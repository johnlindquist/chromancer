This file is a merged representation of the entire codebase, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
.claude/
  settings.local.json
.devcontainer/
  devcontainer.json
  Dockerfile
  init-firewall.sh
.github/
  workflows/
    README.md
    release.yml
bin/
  run.js
examples/
  form-automation.yml
  login-workflow.yml
  scraping-workflow.yml
src/
  commands/
    assert.ts
    click.ts
    config.ts
    cookies.ts
    evaluate.ts
    examples.ts
    export.ts
    fill.ts
    go.ts
    hover.ts
    init.ts
    interactive.ts
    navigate.ts
    network.ts
    pdf.ts
    quick.ts
    record.ts
    repl.ts
    run.ts
    screenshot.ts
    scroll.ts
    select.ts
    sessions.ts
    shot.ts
    spawn.ts
    stop.ts
    store.ts
    type.ts
    wait-for-login.ts
    wait.ts
  types/
    inquirer-autocomplete-prompt.d.ts
    schema.ts
  utils/
    config.ts
    error-tips.ts
    errors.ts
    evaluation.ts
    progress.ts
    selectors.ts
  base.ts
  session.ts
test/
  fixtures/
    buttons.html
    click-edge.html
    complex-workflow.html
    dynamic.html
    form.html
    index.html
    navigation-edge.html
    selects.html
    type-edge.html
  utils/
    errors.test.js
    evaluation.test.js
    selectors.test.js
  assert.test.js
  chromancer.test.js
  click.test.js
  edge-cases.test.js
  evaluate.test.js
  hover.test.js
  integration-tests.js
  interactive.test.js
  mock-chrome-test.js
  navigate.test.js
  new-features.test.js
  README.md
  refactor-test.js
  regression-tests.js
  run-tests.js
  screenshot.test.js
  select.test.js
  setup.js
  simple-wait-test.js
  store.test.js
  test-cli-intellisense.js
  test-enhanced-features.js
  test-error-tips-unit.js
  test-error-tips.js
  test-server.js
  test-suite.js
  test-utils.js
  test-working-features.js
  test-yaml-workflows.js
  type.test.js
  unit-tests.js
  wait.test.js
.gitignore
.npmignore
.releaserc.json
CLAUDE.md
docker-chrome-setup.bat
docker-chrome-setup.sh
ENHANCED_FEATURES.md
LICENSE
NEW_FEATURES_IMPLEMENTED.md
NEW_FEATURES.md
PACKAGE_SUMMARY.md
package.json
PROPOSED_FEATURES.md
PUBLISHING.md
README.md
REFACTORING_SUMMARY.md
run-chromancer-tests.sh
TEST_SUMMARY.md
test-cli.bat
test-cli.sh
TESTING.md
tsconfig.json
UX_IMPROVEMENTS.md
verify-all.bat
verify-all.sh
vitest.config.js
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/commands/config.ts">
import { Args, Flags } from '@oclif/core'
import { Command } from '@oclif/core'
import { config } from '../utils/config.js'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
}

export default class Config extends Command {
  static description = 'Manage chromancer configuration'

  static examples = [
    '<%= config.bin %> <%= command.id %> get chrome.port',
    '<%= config.bin %> <%= command.id %> set chrome.port 9223',
    '<%= config.bin %> <%= command.id %> set ui.colorOutput false',
    '<%= config.bin %> <%= command.id %> list',
    '<%= config.bin %> <%= command.id %> reset',
  ]

  static args = {
    action: Args.string({
      description: 'Config action',
      required: true,
      options: ['get', 'set', 'list', 'reset', 'path'],
    }),
    key: Args.string({
      description: 'Configuration key (e.g., chrome.port)',
    }),
    value: Args.string({
      description: 'Value to set',
    }),
  }

  static flags = {
    json: Flags.boolean({
      description: 'Output in JSON format',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Config)
    
    switch (args.action) {
      case 'get':
        await this.getConfig(args.key!, flags.json)
        break
        
      case 'set':
        await this.setConfig(args.key!, args.value!)
        break
        
      case 'list':
        await this.listConfig(flags.json)
        break
        
      case 'reset':
        await this.resetConfig()
        break
        
      case 'path':
        this.showPath()
        break
        
      default:
        this.error(`Unknown action: ${args.action}`)
    }
  }

  private async getConfig(key: string, json: boolean): Promise<void> {
    if (!key) {
      this.error('Key is required for get action')
    }
    
    const value = await config.get(key)
    
    if (value === undefined) {
      this.warn(`Configuration key not found: ${key}`)
      return
    }
    
    if (json) {
      console.log(JSON.stringify(value))
    } else {
      console.log(`${chalk.cyan(key)}: ${JSON.stringify(value, null, 2)}`)
    }
  }

  private async setConfig(key: string, value: string): Promise<void> {
    if (!key || !value) {
      this.error('Key and value are required for set action')
    }
    
    // Try to parse value as JSON
    let parsedValue: any = value
    try {
      parsedValue = JSON.parse(value)
    } catch {
      // Keep as string if not valid JSON
    }
    
    await config.set(key, parsedValue)
    console.log(chalk.green(`‚úÖ Set ${key} = ${JSON.stringify(parsedValue)}`))
  }

  private async listConfig(json: boolean): Promise<void> {
    const configData = await config.load()
    
    if (json) {
      console.log(JSON.stringify(configData, null, 2))
    } else {
      console.log(chalk.cyan('\nüìã Current Configuration:\n'))
      this.printConfig(configData)
    }
  }

  private printConfig(obj: any, prefix = ''): void {
    Object.entries(obj).forEach(([key, value]) => {
      const fullKey = prefix ? `${prefix}.${key}` : key
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        console.log(chalk.blue(`${fullKey}:`))
        this.printConfig(value, fullKey)
      } else {
        console.log(`  ${chalk.gray(fullKey)}: ${JSON.stringify(value)}`)
      }
    })
  }

  private async resetConfig(): Promise<void> {
    console.log(chalk.yellow('‚ö†Ô∏è  This will reset all configuration to defaults'))
    
    // Simple confirmation
    console.log('\nPress Enter to confirm or Ctrl+C to cancel')
    await new Promise(resolve => {
      process.stdin.once('data', resolve)
      process.stdin.resume()
    })
    
    await config.reset()
    console.log(chalk.green('‚úÖ Configuration reset to defaults'))
  }

  private showPath(): void {
    console.log(chalk.cyan('üìÅ Config file location:'))
    console.log(config.getConfigPath())
  }
}
</file>

<file path="src/commands/examples.ts">
import { Args, Flags } from '@oclif/core'
import { Command } from '@oclif/core'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
}

interface Example {
  title: string
  commands: string[]
  description?: string
}

export default class Examples extends Command {
  static description = 'Show example recipes for common tasks'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> login',
    '<%= config.bin %> <%= command.id %> scraping',
    '<%= config.bin %> <%= command.id %> testing',
  ]

  static args = {
    topic: Args.string({
      description: 'Topic to show examples for',
      options: ['login', 'scraping', 'testing', 'forms', 'automation', 'monitoring'],
    }),
  }

  static flags = {
    list: Flags.boolean({
      char: 'l',
      description: 'List all available topics',
      default: false,
    }),
  }

  private examples: Record<string, Example> = {
    login: {
      title: 'Login & Authentication',
      description: 'Handle login flows and authenticated sessions',
      commands: [
        '# Method 1: Interactive login with profile',
        'chromancer spawn --profile work',
        'chromancer wait-for-login https://github.com/login',
        'chromancer navigate https://github.com/settings',
        '',
        '# Method 2: Automated login with workflow',
        'cat > github-login.yml << EOF',
        '- navigate: https://github.com/login',
        '- type:',
        '    selector: input[name="login"]',
        '    text: ${USERNAME}',
        '- type:',
        '    selector: input[name="password"]',
        '    text: ${PASSWORD}',
        '- click: input[type="submit"]',
        '- wait:',
        '    url: https://github.com',
        'EOF',
        'chromancer run github-login.yml --var USERNAME=you --var PASSWORD=secret',
      ],
    },
    scraping: {
      title: 'Web Scraping',
      description: 'Extract data from websites',
      commands: [
        '# Quick data extraction',
        'chromancer quick extract https://news.ycombinator.com ".titleline a" --json > stories.json',
        '',
        '# Export table data as CSV',
        'chromancer navigate https://example.com/data',
        'chromancer export --format csv --selector "table#results" --output data.csv',
        '',
        '# Complex scraping workflow',
        'cat > scraper.yml << EOF',
        '- navigate: https://example.com/products',
        '- wait: .product-list',
        '- evaluate: |',
        '    Array.from(document.querySelectorAll(".product")).map(p => ({',
        '      name: p.querySelector(".name")?.textContent,',
        '      price: p.querySelector(".price")?.textContent,',
        '      link: p.querySelector("a")?.href',
        '    }))',
        '- export:',
        '    format: json',
        '    output: products.json',
        'EOF',
        'chromancer run scraper.yml',
      ],
    },
    testing: {
      title: 'Testing & Monitoring',
      description: 'Test websites and monitor performance',
      commands: [
        '# Quick site test',
        'chromancer quick test example.com',
        '',
        '# Visual regression test',
        'chromancer navigate https://example.com',
        'chromancer screenshot baseline.png',
        '# ... make changes ...',
        'chromancer screenshot current.png',
        '',
        '# Performance monitoring',
        'chromancer navigate https://example.com',
        'chromancer evaluate "performance.timing" --json > perf.json',
        '',
        '# Network monitoring',
        'chromancer network --filter "api" --type xhr --output api-calls.json',
      ],
    },
    forms: {
      title: 'Form Automation',
      description: 'Fill and submit forms automatically',
      commands: [
        '# Auto-fill with generated data',
        'chromancer navigate https://example.com/signup',
        'chromancer fill --auto-generate --submit',
        '',
        '# Fill with specific data',
        'chromancer fill --data \'{"email": "test@example.com", "name": "Test User"}\'',
        '',
        '# Complex form workflow',
        'cat > form-flow.yml << EOF',
        '- navigate: https://example.com/application',
        '- fill:',
        '    form:',
        '      firstName: John',
        '      lastName: Doe',
        '      email: john@example.com',
        '- select:',
        '    selector: select[name="country"]',
        '    value: US',
        '- click: input[type="checkbox"][name="terms"]',
        '- screenshot: form-complete.png',
        '- click: button[type="submit"]',
        'EOF',
        'chromancer run form-flow.yml',
      ],
    },
    automation: {
      title: 'General Automation',
      description: 'Automate repetitive tasks',
      commands: [
        '# Daily screenshot',
        'chromancer spawn --headless',
        'chromancer run daily-screenshots.yml',
        '',
        '# Batch PDF generation',
        'for url in site1.com site2.com site3.com; do',
        '  chromancer navigate "https://$url"',
        '  chromancer pdf --output "$url.pdf"',
        'done',
        '',
        '# Cookie management',
        'chromancer cookies save --output session.json',
        '# ... later ...',
        'chromancer cookies load --file session.json',
        'chromancer navigate https://example.com/dashboard',
        '',
        '# Record and replay',
        'chromancer record --output actions.json',
        '# ... perform actions in browser ...',
        '# Press Ctrl+C to stop',
        'chromancer record --output actions.js --format js',
      ],
    },
    monitoring: {
      title: 'Monitoring & Alerts',
      description: 'Monitor websites for changes',
      commands: [
        '# Check for content changes',
        'chromancer navigate https://example.com/status',
        'chromancer evaluate "document.querySelector(\'.status\').textContent" > status.txt',
        'diff status.txt previous-status.txt || echo "Status changed!"',
        '',
        '# Monitor for specific text',
        'cat > monitor.yml << EOF',
        '- navigate: https://example.com/products',
        '- wait:',
        '    text: "Out of Stock"',
        '    timeout: 5000',
        '- evaluate: |',
        '    console.log("Item is out of stock!")',
        'EOF',
        'chromancer run monitor.yml --continue-on-error',
        '',
        '# Network performance monitoring',
        'chromancer network --duration 60000 --output network-report.json',
        'cat network-report.json | jq \'.[] | select(.duration > 1000)\'',
      ],
    },
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Examples)
    
    if (flags.list || !args.topic) {
      this.showTopics()
      return
    }
    
    const example = this.examples[args.topic]
    if (!example) {
      this.error(`Unknown topic: ${args.topic}\nRun 'chromancer examples --list' to see available topics`)
    }
    
    this.showExample(args.topic, example)
  }

  private showTopics(): void {
    console.log(chalk.bold('\nüìö Available Example Topics\n'))
    
    Object.entries(this.examples).forEach(([key, example]) => {
      console.log(`${chalk.cyan(key.padEnd(12))} - ${example.title}`)
      if (example.description) {
        console.log(chalk.gray(`${''.padEnd(14)} ${example.description}`))
      }
    })
    
    console.log(chalk.gray('\nRun \'chromancer examples <topic>\' to see examples'))
    console.log()
  }

  private showExample(topic: string, example: Example): void {
    console.log()
    console.log(chalk.bold(chalk.cyan(`üìñ ${example.title}`)))
    if (example.description) {
      console.log(chalk.gray(example.description))
    }
    console.log()
    
    let inCodeBlock = false
    
    example.commands.forEach(line => {
      if (line.startsWith('#')) {
        // Comment
        console.log(chalk.green(line))
      } else if (line === '') {
        console.log()
      } else if (line.includes('<<') && line.includes('EOF')) {
        // Start of heredoc
        console.log(chalk.gray(line))
        inCodeBlock = true
      } else if (line === 'EOF') {
        // End of heredoc
        console.log(chalk.gray(line))
        inCodeBlock = false
      } else if (inCodeBlock) {
        // Inside heredoc
        console.log(chalk.yellow(line))
      } else {
        // Command
        console.log(line)
      }
    })
    
    console.log()
    console.log(chalk.gray(`Try more examples: chromancer examples --list`))
    console.log()
  }
}
</file>

<file path="src/commands/go.ts">
import { Args } from '@oclif/core'
import Navigate from './navigate.js'

export default class Go extends Navigate {
  static description = 'Alias for navigate - go to a URL'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> example.com',
  ]

  static args = {
    url: Args.string({
      description: 'URL to navigate to',
      required: true,
    }),
  }

  static flags = Navigate.flags

  async run(): Promise<void> {
    // Simply run the parent navigate command
    await super.run()
  }
}
</file>

<file path="src/commands/init.ts">
import { Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
}

export default class Init extends BaseCommand {
  static description = 'Initialize chromancer and set up your environment'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --skip-chrome-check',
    '<%= config.bin %> <%= command.id %> --example-workflows',
  ]

  static flags = {
    'skip-chrome-check': Flags.boolean({
      description: 'Skip Chrome connectivity check',
      default: false,
    }),
    'example-workflows': Flags.boolean({
      description: 'Create example workflow files',
      default: false,
    }),
    'config-only': Flags.boolean({
      description: 'Only create config file',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Init)
    
    this.showWelcome()
    
    // Step 1: Check Chrome
    if (!flags['skip-chrome-check'] && !flags['config-only']) {
      await this.checkChrome()
    }
    
    // Step 2: Create config
    await this.createConfig()
    
    // Step 3: Create examples if requested
    if (flags['example-workflows']) {
      await this.createExamples()
    }
    
    // Step 4: Show next steps
    this.showNextSteps()
  }

  private showWelcome(): void {
    console.log()
    console.log(chalk.bold(chalk.cyan('üßô Welcome to Chromancer!')))
    console.log(chalk.gray('The magical Chrome automation tool'))
    console.log()
    console.log('This wizard will help you:')
    console.log('  ‚Ä¢ Check Chrome connectivity')
    console.log('  ‚Ä¢ Create a configuration file')
    console.log('  ‚Ä¢ Set up example workflows')
    console.log()
  }

  private async checkChrome(): Promise<void> {
    this.log(chalk.blue('üì° Checking Chrome connectivity...'))
    
    try {
      // Try default port
      await this.connectToChrome(9222, 'localhost', false)
      this.log(chalk.green('‚úÖ Chrome is running and accessible on port 9222'))
    } catch (error) {
      this.log(chalk.yellow('‚ö†Ô∏è  Chrome is not running or not accessible'))
      this.log()
      this.log('To start Chrome with remote debugging:')
      this.log()
      this.log(chalk.gray('  # Option 1: Use chromancer'))
      this.log('  chromancer spawn --headless')
      this.log()
      this.log(chalk.gray('  # Option 2: Start Chrome manually'))
      this.log('  chrome --remote-debugging-port=9222')
      this.log()
      this.log(chalk.gray('  # Option 3: Use Docker'))
      this.log('  docker run -d -p 9222:9222 zenika/alpine-chrome \\')
      this.log('    --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222')
      this.log()
    }
  }

  private async createConfig(): Promise<void> {
    const configPath = path.join(os.homedir(), '.chromancer.json')
    
    // Check if config exists
    try {
      await fs.access(configPath)
      this.log(chalk.yellow(`‚ö†Ô∏è  Config file already exists: ${configPath}`))
      return
    } catch {
      // File doesn't exist, create it
    }
    
    const defaultConfig = {
      chrome: {
        port: 9222,
        host: 'localhost',
        defaultTimeout: 30000,
      },
      commands: {
        screenshot: {
          path: './screenshots',
          fullPage: true,
        },
        pdf: {
          path: './pdfs',
          format: 'A4',
        },
        export: {
          path: './exports',
        },
      },
      workflows: {
        continueOnError: false,
        variablePrefix: '${',
        variableSuffix: '}',
      },
      ui: {
        colorOutput: true,
        verboseErrors: true,
        showTips: true,
      },
    }
    
    await fs.writeFile(
      configPath,
      JSON.stringify(defaultConfig, null, 2)
    )
    
    this.log(chalk.green(`‚úÖ Created config file: ${configPath}`))
    this.log(chalk.gray('   You can edit this file to customize chromancer behavior'))
  }

  private async createExamples(): Promise<void> {
    const examplesDir = path.join(process.cwd(), 'chromancer-examples')
    
    try {
      await fs.mkdir(examplesDir, { recursive: true })
    } catch (error) {
      this.warn('Could not create examples directory')
      return
    }
    
    // Create a simple example
    const simpleExample = `# Simple workflow example
# Run with: chromancer run simple.yml

- navigate: https://example.com
- wait:
    selector: h1
    timeout: 5000
- screenshot: example-home.png
- click: a[href*="more"]
- wait: 
    time: 2000
- screenshot: example-more.png
`
    
    await fs.writeFile(
      path.join(examplesDir, 'simple.yml'),
      simpleExample
    )
    
    // Create a form example
    const formExample = `# Form automation example
# Run with: chromancer run form.yml --var EMAIL=test@example.com

- navigate: https://example.com/contact
- wait:
    selector: form
- fill:
    form:
      name: "Test User"
      email: \${EMAIL}
      message: "This is an automated test"
- screenshot: form-filled.png
# Uncomment to submit:
# - click: button[type="submit"]
`
    
    await fs.writeFile(
      path.join(examplesDir, 'form.yml'),
      formExample
    )
    
    // Create a scraping example
    const scrapingExample = `# Web scraping example
# Run with: chromancer run scraping.yml

- navigate: https://news.ycombinator.com
- wait:
    selector: .itemlist
- evaluate: |
    // Extract top stories
    Array.from(document.querySelectorAll('.athing')).slice(0, 10).map(item => ({
      title: item.querySelector('.titleline a')?.textContent,
      link: item.querySelector('.titleline a')?.href,
      rank: item.querySelector('.rank')?.textContent
    }))
- export:
    format: json
    output: hn-stories.json
`
    
    await fs.writeFile(
      path.join(examplesDir, 'scraping.yml'),
      scrapingExample
    )
    
    this.log(chalk.green(`‚úÖ Created example workflows in: ${examplesDir}`))
    this.log(chalk.gray('   ‚Ä¢ simple.yml    - Basic navigation'))
    this.log(chalk.gray('   ‚Ä¢ form.yml      - Form automation'))
    this.log(chalk.gray('   ‚Ä¢ scraping.yml  - Data extraction'))
  }

  private showNextSteps(): void {
    console.log()
    console.log(chalk.bold(chalk.green('üéâ Setup complete!')))
    console.log()
    console.log('Next steps:')
    console.log()
    console.log('1. Start Chrome (if not running):')
    console.log(chalk.cyan('   chromancer spawn'))
    console.log()
    console.log('2. Try a simple command:')
    console.log(chalk.cyan('   chromancer navigate https://example.com'))
    console.log(chalk.cyan('   chromancer screenshot example.png'))
    console.log()
    console.log('3. Run a workflow:')
    console.log(chalk.cyan('   chromancer run chromancer-examples/simple.yml'))
    console.log()
    console.log('4. Explore more commands:')
    console.log(chalk.cyan('   chromancer --help'))
    console.log()
    console.log(chalk.gray('üìö Full documentation: https://chromancer.dev'))
    console.log()
  }
}
</file>

<file path="src/commands/quick.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { ProgressIndicator } from '../utils/progress.js'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
}

export default class Quick extends BaseCommand {
  static description = 'Quick commands for common tasks'

  static examples = [
    '<%= config.bin %> <%= command.id %> check example.com',
    '<%= config.bin %> <%= command.id %> capture https://example.com output.png',
    '<%= config.bin %> <%= command.id %> extract https://news.site "article h2"',
  ]

  static args = {
    action: Args.string({
      description: 'Quick action to perform',
      required: true,
      options: ['check', 'capture', 'extract', 'test'],
    }),
    target: Args.string({
      description: 'URL or target for the action',
      required: true,
    }),
    extra: Args.string({
      description: 'Extra parameter (output file, selector, etc)',
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    json: Flags.boolean({
      description: 'Output in JSON format',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Quick)
    
    // Connect to Chrome
    const progress = new ProgressIndicator('Connecting to Chrome...')
    progress.start()
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    progress.stop()
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    switch (args.action) {
      case 'check':
        await this.checkSite(args.target)
        break
        
      case 'capture':
        await this.captureSite(args.target, args.extra || 'quick-capture.png')
        break
        
      case 'extract':
        await this.extractData(args.target, args.extra || 'body')
        break
        
      case 'test':
        await this.testSite(args.target)
        break
        
      default:
        this.error(`Unknown action: ${args.action}`)
    }
  }

  private async checkSite(url: string): Promise<void> {
    const progress = new ProgressIndicator('Checking site...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      const startTime = Date.now()
      await this.page!.goto(url, { waitUntil: 'load' })
      const loadTime = Date.now() - startTime
      
      // Get page info
      const title = await this.page!.title()
      const metrics = await this.page!.evaluate(() => ({
        links: document.querySelectorAll('a').length,
        images: document.querySelectorAll('img').length,
        scripts: document.querySelectorAll('script').length,
        styles: document.querySelectorAll('link[rel="stylesheet"], style').length,
      }))
      
      progress.stop()
      
      console.log(chalk.green('\n‚úÖ Site is accessible!\n'))
      console.log(`üìç URL: ${chalk.blue(this.page!.url())}`)
      console.log(`üìÑ Title: ${title}`)
      console.log(`‚è±Ô∏è  Load time: ${loadTime}ms`)
      console.log(`\nüìä Page stats:`)
      console.log(`   ‚Ä¢ Links: ${metrics.links}`)
      console.log(`   ‚Ä¢ Images: ${metrics.images}`)
      console.log(`   ‚Ä¢ Scripts: ${metrics.scripts}`)
      console.log(`   ‚Ä¢ Styles: ${metrics.styles}`)
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to check site: ${error.message}`)
    }
  }

  private async captureSite(url: string, output: string): Promise<void> {
    const progress = new ProgressIndicator('Capturing page...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      await this.page!.goto(url, { waitUntil: 'networkidle' })
      progress.update('Taking screenshot...')
      
      // Take screenshot
      await this.page!.screenshot({
        path: output,
        fullPage: true,
      })
      
      progress.stop()
      console.log(chalk.green(`‚úÖ Captured to: ${output}`))
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to capture: ${error.message}`)
    }
  }

  private async extractData(url: string, selector: string): Promise<void> {
    const progress = new ProgressIndicator('Extracting data...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      await this.page!.goto(url, { waitUntil: 'load' })
      progress.update('Finding elements...')
      
      // Extract data
      const data = await this.page!.evaluate((sel) => {
        const elements = document.querySelectorAll(sel)
        return Array.from(elements).map(el => ({
          text: el.textContent?.trim(),
          tag: el.tagName.toLowerCase(),
          href: (el as any).href,
          src: (el as any).src,
        }))
      }, selector)
      
      progress.stop()
      
      if (data.length === 0) {
        this.warn(`No elements found matching: ${selector}`)
        return
      }
      
      const { flags } = await this.parse(Quick)
      
      if (flags.json) {
        console.log(JSON.stringify(data, null, 2))
      } else {
        console.log(chalk.green(`\n‚úÖ Found ${data.length} elements:\n`))
        data.slice(0, 10).forEach((item, i) => {
          console.log(`${i + 1}. [${chalk.blue(item.tag)}] ${item.text}`)
          if (item.href) console.log(`   ${chalk.gray('‚Üí')} ${item.href}`)
        })
        if (data.length > 10) {
          console.log(chalk.gray(`\n... and ${data.length - 10} more`))
        }
      }
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to extract: ${error.message}`)
    }
  }

  private async testSite(url: string): Promise<void> {
    console.log(chalk.cyan('\nüß™ Running site tests...\n'))
    
    const tests = [
      { name: 'Accessibility', fn: () => this.testAccessibility(url) },
      { name: 'Performance', fn: () => this.testPerformance(url) },
      { name: 'Mobile View', fn: () => this.testMobile(url) },
      { name: 'Console Errors', fn: () => this.testConsole(url) },
    ]
    
    let passed = 0
    
    for (const test of tests) {
      try {
        const progress = new ProgressIndicator(`Testing ${test.name}...`)
        progress.start()
        const result = await test.fn()
        progress.stop()
        
        if (result.passed) {
          console.log(chalk.green(`‚úÖ ${test.name}: ${result.message}`))
          passed++
        } else {
          console.log(chalk.yellow(`‚ö†Ô∏è  ${test.name}: ${result.message}`))
        }
      } catch (error: any) {
        console.log(chalk.red(`‚ùå ${test.name}: ${error.message}`))
      }
    }
    
    console.log(chalk.cyan(`\nüìä Test Summary: ${passed}/${tests.length} passed\n`))
  }

  private async testAccessibility(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    await this.page!.goto(url, { waitUntil: 'load' })
    
    const results = await this.page!.evaluate(() => {
      const issues = []
      
      // Check images for alt text
      const imagesWithoutAlt = document.querySelectorAll('img:not([alt])')
      if (imagesWithoutAlt.length > 0) {
        issues.push(`${imagesWithoutAlt.length} images without alt text`)
      }
      
      // Check headings hierarchy
      const h1Count = document.querySelectorAll('h1').length
      if (h1Count !== 1) {
        issues.push(`${h1Count} H1 tags (should be 1)`)
      }
      
      // Check form labels
      const inputsWithoutLabels = document.querySelectorAll('input:not([aria-label]):not([id])')
      if (inputsWithoutLabels.length > 0) {
        issues.push(`${inputsWithoutLabels.length} inputs without labels`)
      }
      
      return issues
    })
    
    return {
      passed: results.length === 0,
      message: results.length === 0 ? 'No major issues found' : results.join(', ')
    }
  }

  private async testPerformance(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    
    const startTime = Date.now()
    await this.page!.goto(url, { waitUntil: 'networkidle' })
    const loadTime = Date.now() - startTime
    
    const metrics = await this.page!.evaluate(() => {
      const perf = (performance as any)
      return {
        resources: performance.getEntriesByType('resource').length,
        jsHeap: perf.memory ? Math.round(perf.memory.usedJSHeapSize / 1048576) : 0,
      }
    })
    
    return {
      passed: loadTime < 3000,
      message: `Load time: ${loadTime}ms, Resources: ${metrics.resources}, JS Heap: ${metrics.jsHeap}MB`
    }
  }

  private async testMobile(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    
    // Set mobile viewport
    await this.page!.setViewportSize({ width: 375, height: 667 })
    await this.page!.goto(url, { waitUntil: 'load' })
    
    const results = await this.page!.evaluate(() => {
      const issues = []
      
      // Check viewport meta tag
      const viewport = document.querySelector('meta[name="viewport"]')
      if (!viewport) {
        issues.push('No viewport meta tag')
      }
      
      // Check for horizontal scroll
      if (document.documentElement.scrollWidth > window.innerWidth) {
        issues.push('Horizontal scroll detected')
      }
      
      return issues
    })
    
    // Reset viewport
    await this.page!.setViewportSize({ width: 1280, height: 720 })
    
    return {
      passed: results.length === 0,
      message: results.length === 0 ? 'Mobile-friendly' : results.join(', ')
    }
  }

  private async testConsole(url: string): Promise<any> {
    const errors: string[] = []
    
    this.page!.on('console', (msg) => {
      if (msg.type() === 'error') {
        errors.push(msg.text())
      }
    })
    
    if (!url.startsWith('http')) url = 'https://' + url
    await this.page!.goto(url, { waitUntil: 'load' })
    
    return {
      passed: errors.length === 0,
      message: errors.length === 0 ? 'No console errors' : `${errors.length} console errors`
    }
  }
}
</file>

<file path="src/commands/shot.ts">
import Screenshot from './screenshot.js'

export default class Shot extends Screenshot {
  static description = 'Alias for screenshot - capture the page'

  static examples = [
    '<%= config.bin %> <%= command.id %> output.png',
    '<%= config.bin %> <%= command.id %> --selector ".main-content"',
  ]

  static args = Screenshot.args
  static flags = Screenshot.flags

  async run(): Promise<void> {
    // Simply run the parent screenshot command
    await super.run()
  }
}
</file>

<file path="src/utils/config.ts">
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

export interface ChromancerConfig {
  chrome?: {
    port?: number
    host?: string
    defaultTimeout?: number
    launchOptions?: {
      headless?: boolean
      args?: string[]
    }
  }
  commands?: {
    screenshot?: {
      path?: string
      fullPage?: boolean
      type?: 'png' | 'jpeg' | 'webp'
    }
    pdf?: {
      path?: string
      format?: string
      landscape?: boolean
    }
    export?: {
      path?: string
      defaultFormat?: string
    }
    record?: {
      outputPath?: string
      maxDuration?: number
    }
  }
  workflows?: {
    continueOnError?: boolean
    variablePrefix?: string
    variableSuffix?: string
    defaultTimeout?: number
  }
  ui?: {
    colorOutput?: boolean
    verboseErrors?: boolean
    showTips?: boolean
    progressIndicators?: boolean
  }
  aliases?: Record<string, string>
}

class ConfigManager {
  private configPath: string
  private config?: ChromancerConfig
  
  constructor() {
    this.configPath = path.join(os.homedir(), '.chromancer.json')
  }
  
  async load(): Promise<ChromancerConfig> {
    if (this.config) {
      return this.config
    }
    
    try {
      const content = await fs.readFile(this.configPath, 'utf-8')
      this.config = JSON.parse(content)
      return this.config!
    } catch (error) {
      // Return default config if file doesn't exist
      this.config = this.getDefaultConfig()
      return this.config
    }
  }
  
  async save(config: ChromancerConfig): Promise<void> {
    this.config = config
    await fs.writeFile(
      this.configPath,
      JSON.stringify(config, null, 2)
    )
  }
  
  async get<T>(path: string, defaultValue?: T): Promise<T | undefined> {
    const config = await this.load()
    
    const keys = path.split('.')
    let value: any = config
    
    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key]
      } else {
        return defaultValue
      }
    }
    
    return value as T
  }
  
  async set(path: string, value: any): Promise<void> {
    const config = await this.load()
    
    const keys = path.split('.')
    let current: any = config
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i]
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {}
      }
      current = current[key]
    }
    
    current[keys[keys.length - 1]] = value
    await this.save(config)
  }
  
  private getDefaultConfig(): ChromancerConfig {
    return {
      chrome: {
        port: 9222,
        host: 'localhost',
        defaultTimeout: 30000,
        launchOptions: {
          headless: false,
          args: [],
        },
      },
      commands: {
        screenshot: {
          path: './screenshots',
          fullPage: true,
          type: 'png',
        },
        pdf: {
          path: './pdfs',
          format: 'A4',
          landscape: false,
        },
        export: {
          path: './exports',
          defaultFormat: 'json',
        },
        record: {
          outputPath: './recordings',
          maxDuration: 300000, // 5 minutes
        },
      },
      workflows: {
        continueOnError: false,
        variablePrefix: '${',
        variableSuffix: '}',
        defaultTimeout: 30000,
      },
      ui: {
        colorOutput: true,
        verboseErrors: true,
        showTips: true,
        progressIndicators: true,
      },
      aliases: {
        'g': 'go',
        'n': 'navigate',
        's': 'screenshot',
        'c': 'click',
        't': 'type',
        'w': 'wait',
        'e': 'evaluate',
      },
    }
  }
  
  async reset(): Promise<void> {
    this.config = this.getDefaultConfig()
    await this.save(this.config)
  }
  
  getConfigPath(): string {
    return this.configPath
  }
}

// Singleton instance
export const config = new ConfigManager()

// Helper to apply config to command flags
export async function applyConfigToFlags(command: string, flags: any): Promise<any> {
  const configData = await config.load()
  
  // Apply command-specific config
  const commandConfig = configData.commands?.[command as keyof typeof configData.commands]
  if (commandConfig) {
    Object.entries(commandConfig).forEach(([key, value]) => {
      if (!(key in flags) || flags[key] === undefined) {
        flags[key] = value
      }
    })
  }
  
  // Apply global Chrome config
  if (configData.chrome) {
    if (!flags.port && configData.chrome.port) {
      flags.port = configData.chrome.port
    }
    if (!flags.host && configData.chrome.host) {
      flags.host = configData.chrome.host
    }
  }
  
  return flags
}
</file>

<file path="src/utils/progress.ts">
export class ProgressIndicator {
  private spinner = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
  private currentIndex = 0
  private interval?: NodeJS.Timeout
  private message: string
  
  constructor(message: string) {
    this.message = message
  }
  
  start(): void {
    this.interval = setInterval(() => {
      process.stdout.write(`\r${this.spinner[this.currentIndex]} ${this.message}`)
      this.currentIndex = (this.currentIndex + 1) % this.spinner.length
    }, 80)
  }
  
  update(message: string): void {
    this.message = message
  }
  
  stop(finalMessage?: string): void {
    if (this.interval) {
      clearInterval(this.interval)
      process.stdout.write('\r' + ' '.repeat(this.message.length + 3) + '\r')
      if (finalMessage) {
        console.log(finalMessage)
      }
    }
  }
}

export class ProgressBar {
  private width: number
  private total: number
  private current = 0
  private description: string
  
  constructor(description: string, total: number, width = 30) {
    this.description = description
    this.total = total
    this.width = width
  }
  
  update(current: number): void {
    this.current = Math.min(current, this.total)
    this.render()
  }
  
  increment(): void {
    this.update(this.current + 1)
  }
  
  private render(): void {
    const percent = this.current / this.total
    const filled = Math.floor(this.width * percent)
    const empty = this.width - filled
    
    const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty)
    const percentStr = `${Math.floor(percent * 100)}%`
    
    process.stdout.write(
      `\r${this.description} [${bar}] ${percentStr} (${this.current}/${this.total})`
    )
    
    if (this.current === this.total) {
      console.log() // New line when complete
    }
  }
  
  complete(message?: string): void {
    this.update(this.total)
    if (message) {
      console.log(message)
    }
  }
}
</file>

<file path="UX_IMPROVEMENTS.md">
# UX Improvements for Chromancer

## Overview
Comprehensive user experience improvements have been added to make chromancer more intuitive, helpful, and efficient for both beginners and power users.

## New Features

### 1. üßô Onboarding & Setup Wizard (`init` command)
A friendly initialization command that helps new users get started quickly.

**Features:**
- Welcome message with clear guidance
- Chrome connectivity check
- Automatic config file creation
- Optional example workflow generation
- Next steps guidance

**Usage:**
```bash
chromancer init                    # Full setup wizard
chromancer init --example-workflows # Include example files
chromancer init --config-only      # Just create config
```

### 2. üìö Interactive Examples (`examples` command)
Rich, categorized examples for common automation tasks.

**Categories:**
- **login** - Authentication workflows
- **scraping** - Data extraction patterns
- **testing** - Site testing and monitoring
- **forms** - Form automation
- **automation** - General automation tasks
- **monitoring** - Change detection and alerts

**Usage:**
```bash
chromancer examples --list     # Show all categories
chromancer examples scraping   # Show scraping examples
chromancer examples forms      # Show form examples
```

### 3. ‚ö° Quick Commands (`quick` command)
Simplified commands for common tasks with built-in intelligence.

**Actions:**
- **check** - Quick site health check
- **capture** - Fast screenshot with auto-naming
- **extract** - Smart data extraction
- **test** - Comprehensive site testing

**Usage:**
```bash
chromancer quick check example.com
chromancer quick capture https://example.com screenshot.png
chromancer quick extract https://news.site "h2.headline"
chromancer quick test example.com
```

### 4. üèÉ Command Aliases
Shorter aliases for frequently used commands:
- `go` ‚Üí `navigate`
- `shot` ‚Üí `screenshot`

**Usage:**
```bash
chromancer go example.com
chromancer shot output.png
```

### 5. ‚öôÔ∏è Configuration System (`config` command)
Persistent configuration for defaults and preferences.

**Features:**
- Set default values for all commands
- Configure Chrome connection settings
- Customize UI preferences
- Manage workflow defaults

**Usage:**
```bash
chromancer config list                    # Show all settings
chromancer config get chrome.port         # Get specific value
chromancer config set chrome.port 9223    # Set value
chromancer config set ui.colorOutput false # Disable colors
chromancer config reset                   # Reset to defaults
```

**Config Structure:**
```json
{
  "chrome": {
    "port": 9222,
    "host": "localhost",
    "defaultTimeout": 30000
  },
  "commands": {
    "screenshot": {
      "path": "./screenshots",
      "fullPage": true
    },
    "pdf": {
      "format": "A4"
    }
  },
  "workflows": {
    "continueOnError": false,
    "variablePrefix": "${",
    "variableSuffix": "}"
  },
  "ui": {
    "colorOutput": true,
    "verboseErrors": true,
    "showTips": true
  }
}
```

### 6. üìä Progress Indicators
Visual feedback for long-running operations.

**Types:**
- **Spinner** - For indeterminate operations
- **Progress Bar** - For operations with known steps

**Example:**
```
‚†π Connecting to Chrome...
‚†∏ Taking screenshot...
‚úÖ Screenshot saved to: output.png

Exporting data [‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñà‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë‚ñë] 67% (67/100)
```

## Benefits

### For Beginners
- **Guided Setup**: `init` command provides step-by-step onboarding
- **Rich Examples**: Learn by example with categorized recipes
- **Quick Commands**: Start using chromancer without memorizing syntax
- **Clear Feedback**: Progress indicators show what's happening

### For Power Users
- **Configuration**: Set once, use everywhere with persistent config
- **Aliases**: Type less with short command aliases
- **Quick Actions**: Combined operations for efficiency
- **Customization**: Fine-tune behavior through config

### For Everyone
- **Better Discoverability**: Examples command shows what's possible
- **Consistent Experience**: Config ensures predictable behavior
- **Visual Feedback**: Know what's happening with progress indicators
- **Helpful Errors**: Enhanced error messages guide to solutions

## Usage Flow

### First Time User
```bash
# 1. Initialize chromancer
chromancer init

# 2. Start Chrome
chromancer spawn

# 3. Try examples
chromancer examples --list
chromancer examples scraping

# 4. Run quick test
chromancer quick check example.com
```

### Daily Usage
```bash
# Use aliases and quick commands
chromancer go news.site
chromancer quick extract news.site "article h2"
chromancer shot daily-screenshot.png

# Run workflows with config defaults
chromancer run daily-tasks.yml
```

### Advanced Usage
```bash
# Customize behavior
chromancer config set commands.screenshot.type jpeg
chromancer config set workflows.continueOnError true

# Use in scripts with progress
chromancer quick test site1.com site2.com site3.com
```

## Summary

These UX improvements make chromancer:
- **Easier to learn** with examples and guided setup
- **Faster to use** with aliases and quick commands
- **More flexible** with configuration system
- **More informative** with progress indicators
- **More discoverable** with categorized examples

The goal is to reduce the learning curve while increasing productivity for all users.
</file>

<file path=".devcontainer/devcontainer.json">
{
  "name": "Claude Code Sandbox",
  "build": {
    "dockerfile": "Dockerfile",
    "args": {
      "TZ": "${localEnv:TZ:America/Los_Angeles}"
    }
  },
  "runArgs": [
    "--cap-add=NET_ADMIN",
    "--cap-add=NET_RAW"
  ],
  "customizations": {
    "vscode": {
      "extensions": [
        "dbaeumer.vscode-eslint",
        "esbenp.prettier-vscode",
        "eamodio.gitlens"
      ],
      "settings": {
        "editor.formatOnSave": true,
        "editor.defaultFormatter": "esbenp.prettier-vscode",
        "editor.codeActionsOnSave": {
          "source.fixAll.eslint": "explicit"
        },
        "terminal.integrated.defaultProfile.linux": "zsh",
        "terminal.integrated.profiles.linux": {
          "bash": {
            "path": "bash",
            "icon": "terminal-bash"
          },
          "zsh": {
            "path": "zsh"
          }
        }
      }
    }
  },
  "remoteUser": "node",
  "mounts": [
    "source=claude-code-bashhistory,target=/commandhistory,type=volume",
    "source=claude-code-config,target=/home/node/.claude,type=volume"
  ],
  "remoteEnv": {
    "NODE_OPTIONS": "--max-old-space-size=4096",
    "CLAUDE_CONFIG_DIR": "/home/node/.claude",
    "POWERLEVEL9K_DISABLE_GITSTATUS": "true"
  },
  "workspaceMount": "source=${localWorkspaceFolder},target=/workspace,type=bind,consistency=delegated",
  "workspaceFolder": "/workspace",
  "postCreateCommand": "sudo /usr/local/bin/init-firewall.sh"
}
</file>

<file path=".devcontainer/Dockerfile">
FROM node:22.9.0

ARG TZ
ENV TZ="$TZ"

# Install basic development tools and iptables/ipset
RUN apt update && apt install -y less \
  git \
  procps \
  sudo \
  fzf \
  zsh \
  man-db \
  unzip \
  gnupg2 \
  gh \
  iptables \
  ipset \
  iproute2 \
  dnsutils \
  aggregate \
  jq

# Ensure default node user has access to /usr/local/share
RUN mkdir -p /usr/local/share/npm-global && \
  chown -R node:node /usr/local/share

ARG USERNAME=node

# Persist bash history.
RUN SNIPPET="export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
  && mkdir /commandhistory \
  && touch /commandhistory/.bash_history \
  && chown -R $USERNAME /commandhistory

# Set `DEVCONTAINER` environment variable to help with orientation
ENV DEVCONTAINER=true

# Create workspace and config directories and set permissions
RUN mkdir -p /workspace /home/node/.claude && \
  chown -R node:node /workspace /home/node/.claude

WORKDIR /workspace

RUN ARCH=$(dpkg --print-architecture) && \
  wget "https://github.com/dandavison/delta/releases/download/0.18.2/git-delta_0.18.2_${ARCH}.deb" && \
  sudo dpkg -i "git-delta_0.18.2_${ARCH}.deb" && \
  rm "git-delta_0.18.2_${ARCH}.deb"

# Set up non-root user
USER node

# Install global packages
ENV NPM_CONFIG_PREFIX=/usr/local/share/npm-global
ENV PATH=$PATH:/usr/local/share/npm-global/bin

# Set the default shell to zsh rather than sh
ENV SHELL=/bin/zsh

# Default powerline10k theme
RUN sh -c "$(wget -O- https://github.com/deluan/zsh-in-docker/releases/download/v1.2.0/zsh-in-docker.sh)" -- \
  -p git \
  -p fzf \
  -a "source /usr/share/doc/fzf/examples/key-bindings.zsh" \
  -a "source /usr/share/doc/fzf/examples/completion.zsh" \
  -a "export PROMPT_COMMAND='history -a' && export HISTFILE=/commandhistory/.bash_history" \
  -a "alias opus='claude --dangerously-skip-permissions --model opus'" \
  -x

# Install Claude and pnpm
RUN npm install -g @anthropic-ai/claude-code pnpm


# Copy and set up firewall script
COPY init-firewall.sh /usr/local/bin/
USER root
RUN chmod +x /usr/local/bin/init-firewall.sh && \
  echo "node ALL=(root) NOPASSWD: /usr/local/bin/init-firewall.sh" > /etc/sudoers.d/node-firewall && \
  chmod 0440 /etc/sudoers.d/node-firewall
USER node
</file>

<file path=".devcontainer/init-firewall.sh">
#!/bin/bash
set -euo pipefail  # Exit on error, undefined vars, and pipeline failures
IFS=$'\n\t'       # Stricter word splitting

# Flush existing rules and delete existing ipsets
iptables -F
iptables -X
iptables -t nat -F
iptables -t nat -X
iptables -t mangle -F
iptables -t mangle -X
ipset destroy allowed-domains 2>/dev/null || true

# First allow DNS and localhost before any restrictions
# Allow outbound DNS
iptables -A OUTPUT -p udp --dport 53 -j ACCEPT
# Allow inbound DNS responses
iptables -A INPUT -p udp --sport 53 -j ACCEPT
# Allow outbound SSH
iptables -A OUTPUT -p tcp --dport 22 -j ACCEPT
# Allow inbound SSH responses
iptables -A INPUT -p tcp --sport 22 -m state --state ESTABLISHED -j ACCEPT
# Allow localhost
iptables -A INPUT -i lo -j ACCEPT
iptables -A OUTPUT -o lo -j ACCEPT

# Create ipset with CIDR support
ipset create allowed-domains hash:net

# Fetch GitHub meta information and aggregate + add their IP ranges
echo "Fetching GitHub IP ranges..."
gh_ranges=$(curl -s https://api.github.com/meta)
if [ -z "$gh_ranges" ]; then
    echo "ERROR: Failed to fetch GitHub IP ranges"
    exit 1
fi

if ! echo "$gh_ranges" | jq -e '.web and .api and .git' >/dev/null; then
    echo "ERROR: GitHub API response missing required fields"
    exit 1
fi

echo "Processing GitHub IPs..."
while read -r cidr; do
    if [[ ! "$cidr" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}/[0-9]{1,2}$ ]]; then
        echo "ERROR: Invalid CIDR range from GitHub meta: $cidr"
        exit 1
    fi
    echo "Adding GitHub range $cidr"
    ipset add allowed-domains "$cidr"
done < <(echo "$gh_ranges" | jq -r '(.web + .api + .git)[]' | aggregate -q)

# Resolve and add other allowed domains
for domain in \
    "registry.npmjs.org" \
    "api.anthropic.com" \
    "sentry.io" \
    "statsig.anthropic.com" \
    "statsig.com"; do
    echo "Resolving $domain..."
    ips=$(dig +short A "$domain")
    if [ -z "$ips" ]; then
        echo "ERROR: Failed to resolve $domain"
        exit 1
    fi
    
    while read -r ip; do
        if [[ ! "$ip" =~ ^[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}\.[0-9]{1,3}$ ]]; then
            echo "ERROR: Invalid IP from DNS for $domain: $ip"
            exit 1
        fi
        echo "Adding $ip for $domain"
        ipset add allowed-domains "$ip"
    done < <(echo "$ips")
done

# Get host IP from default route
HOST_IP=$(ip route | grep default | cut -d" " -f3)
if [ -z "$HOST_IP" ]; then
    echo "ERROR: Failed to detect host IP"
    exit 1
fi

HOST_NETWORK=$(echo "$HOST_IP" | sed "s/\.[0-9]*$/.0\/24/")
echo "Host network detected as: $HOST_NETWORK"

# Set up remaining iptables rules
iptables -A INPUT -s "$HOST_NETWORK" -j ACCEPT
iptables -A OUTPUT -d "$HOST_NETWORK" -j ACCEPT

# Set default policies to DROP first
iptables -P INPUT DROP
iptables -P FORWARD DROP
iptables -P OUTPUT DROP

# First allow established connections for already approved traffic
iptables -A INPUT -m state --state ESTABLISHED,RELATED -j ACCEPT
iptables -A OUTPUT -m state --state ESTABLISHED,RELATED -j ACCEPT

# Then allow only specific outbound traffic to allowed domains
iptables -A OUTPUT -m set --match-set allowed-domains dst -j ACCEPT

echo "Firewall configuration complete"
echo "Verifying firewall rules..."
if curl --connect-timeout 5 https://example.com >/dev/null 2>&1; then
    echo "ERROR: Firewall verification failed - was able to reach https://example.com"
    exit 1
else
    echo "Firewall verification passed - unable to reach https://example.com as expected"
fi

# Verify GitHub API access
if ! curl --connect-timeout 5 https://api.github.com/zen >/dev/null 2>&1; then
    echo "ERROR: Firewall verification failed - unable to reach https://api.github.com"
    exit 1
else
    echo "Firewall verification passed - able to reach https://api.github.com as expected"
fi
</file>

<file path="bin/run.js">
#!/usr/bin/env node

const oclif = require('@oclif/core')

oclif.run().then(require('@oclif/core/flush')).catch(require('@oclif/core/handle'))
</file>

<file path="examples/form-automation.yml">
# Example workflow for form automation
# Run with: chromancer run examples/form-automation.yml --continue-on-error

- navigate: file:///tmp/test-form.html

# Create a test form first
- evaluate: |
    document.body.innerHTML = `
      <form id="contact-form">
        <h2>Contact Form</h2>
        <input type="text" name="name" placeholder="Your Name" required>
        <input type="email" name="email" placeholder="Your Email" required>
        <select name="subject">
          <option value="">Select Subject</option>
          <option value="general">General Inquiry</option>
          <option value="support">Support</option>
          <option value="feedback">Feedback</option>
        </select>
        <textarea name="message" placeholder="Your Message" rows="5"></textarea>
        <button type="submit">Send Message</button>
      </form>
    `

- wait:
    selector: #contact-form
    
- fill:
    form:
      name: John Doe
      email: john@example.com
      message: This is an automated test message

- select:
    selector: select[name="subject"]
    value: feedback
    
- screenshot: form-filled.png

# Uncomment to submit
# - click: button[type="submit"]
</file>

<file path="examples/login-workflow.yml">
# Example workflow for logging into a website
# Run with: chromancer run examples/login-workflow.yml --var USER=myusername --var PASS=mypassword

- navigate: https://github.com/login
- wait:
    selector: input[name="login"]
    timeout: 10000
    
- type:
    selector: input[name="login"]
    text: ${USER}
    
- type:
    selector: input[name="password"]
    text: ${PASS}
    
- click: input[type="submit"]

- wait:
    url: https://github.com
    timeout: 15000
    
- screenshot: logged-in.png
</file>

<file path="examples/scraping-workflow.yml">
# Example workflow for web scraping
# Run with: chromancer run examples/scraping-workflow.yml

- navigate: https://news.ycombinator.com

- wait:
    selector: .itemlist
    state: visible
    
- evaluate: |
    // Extract top 5 stories
    Array.from(document.querySelectorAll('.athing')).slice(0, 5).map(item => ({
      title: item.querySelector('.titleline a').textContent,
      link: item.querySelector('.titleline a').href,
      rank: item.querySelector('.rank').textContent
    }))
    
- screenshot:
    path: hackernews.png
    fullPage: false
    
- scroll: bottom

- wait: 
    time: 1000
    
- scroll: top
</file>

<file path="src/commands/cookies.ts">
import { Args, Flags } from '@oclif/core'
import { Page, Cookie } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

export default class Cookies extends BaseCommand {
  static description = 'Manage browser cookies'

  static examples = [
    '<%= config.bin %> <%= command.id %> list',
    '<%= config.bin %> <%= command.id %> get sessionId',
    '<%= config.bin %> <%= command.id %> set name=value',
    '<%= config.bin %> <%= command.id %> delete sessionId',
    '<%= config.bin %> <%= command.id %> clear',
    '<%= config.bin %> <%= command.id %> save --output cookies.json',
    '<%= config.bin %> <%= command.id %> load --file cookies.json',
  ]

  static args = {
    action: Args.string({
      description: 'Cookie action',
      options: ['list', 'get', 'set', 'delete', 'clear', 'save', 'load'],
      required: true,
    }),
    value: Args.string({
      description: 'Cookie name or name=value pair',
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output file for save action',
      default: 'cookies.json',
    }),
    file: Flags.string({
      char: 'f',
      description: 'Input file for load action',
    }),
    domain: Flags.string({
      description: 'Cookie domain',
    }),
    path: Flags.string({
      description: 'Cookie path',
      default: '/',
    }),
    secure: Flags.boolean({
      description: 'Secure cookie flag',
      default: false,
    }),
    httpOnly: Flags.boolean({
      description: 'HttpOnly cookie flag',
      default: false,
    }),
    sameSite: Flags.string({
      description: 'SameSite cookie attribute',
      options: ['Strict', 'Lax', 'None'],
    }),
    expires: Flags.integer({
      description: 'Cookie expiration timestamp',
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Cookies)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page || !this.context) {
      this.error('Failed to connect to Chrome')
    }

    await this.manageCookies(this.page!, args.action, args.value)
  }

  private async manageCookies(page: Page, action: string, value?: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    
    switch (action) {
      case 'list':
        await this.listCookies(page)
        break
        
      case 'get':
        if (!value) this.error('Cookie name required for get action')
        await this.getCookie(page, value)
        break
        
      case 'set':
        if (!value) this.error('Cookie data required for set action (name=value)')
        await this.setCookie(page, value)
        break
        
      case 'delete':
        if (!value) this.error('Cookie name required for delete action')
        await this.deleteCookie(page, value)
        break
        
      case 'clear':
        await this.clearCookies(page)
        break
        
      case 'save':
        await this.saveCookies(page, flags.output)
        break
        
      case 'load':
        if (!flags.file) this.error('File path required for load action (use --file)')
        await this.loadCookies(page, flags.file)
        break
        
      default:
        this.error(`Unknown action: ${action}`)
    }
  }

  private async listCookies(page: Page): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.log('No cookies found')
      return
    }
    
    this.log(`Found ${cookies.length} cookies:\n`)
    
    for (const cookie of cookies) {
      this.log(`üç™ ${cookie.name}`)
      this.log(`   Value: ${cookie.value}`)
      this.log(`   Domain: ${cookie.domain}`)
      this.log(`   Path: ${cookie.path}`)
      if (cookie.expires && cookie.expires > 0) {
        this.log(`   Expires: ${new Date(cookie.expires * 1000).toISOString()}`)
      }
      if (cookie.secure) this.log('   Secure: ‚úì')
      if (cookie.httpOnly) this.log('   HttpOnly: ‚úì')
      if (cookie.sameSite) this.log(`   SameSite: ${cookie.sameSite}`)
      this.log('')
    }
  }

  private async getCookie(page: Page, name: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    const cookies = await this.context!.cookies()
    const cookie = cookies.find(c => c.name === name)
    
    if (!cookie) {
      this.error(`Cookie not found: ${name}`)
    }
    
    this.log(`üç™ ${cookie.name} = ${cookie.value}`)
    
    if (flags.verbose) {
      this.logVerbose('Cookie details', {
        domain: cookie.domain,
        path: cookie.path,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        sameSite: cookie.sameSite,
        expires: cookie.expires ? new Date(cookie.expires * 1000).toISOString() : 'Session',
      })
    }
  }

  private async setCookie(page: Page, value: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    
    // Parse name=value format
    const [name, ...valueParts] = value.split('=')
    if (!name || valueParts.length === 0) {
      this.error('Invalid cookie format. Use: name=value')
    }
    
    const cookieValue = valueParts.join('=') // Handle values with = in them
    
    // Get current URL for domain
    const url = page.url()
    const urlObj = new URL(url)
    
    const cookie: Cookie = {
      name: name.trim(),
      value: cookieValue.trim(),
      domain: flags.domain || urlObj.hostname,
      path: flags.path,
      secure: flags.secure,
      httpOnly: flags.httpOnly,
      sameSite: flags.sameSite as 'Strict' | 'Lax' | 'None',
      expires: flags.expires || -1, // -1 means session cookie
    }
    
    await this.context!.addCookies([cookie])
    this.log(`‚úÖ Cookie set: ${name}`)
    
    if (flags.verbose) {
      this.logVerbose('Cookie set', cookie)
    }
  }

  private async deleteCookie(page: Page, name: string): Promise<void> {
    const cookies = await this.context!.cookies()
    const cookie = cookies.find(c => c.name === name)
    
    if (!cookie) {
      this.warn(`Cookie not found: ${name}`)
      return
    }
    
    // Delete by setting expiration to past
    await this.context!.addCookies([{
      ...cookie,
      expires: 0,
    }])
    
    this.log(`‚úÖ Cookie deleted: ${name}`)
  }

  private async clearCookies(page: Page): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.log('No cookies to clear')
      return
    }
    
    await this.context!.clearCookies()
    this.log(`‚úÖ Cleared ${cookies.length} cookies`)
  }

  private async saveCookies(page: Page, outputPath: string): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.warn('No cookies to save')
      return
    }
    
    await fs.writeFile(outputPath, JSON.stringify(cookies, null, 2))
    this.log(`‚úÖ Saved ${cookies.length} cookies to: ${outputPath}`)
  }

  private async loadCookies(page: Page, filePath: string): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8')
      const cookies = JSON.parse(content) as Cookie[]
      
      if (!Array.isArray(cookies)) {
        this.error('Invalid cookie file format')
      }
      
      await this.context!.addCookies(cookies)
      this.log(`‚úÖ Loaded ${cookies.length} cookies from: ${filePath}`)
      
    } catch (error: any) {
      this.error(`Failed to load cookies: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/export.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'
import * as path from 'path'

export default class Export extends BaseCommand {
  static description = 'Export page content, data, or resources'

  static examples = [
    '<%= config.bin %> <%= command.id %> --format html --output page.html',
    '<%= config.bin %> <%= command.id %> --format json --selector "table#data"',
    '<%= config.bin %> <%= command.id %> --format csv --selector "table"',
    '<%= config.bin %> <%= command.id %> --format markdown --output content.md',
    '<%= config.bin %> <%= command.id %> --all-resources --output-dir ./export',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    format: Flags.string({
      char: 'f',
      description: 'Export format',
      options: ['html', 'json', 'csv', 'markdown', 'text'],
      default: 'html',
    }),
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to export specific element',
    }),
    output: Flags.string({
      char: 'o',
      description: 'Output file path',
    }),
    'output-dir': Flags.string({
      description: 'Output directory for resources',
      default: './export',
    }),
    'all-resources': Flags.boolean({
      description: 'Export all page resources (images, scripts, styles)',
      default: false,
    }),
    'include-styles': Flags.boolean({
      description: 'Include computed styles in HTML export',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Export)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.exportContent(this.page!)
  }

  private async exportContent(page: Page): Promise<void> {
    const { flags } = await this.parse(Export)
    
    let content: string
    
    switch (flags.format) {
      case 'html':
        content = await this.exportHTML(page, flags.selector, flags['include-styles'])
        break
      case 'json':
        content = await this.exportJSON(page, flags.selector)
        break
      case 'csv':
        content = await this.exportCSV(page, flags.selector)
        break
      case 'markdown':
        content = await this.exportMarkdown(page, flags.selector)
        break
      case 'text':
        content = await this.exportText(page, flags.selector)
        break
      default:
        this.error(`Unsupported format: ${flags.format}`)
    }
    
    // Export resources if requested
    if (flags['all-resources']) {
      await this.exportResources(page, flags['output-dir'])
    }
    
    // Save content
    const outputPath = flags.output || `export.${flags.format}`
    await fs.writeFile(outputPath, content)
    this.log(`‚úÖ Exported to: ${outputPath}`)
  }

  private async exportHTML(page: Page, selector?: string, includeStyles?: boolean): Promise<string> {
    if (selector) {
      return await page.evaluate(({ sel, styles }) => {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        
        if (styles) {
          // Clone element and inline styles
          const clone = element.cloneNode(true) as HTMLElement
          const allElements = clone.querySelectorAll('*')
          allElements.forEach((el) => {
            const computed = window.getComputedStyle(el as HTMLElement)
            ;(el as HTMLElement).setAttribute('style', computed.cssText)
          })
          return clone.outerHTML
        }
        
        return element.outerHTML
      }, { sel: selector, styles: includeStyles })
    }
    
    return await page.content()
  }

  private async exportJSON(page: Page, selector?: string): Promise<string> {
    const data = await page.evaluate((sel) => {
      if (sel) {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        
        // Special handling for tables
        if (element.tagName === 'TABLE') {
          const headers: string[] = []
          const rows: any[] = []
          
          // Get headers
          element.querySelectorAll('thead th').forEach((th) => {
            headers.push(th.textContent?.trim() || '')
          })
          
          // Get rows
          element.querySelectorAll('tbody tr').forEach((tr) => {
            const row: any = {}
            tr.querySelectorAll('td').forEach((td, i) => {
              const key = headers[i] || `col${i}`
              row[key] = td.textContent?.trim() || ''
            })
            rows.push(row)
          })
          
          return rows
        }
        
        // Try to extract data attributes
        const dataAttrs: any = {}
        Array.from(element.attributes).forEach((attr) => {
          if (attr.name.startsWith('data-')) {
            const key = attr.name.replace('data-', '')
            try {
              dataAttrs[key] = JSON.parse(attr.value)
            } catch {
              dataAttrs[key] = attr.value
            }
          }
        })
        
        return {
          text: element.textContent?.trim(),
          attributes: dataAttrs,
          html: element.innerHTML,
        }
      }
      
      // Export all data elements
      const allData: any[] = []
      document.querySelectorAll('[data-export], [data-json], table').forEach((el) => {
        if (el.tagName === 'TABLE') {
          // Handle tables as above
          const headers: string[] = []
          const rows: any[] = []
          
          el.querySelectorAll('thead th').forEach((th) => {
            headers.push(th.textContent?.trim() || '')
          })
          
          el.querySelectorAll('tbody tr').forEach((tr) => {
            const row: any = {}
            tr.querySelectorAll('td').forEach((td, i) => {
              const key = headers[i] || `col${i}`
              row[key] = td.textContent?.trim() || ''
            })
            rows.push(row)
          })
          
          allData.push({ type: 'table', data: rows })
        } else {
          // Handle data elements
          const data = el.getAttribute('data-json') || el.getAttribute('data-export')
          if (data) {
            try {
              allData.push(JSON.parse(data))
            } catch {
              allData.push(data)
            }
          }
        }
      })
      
      return allData
    }, selector)
    
    return JSON.stringify(data, null, 2)
  }

  private async exportCSV(page: Page, selector?: string): Promise<string> {
    const tableSelector = selector || 'table'
    
    return await page.evaluate((sel) => {
      const table = document.querySelector(sel)
      if (!table || table.tagName !== 'TABLE') {
        throw new Error('No table found with selector: ' + sel)
      }
      
      const rows: string[] = []
      
      // Get headers
      const headers: string[] = []
      table.querySelectorAll('thead th').forEach((th) => {
        headers.push(`"${th.textContent?.trim().replace(/"/g, '""') || ''}"`)
      })
      if (headers.length > 0) {
        rows.push(headers.join(','))
      }
      
      // Get data rows
      table.querySelectorAll('tbody tr').forEach((tr) => {
        const cells: string[] = []
        tr.querySelectorAll('td').forEach((td) => {
          cells.push(`"${td.textContent?.trim().replace(/"/g, '""') || ''}"`)
        })
        rows.push(cells.join(','))
      })
      
      return rows.join('\n')
    }, tableSelector)
  }

  private async exportMarkdown(page: Page, selector?: string): Promise<string> {
    return await page.evaluate((sel) => {
      const element = sel ? document.querySelector(sel) : document.body
      if (!element) throw new Error(`Element not found: ${sel}`)
      
      // Simple HTML to Markdown conversion
      function htmlToMarkdown(el: Element): string {
        let md = ''
        
        for (const node of Array.from(el.childNodes)) {
          if (node.nodeType === Node.TEXT_NODE) {
            md += node.textContent
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const elem = node as Element
            const tag = elem.tagName.toLowerCase()
            
            switch (tag) {
              case 'h1':
                md += `# ${elem.textContent?.trim()}\n\n`
                break
              case 'h2':
                md += `## ${elem.textContent?.trim()}\n\n`
                break
              case 'h3':
                md += `### ${elem.textContent?.trim()}\n\n`
                break
              case 'h4':
                md += `#### ${elem.textContent?.trim()}\n\n`
                break
              case 'h5':
                md += `##### ${elem.textContent?.trim()}\n\n`
                break
              case 'h6':
                md += `###### ${elem.textContent?.trim()}\n\n`
                break
              case 'p':
                md += `${elem.textContent?.trim()}\n\n`
                break
              case 'a':
                md += `[${elem.textContent?.trim()}](${elem.getAttribute('href')})`
                break
              case 'img':
                md += `![${elem.getAttribute('alt') || ''}](${elem.getAttribute('src')})`
                break
              case 'strong':
              case 'b':
                md += `**${elem.textContent?.trim()}**`
                break
              case 'em':
              case 'i':
                md += `*${elem.textContent?.trim()}*`
                break
              case 'code':
                md += `\`${elem.textContent?.trim()}\``
                break
              case 'pre':
                md += `\`\`\`\n${elem.textContent?.trim()}\n\`\`\`\n\n`
                break
              case 'ul':
              case 'ol':
                const items = Array.from(elem.querySelectorAll('li'))
                items.forEach((li, i) => {
                  const prefix = tag === 'ol' ? `${i + 1}. ` : '- '
                  md += `${prefix}${li.textContent?.trim()}\n`
                })
                md += '\n'
                break
              case 'blockquote':
                md += `> ${elem.textContent?.trim()}\n\n`
                break
              case 'hr':
                md += '---\n\n'
                break
              case 'br':
                md += '\n'
                break
              case 'table':
                // Convert table to markdown
                const headers = Array.from(elem.querySelectorAll('thead th'))
                if (headers.length > 0) {
                  md += '| ' + headers.map(th => th.textContent?.trim()).join(' | ') + ' |\n'
                  md += '| ' + headers.map(() => '---').join(' | ') + ' |\n'
                }
                elem.querySelectorAll('tbody tr').forEach((tr) => {
                  const cells = Array.from(tr.querySelectorAll('td'))
                  md += '| ' + cells.map(td => td.textContent?.trim()).join(' | ') + ' |\n'
                })
                md += '\n'
                break
              default:
                md += htmlToMarkdown(elem)
            }
          }
        }
        
        return md
      }
      
      return htmlToMarkdown(element)
    }, selector)
  }

  private async exportText(page: Page, selector?: string): Promise<string> {
    if (selector) {
      return await page.evaluate((sel) => {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        return element.textContent?.trim() || ''
      }, selector)
    }
    
    return await page.evaluate(() => document.body.textContent?.trim() || '')
  }

  private async exportResources(page: Page, outputDir: string): Promise<void> {
    const { flags } = await this.parse(Export)
    await fs.mkdir(outputDir, { recursive: true })
    
    // Get all resource URLs
    const resources = await page.evaluate(() => {
      const urls = new Set<string>()
      
      // Images
      document.querySelectorAll('img').forEach((img) => {
        if (img.src) urls.add(img.src)
      })
      
      // Stylesheets
      document.querySelectorAll('link[rel="stylesheet"]').forEach((link) => {
        if ((link as HTMLLinkElement).href) urls.add((link as HTMLLinkElement).href)
      })
      
      // Scripts
      document.querySelectorAll('script[src]').forEach((script) => {
        if ((script as HTMLScriptElement).src) urls.add((script as HTMLScriptElement).src)
      })
      
      return Array.from(urls)
    })
    
    this.log(`üì¶ Exporting ${resources.length} resources...`)
    
    // Download each resource
    for (const url of resources) {
      try {
        const response = await page.request.get(url)
        if (response.ok()) {
          const urlObj = new URL(url)
          const filename = path.basename(urlObj.pathname) || 'index.html'
          const filepath = path.join(outputDir, filename)
          
          const buffer = await response.body()
          await fs.writeFile(filepath, buffer)
          
          if (flags.verbose) {
            this.logVerbose(`Downloaded: ${filename}`)
          }
        }
      } catch (error) {
        this.warn(`Failed to download: ${url}`)
      }
    }
    
    this.log(`‚úÖ Resources exported to: ${outputDir}`)
  }
}
</file>

<file path="src/commands/fill.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface FormData {
  [key: string]: string | boolean | string[]
}

export default class Fill extends BaseCommand {
  static description = 'Fill form fields automatically'

  static examples = [
    '<%= config.bin %> <%= command.id %> --data \'{"username": "john", "email": "john@example.com"}\'',
    '<%= config.bin %> <%= command.id %> --file form-data.json',
    '<%= config.bin %> <%= command.id %> --selector "#login-form" --data \'{"username": "admin", "password": "secret"}\'',
    '<%= config.bin %> <%= command.id %> --auto-generate --submit',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    data: Flags.string({
      char: 'd',
      description: 'JSON data to fill forms with',
      exclusive: ['file', 'auto-generate'],
    }),
    file: Flags.string({
      char: 'f',
      description: 'JSON file containing form data',
      exclusive: ['data', 'auto-generate'],
    }),
    selector: Flags.string({
      char: 's',
      description: 'CSS selector for specific form',
    }),
    'auto-generate': Flags.boolean({
      description: 'Generate random test data for all fields',
      exclusive: ['data', 'file'],
    }),
    submit: Flags.boolean({
      description: 'Submit the form after filling',
      default: false,
    }),
    'wait-after': Flags.integer({
      description: 'Wait time in ms after filling each field',
      default: 100,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Fill)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.fillForms(this.page!)
  }

  private async fillForms(page: Page): Promise<void> {
    const { flags } = await this.parse(Fill)
    
    // Get form data
    let formData: FormData = {}
    
    if (flags.data) {
      try {
        formData = JSON.parse(flags.data)
      } catch (error) {
        this.error('Invalid JSON data')
      }
    } else if (flags.file) {
      try {
        const content = await fs.readFile(flags.file, 'utf-8')
        formData = JSON.parse(content)
      } catch (error) {
        this.error(`Failed to read file: ${flags.file}`)
      }
    } else if (flags['auto-generate']) {
      formData = await this.generateTestData(page, flags.selector)
    } else {
      this.error('No form data provided. Use --data, --file, or --auto-generate')
    }
    
    // Fill the form
    const formSelector = flags.selector || 'form'
    
    try {
      // Wait for form to be present
      await page.waitForSelector(formSelector, { timeout: 5000 })
      
      // Fill each field
      for (const [key, value] of Object.entries(formData)) {
        const filled = await this.fillField(page, formSelector, key, value)
        
        if (filled && flags['wait-after'] > 0) {
          await page.waitForTimeout(flags['wait-after'])
        }
      }
      
      this.log('‚úÖ Form filled successfully')
      
      // Submit if requested
      if (flags.submit) {
        await this.submitForm(page, formSelector)
      }
      
    } catch (error: any) {
      this.error(`Failed to fill form: ${error.message}`)
    }
  }

  private async fillField(page: Page, formSelector: string, key: string, value: any): Promise<boolean> {
    const { flags } = await this.parse(Fill)
    
    // Try different strategies to find the field
    const selectors = [
      `${formSelector} [name="${key}"]`,
      `${formSelector} #${key}`,
      `${formSelector} [id="${key}"]`,
      `${formSelector} [data-field="${key}"]`,
      `${formSelector} input[placeholder*="${key}" i]`,
      `${formSelector} label:has-text("${key}") input`,
    ]
    
    for (const selector of selectors) {
      try {
        const element = await page.$(selector)
        if (!element) continue
        
        const tagName = await element.evaluate(el => el.tagName)
        const type = await element.evaluate(el => (el as any).type)
        
        if (tagName === 'INPUT') {
          if (type === 'checkbox' || type === 'radio') {
            if (value === true || value === 'true' || value === '1') {
              await element.check()
              if (flags.verbose) {
                this.logVerbose(`Checked: ${key}`)
              }
            }
          } else if (type === 'file') {
            if (typeof value === 'string') {
              await element.setInputFiles(value)
              if (flags.verbose) {
                this.logVerbose(`Set file: ${key} = ${value}`)
              }
            }
          } else {
            await element.fill(String(value))
            if (flags.verbose) {
              this.logVerbose(`Filled: ${key} = ${value}`)
            }
          }
          return true
        } else if (tagName === 'SELECT') {
          if (Array.isArray(value)) {
            await element.selectOption(value)
          } else {
            await element.selectOption(String(value))
          }
          if (flags.verbose) {
            this.logVerbose(`Selected: ${key} = ${value}`)
          }
          return true
        } else if (tagName === 'TEXTAREA') {
          await element.fill(String(value))
          if (flags.verbose) {
            this.logVerbose(`Filled textarea: ${key}`)
          }
          return true
        }
      } catch (error) {
        // Try next selector
        continue
      }
    }
    
    this.warn(`Could not find field: ${key}`)
    return false
  }

  private async generateTestData(page: Page, formSelector?: string): Promise<FormData> {
    const selector = formSelector || 'form'
    
    return await page.evaluate((sel) => {
      const form = document.querySelector(sel)
      if (!form) throw new Error(`Form not found: ${sel}`)
      
      const data: any = {}
      
      // Generate data based on field types and names
      const generateValue = (element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement): any => {
        const name = element.name || element.id
        const type = (element as HTMLInputElement).type || element.tagName.toLowerCase()
        
        // Generate based on common field names
        if (/email/i.test(name)) return 'test@example.com'
        if (/phone|tel/i.test(name)) return '+1234567890'
        if (/name/i.test(name)) {
          if (/first/i.test(name)) return 'John'
          if (/last/i.test(name)) return 'Doe'
          return 'John Doe'
        }
        if (/user/i.test(name)) return 'testuser'
        if (/pass/i.test(name)) return 'TestPass123!'
        if (/age/i.test(name)) return '25'
        if (/date/i.test(name)) return new Date().toISOString().split('T')[0]
        if (/time/i.test(name)) return '12:00'
        if (/url|website/i.test(name)) return 'https://example.com'
        if (/zip|postal/i.test(name)) return '12345'
        if (/address/i.test(name)) return '123 Test Street'
        if (/city/i.test(name)) return 'Test City'
        if (/state/i.test(name)) return 'CA'
        if (/country/i.test(name)) return 'United States'
        if (/message|comment|description|bio/i.test(name)) return 'This is a test message.'
        
        // Generate based on input type
        switch (type) {
          case 'email': return 'test@example.com'
          case 'tel': return '+1234567890'
          case 'url': return 'https://example.com'
          case 'number': return '42'
          case 'date': return new Date().toISOString().split('T')[0]
          case 'time': return '12:00'
          case 'datetime-local': return new Date().toISOString().slice(0, 16)
          case 'month': return new Date().toISOString().slice(0, 7)
          case 'week': return new Date().toISOString().split('T')[0]
          case 'color': return '#3498db'
          case 'range': return '50'
          case 'checkbox': return true
          case 'radio': return true
          case 'select':
          case 'select-one':
            const options = (element as HTMLSelectElement).options
            if (options.length > 1) {
              return options[1].value // Skip first option (often empty)
            }
            return options[0]?.value
          case 'select-multiple':
            const opts = Array.from((element as HTMLSelectElement).options)
            return opts.slice(1, 3).map(o => o.value) // Select first two non-empty options
          case 'textarea': return 'This is test content for the textarea field.'
          default: return 'Test Value'
        }
      }
      
      // Find all form fields
      form.querySelectorAll('input, select, textarea').forEach((field) => {
        const element = field as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
        const name = element.name || element.id
        
        if (!name) return
        
        // Skip hidden, submit, button, reset fields
        if ((element as HTMLInputElement).type === 'hidden' ||
            (element as HTMLInputElement).type === 'submit' ||
            (element as HTMLInputElement).type === 'button' ||
            (element as HTMLInputElement).type === 'reset') {
          return
        }
        
        // Skip if already has data for radio buttons
        if ((element as HTMLInputElement).type === 'radio' && data[name]) {
          return
        }
        
        data[name] = generateValue(element)
      })
      
      return data
    }, selector)
  }

  private async submitForm(page: Page, formSelector: string): Promise<void> {
    this.log('üì§ Submitting form...')
    
    // Try to find and click submit button
    const submitSelectors = [
      `${formSelector} button[type="submit"]`,
      `${formSelector} input[type="submit"]`,
      `${formSelector} button:has-text("Submit")`,
      `${formSelector} button:has-text("Send")`,
      `${formSelector} button:has-text("Save")`,
      `${formSelector} button:has-text("Continue")`,
    ]
    
    for (const selector of submitSelectors) {
      try {
        const button = await page.$(selector)
        if (button) {
          await button.click()
          this.log('‚úÖ Form submitted')
          return
        }
      } catch (error) {
        // Try next selector
      }
    }
    
    // Fallback: submit via Enter key
    try {
      await page.evaluate((sel) => {
        const form = document.querySelector(sel) as HTMLFormElement
        if (form) {
          form.submit()
        }
      }, formSelector)
      this.log('‚úÖ Form submitted')
    } catch (error: any) {
      this.warn('Could not find submit button')
    }
  }
}
</file>

<file path="src/commands/network.ts">
import { Flags } from '@oclif/core'
import { Page, Request, Response } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface NetworkLog {
  timestamp: string
  method: string
  url: string
  status?: number
  type?: string
  size?: number
  duration?: number
  headers?: Record<string, string>
  postData?: string
  response?: any
}

export default class Network extends BaseCommand {
  static description = 'Monitor network requests and responses'

  static examples = [
    '<%= config.bin %> <%= command.id %> --filter "api"',
    '<%= config.bin %> <%= command.id %> --type xhr --output api-calls.json',
    '<%= config.bin %> <%= command.id %> --method POST --verbose',
    '<%= config.bin %> <%= command.id %> --status 404 --status 500',
    '<%= config.bin %> <%= command.id %> --block "ads" --block "analytics"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    filter: Flags.string({
      char: 'f',
      description: 'URL filter pattern',
      multiple: true,
    }),
    type: Flags.string({
      char: 't',
      description: 'Resource type filter',
      options: ['document', 'stylesheet', 'image', 'media', 'font', 'script', 'xhr', 'fetch', 'websocket'],
      multiple: true,
    }),
    method: Flags.string({
      char: 'm',
      description: 'HTTP method filter',
      options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'],
      multiple: true,
    }),
    status: Flags.integer({
      description: 'HTTP status code filter',
      multiple: true,
    }),
    block: Flags.string({
      char: 'b',
      description: 'Block requests matching pattern',
      multiple: true,
    }),
    output: Flags.string({
      char: 'o',
      description: 'Output file for network log',
    }),
    'capture-response': Flags.boolean({
      description: 'Capture response bodies',
      default: false,
    }),
    'live-mode': Flags.boolean({
      description: 'Show requests in real-time',
      default: true,
    }),
    duration: Flags.integer({
      char: 'd',
      description: 'Monitor duration in milliseconds',
      default: 60000, // 1 minute
    }),
  }

  private networkLogs: NetworkLog[] = []
  private requestTimings = new Map<string, number>()

  async run(): Promise<void> {
    const { flags } = await this.parse(Network)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open for monitoring
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.monitorNetwork(this.page!)
  }

  private async monitorNetwork(page: Page): Promise<void> {
    const { flags } = await this.parse(Network)
    
    this.log('üåê Network monitoring started...')
    this.log(`Press Ctrl+C to stop (max duration: ${flags.duration}ms)\n`)
    
    // Set up request interception if blocking
    if (flags.block && flags.block.length > 0) {
      await page.route('**/*', async (route) => {
        const url = route.request().url()
        const shouldBlock = flags.block!.some(pattern => url.includes(pattern))
        
        if (shouldBlock) {
          await route.abort()
          if (flags['live-mode']) {
            this.log(`üö´ Blocked: ${url}`)
          }
        } else {
          await route.continue()
        }
      })
    }
    
    // Monitor requests
    page.on('request', (request) => {
      this.requestTimings.set(request.url(), Date.now())
      
      if (this.shouldLogRequest(request)) {
        const log: NetworkLog = {
          timestamp: new Date().toISOString(),
          method: request.method(),
          url: request.url(),
          type: request.resourceType(),
        }
        
        if (flags.verbose || flags['capture-response']) {
          log.headers = request.headers()
          log.postData = request.postData() || undefined
        }
        
        if (flags['live-mode']) {
          this.log(`‚Üí ${request.method()} ${request.url()}`)
        }
        
        this.networkLogs.push(log)
      }
    })
    
    // Monitor responses
    page.on('response', async (response) => {
      const request = response.request()
      
      if (this.shouldLogRequest(request) && this.shouldLogResponse(response)) {
        const startTime = this.requestTimings.get(request.url())
        const duration = startTime ? Date.now() - startTime : undefined
        
        // Find and update the request log
        const logIndex = this.networkLogs.findIndex(
          log => log.url === request.url() && log.method === request.method() && !log.status
        )
        
        if (logIndex !== -1) {
          this.networkLogs[logIndex].status = response.status()
          this.networkLogs[logIndex].duration = duration
          
          try {
            const headers = await response.allHeaders()
            const size = headers['content-length'] ? parseInt(headers['content-length']) : undefined
            this.networkLogs[logIndex].size = size
            
            if (flags['capture-response']) {
              try {
                const contentType = headers['content-type'] || ''
                if (contentType.includes('json') || contentType.includes('text')) {
                  this.networkLogs[logIndex].response = await response.text()
                }
              } catch {
                // Ignore response body errors
              }
            }
          } catch {
            // Ignore header errors
          }
        }
        
        if (flags['live-mode']) {
          const status = response.status()
          const statusIcon = status >= 200 && status < 300 ? '‚úì' : status >= 400 ? '‚úó' : '‚Ä¢'
          const sizeStr = this.networkLogs[logIndex]?.size 
            ? ` (${this.formatBytes(this.networkLogs[logIndex].size!)})`
            : ''
          const durationStr = duration ? ` ${duration}ms` : ''
          
          this.log(`‚Üê ${statusIcon} ${status} ${request.url()}${sizeStr}${durationStr}`)
        }
      }
    })
    
    // Monitor failed requests
    page.on('requestfailed', (request) => {
      if (this.shouldLogRequest(request)) {
        if (flags['live-mode']) {
          this.log(`‚úó Failed: ${request.method()} ${request.url()}`)
        }
        
        const logIndex = this.networkLogs.findIndex(
          log => log.url === request.url() && log.method === request.method() && !log.status
        )
        
        if (logIndex !== -1) {
          this.networkLogs[logIndex].status = 0 // Failed request
        }
      }
    })
    
    // Set up monitoring duration
    const timeout = setTimeout(() => {
      this.stopMonitoring()
    }, flags.duration)
    
    // Handle Ctrl+C
    process.on('SIGINT', () => {
      clearTimeout(timeout)
      this.stopMonitoring()
    })
  }

  private shouldLogRequest(request: Request): boolean {
    const { flags } = this.parsedFlags as any
    
    // Filter by URL pattern
    if (flags.filter && flags.filter.length > 0) {
      const url = request.url()
      if (!flags.filter.some((pattern: string) => url.includes(pattern))) {
        return false
      }
    }
    
    // Filter by resource type
    if (flags.type && flags.type.length > 0) {
      if (!flags.type.includes(request.resourceType())) {
        return false
      }
    }
    
    // Filter by method
    if (flags.method && flags.method.length > 0) {
      if (!flags.method.includes(request.method())) {
        return false
      }
    }
    
    return true
  }

  private shouldLogResponse(response: Response): boolean {
    const { flags } = this.parsedFlags as any
    
    // Filter by status code
    if (flags.status && flags.status.length > 0) {
      if (!flags.status.includes(response.status())) {
        return false
      }
    }
    
    return true
  }

  private async stopMonitoring(): Promise<void> {
    const { flags } = this.parsedFlags as any
    
    this.log('\n‚èπÔ∏è  Network monitoring stopped')
    this.log(`Captured ${this.networkLogs.length} requests`)
    
    // Summary statistics
    const stats = this.calculateStats()
    this.log('\nüìä Summary:')
    this.log(`   Total requests: ${stats.total}`)
    this.log(`   Successful: ${stats.successful} (2xx)`)
    this.log(`   Redirects: ${stats.redirects} (3xx)`)
    this.log(`   Client errors: ${stats.clientErrors} (4xx)`)
    this.log(`   Server errors: ${stats.serverErrors} (5xx)`)
    this.log(`   Failed: ${stats.failed}`)
    if (stats.totalSize > 0) {
      this.log(`   Total size: ${this.formatBytes(stats.totalSize)}`)
    }
    if (stats.avgDuration > 0) {
      this.log(`   Average duration: ${stats.avgDuration.toFixed(0)}ms`)
    }
    
    // Save to file if requested
    if (flags.output) {
      await fs.writeFile(flags.output, JSON.stringify(this.networkLogs, null, 2))
      this.log(`\n‚úÖ Network log saved to: ${flags.output}`)
    }
    
    process.exit(0)
  }

  private calculateStats(): any {
    const stats = {
      total: this.networkLogs.length,
      successful: 0,
      redirects: 0,
      clientErrors: 0,
      serverErrors: 0,
      failed: 0,
      totalSize: 0,
      totalDuration: 0,
      avgDuration: 0,
    }
    
    for (const log of this.networkLogs) {
      if (log.status === 0) {
        stats.failed++
      } else if (log.status && log.status >= 200 && log.status < 300) {
        stats.successful++
      } else if (log.status && log.status >= 300 && log.status < 400) {
        stats.redirects++
      } else if (log.status && log.status >= 400 && log.status < 500) {
        stats.clientErrors++
      } else if (log.status && log.status >= 500) {
        stats.serverErrors++
      }
      
      if (log.size) {
        stats.totalSize += log.size
      }
      
      if (log.duration) {
        stats.totalDuration += log.duration
      }
    }
    
    const completedRequests = this.networkLogs.filter(log => log.duration).length
    if (completedRequests > 0) {
      stats.avgDuration = stats.totalDuration / completedRequests
    }
    
    return stats
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B'
    
    const k = 1024
    const sizes = ['B', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`
  }

  private get parsedFlags() {
    return this.parse(Network).then(result => result.flags)
  }
}
</file>

<file path="src/commands/pdf.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'

export default class Pdf extends BaseCommand {
  static description = 'Save page as PDF'

  static examples = [
    '<%= config.bin %> <%= command.id %> --output page.pdf',
    '<%= config.bin %> <%= command.id %> --output report.pdf --format A4',
    '<%= config.bin %> <%= command.id %> --output doc.pdf --landscape --background',
    '<%= config.bin %> <%= command.id %> --output print.pdf --css "@media print"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output PDF file path',
      default: 'page.pdf',
    }),
    format: Flags.string({
      char: 'f',
      description: 'Page format',
      options: ['Letter', 'Legal', 'Tabloid', 'Ledger', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6'],
      default: 'Letter',
    }),
    landscape: Flags.boolean({
      description: 'Use landscape orientation',
      default: false,
    }),
    scale: Flags.integer({
      description: 'Scale of the webpage rendering (percentage)',
      default: 100,
    }),
    background: Flags.boolean({
      description: 'Print background graphics',
      default: false,
    }),
    'display-header-footer': Flags.boolean({
      description: 'Display header and footer',
      default: false,
    }),
    'header-template': Flags.string({
      description: 'HTML template for header',
    }),
    'footer-template': Flags.string({
      description: 'HTML template for footer',
    }),
    margin: Flags.string({
      description: 'Page margins (e.g., "20px" or "1in 2in 1in 2in")',
    }),
    'page-ranges': Flags.string({
      description: 'Page ranges to print (e.g., "1-5, 8, 11-13")',
    }),
    css: Flags.string({
      description: 'CSS media type to emulate',
    }),
    'wait-for': Flags.string({
      description: 'Wait for selector before generating PDF',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Pdf)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.generatePDF(this.page!)
  }

  private async generatePDF(page: Page): Promise<void> {
    const { flags } = await this.parse(Pdf)
    
    try {
      // Wait for specific element if requested
      if (flags['wait-for']) {
        this.log(`‚è≥ Waiting for: ${flags['wait-for']}`)
        await page.waitForSelector(flags['wait-for'], { timeout: 30000 })
      }
      
      // Emulate CSS media type if specified
      if (flags.css) {
        await page.emulateMedia({ media: flags.css as 'screen' | 'print' })
      }
      
      // Prepare PDF options
      const pdfOptions: any = {
        path: flags.output,
        format: flags.format,
        landscape: flags.landscape,
        printBackground: flags.background,
        displayHeaderFooter: flags['display-header-footer'],
      }
      
      // Scale
      if (flags.scale !== 100) {
        pdfOptions.scale = flags.scale / 100
      }
      
      // Header and footer templates
      if (flags['header-template']) {
        pdfOptions.headerTemplate = flags['header-template']
      }
      if (flags['footer-template']) {
        pdfOptions.footerTemplate = flags['footer-template']
      }
      
      // Margins
      if (flags.margin) {
        const margins = this.parseMargins(flags.margin)
        pdfOptions.margin = margins
      }
      
      // Page ranges
      if (flags['page-ranges']) {
        pdfOptions.pageRanges = flags['page-ranges']
      }
      
      this.log('üìÑ Generating PDF...')
      
      // Generate PDF
      await page.pdf(pdfOptions)
      
      this.log(`‚úÖ PDF saved to: ${flags.output}`)
      
      // Log details if verbose
      if (flags.verbose) {
        const stats = await this.getFileStats(flags.output)
        this.logVerbose('PDF generated', {
          format: flags.format,
          orientation: flags.landscape ? 'landscape' : 'portrait',
          scale: `${flags.scale}%`,
          fileSize: stats ? `${(stats.size / 1024).toFixed(2)} KB` : 'unknown',
          url: page.url(),
        })
      }
      
    } catch (error: any) {
      this.error(`Failed to generate PDF: ${error.message}`)
    }
  }

  private parseMargins(margin: string): any {
    const parts = margin.trim().split(/\s+/)
    
    if (parts.length === 1) {
      // Single value for all margins
      return {
        top: parts[0],
        right: parts[0],
        bottom: parts[0],
        left: parts[0],
      }
    } else if (parts.length === 2) {
      // Vertical and horizontal
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[0],
        left: parts[1],
      }
    } else if (parts.length === 4) {
      // Top, right, bottom, left
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[3],
      }
    } else {
      this.error('Invalid margin format. Use "20px" or "1in 2in 1in 2in"')
    }
  }

  private async getFileStats(path: string): Promise<{ size: number } | null> {
    try {
      const { promises: fs } = await import('fs')
      const stats = await fs.stat(path)
      return { size: stats.size }
    } catch {
      return null
    }
  }
}
</file>

<file path="src/commands/record.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface RecordedAction {
  type: 'click' | 'type' | 'navigate' | 'select' | 'check' | 'scroll'
  selector?: string
  value?: string
  url?: string
  timestamp: number
}

export default class Record extends BaseCommand {
  static description = 'Record user interactions and generate a script'

  static examples = [
    '<%= config.bin %> <%= command.id %> --output recording.json',
    '<%= config.bin %> <%= command.id %> --output script.js --format js',
    '<%= config.bin %> <%= command.id %> --duration 30000',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output file for the recording',
      default: 'recording.json',
    }),
    format: Flags.string({
      char: 'f',
      description: 'Output format (json or js)',
      options: ['json', 'js'],
      default: 'json',
    }),
    duration: Flags.integer({
      char: 'd',
      description: 'Maximum recording duration in milliseconds',
      default: 60000, // 1 minute
    }),
  }

  private actions: RecordedAction[] = []
  private startTime: number = Date.now()

  async run(): Promise<void> {
    const { flags } = await this.parse(Record)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open for recording
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.startRecording(this.page!)
  }

  private async startRecording(page: Page): Promise<void> {
    const { flags } = await this.parse(Record)
    
    this.log('üî¥ Recording started. Interact with the page...')
    this.log(`Press Ctrl+C to stop recording (max duration: ${flags.duration}ms)`)
    
    // Track navigation
    page.on('framenavigated', (frame) => {
      if (frame === page.mainFrame()) {
        this.actions.push({
          type: 'navigate',
          url: frame.url(),
          timestamp: Date.now() - this.startTime,
        })
      }
    })

    // Inject recording script into every frame
    await page.addInitScript(() => {
      // Store actions in window object
      (window as any).__recordedActions = [];
      
      // Override addEventListener to capture all events
      const originalAddEventListener = EventTarget.prototype.addEventListener;
      EventTarget.prototype.addEventListener = function(type: string, listener: any, options: any) {
        if (type === 'click' || type === 'change' || type === 'input') {
          const wrappedListener = function(this: any, event: Event) {
            const target = event.target as HTMLElement;
            
            // Generate selector
            let selector = '';
            if (target.id) {
              selector = `#${target.id}`;
            } else if (target.className) {
              selector = `.${target.className.split(' ')[0]}`;
            } else {
              selector = target.tagName.toLowerCase();
            }
            
            const action: any = {
              type: type,
              selector: selector,
              timestamp: Date.now(),
            };
            
            // Add value for input events
            if (type === 'input' && (target as any).value) {
              action.value = (target as any).value;
            }
            
            // Add selected value for select elements
            if (type === 'change' && target.tagName === 'SELECT') {
              action.value = (target as HTMLSelectElement).value;
            }
            
            (window as any).__recordedActions.push(action);
            
            // Call original listener
            return listener.call(this, event);
          };
          
          return originalAddEventListener.call(this, type, wrappedListener, options);
        }
        
        return originalAddEventListener.call(this, type, listener, options);
      };
    })

    // Set up polling to collect recorded actions
    const pollInterval = setInterval(async () => {
      try {
        const actions = await page.evaluate(() => {
          const recorded = (window as any).__recordedActions || [];
          (window as any).__recordedActions = [];
          return recorded;
        })
        
        // Process and add actions
        for (const action of actions) {
          if (action.type === 'click') {
            this.actions.push({
              type: 'click',
              selector: action.selector,
              timestamp: action.timestamp - this.startTime,
            })
          } else if (action.type === 'input') {
            this.actions.push({
              type: 'type',
              selector: action.selector,
              value: action.value,
              timestamp: action.timestamp - this.startTime,
            })
          } else if (action.type === 'change') {
            this.actions.push({
              type: 'select',
              selector: action.selector,
              value: action.value,
              timestamp: action.timestamp - this.startTime,
            })
          }
        }
      } catch (error) {
        // Page might have navigated, ignore errors
      }
    }, 100)

    // Set up timeout
    const timeout = setTimeout(() => {
      this.stopRecording(pollInterval)
    }, flags.duration)

    // Handle Ctrl+C
    process.on('SIGINT', () => {
      clearTimeout(timeout)
      this.stopRecording(pollInterval)
    })
  }

  private async stopRecording(pollInterval: NodeJS.Timeout): Promise<void> {
    const { flags } = await this.parse(Record)
    
    clearInterval(pollInterval)
    
    this.log('‚èπÔ∏è  Recording stopped')
    this.log(`Captured ${this.actions.length} actions`)
    
    // Generate output
    let output: string
    
    if (flags.format === 'js') {
      output = this.generateJavaScript()
    } else {
      output = JSON.stringify(this.actions, null, 2)
    }
    
    // Write to file
    await fs.writeFile(flags.output, output)
    this.log(`‚úÖ Recording saved to: ${flags.output}`)
    
    process.exit(0)
  }

  private generateJavaScript(): string {
    const lines = [
      '// Generated by chromancer record',
      '// Run with: node script.js',
      '',
      'const { chromium } = require("playwright");',
      '',
      '(async () => {',
      '  const browser = await chromium.launch({ headless: false });',
      '  const page = await browser.newPage();',
      '',
    ]
    
    let lastTimestamp = 0
    
    for (const action of this.actions) {
      // Add delay if needed
      const delay = action.timestamp - lastTimestamp
      if (delay > 100) {
        lines.push(`  await page.waitForTimeout(${delay});`)
      }
      lastTimestamp = action.timestamp
      
      // Generate action code
      switch (action.type) {
        case 'navigate':
          lines.push(`  await page.goto('${action.url}');`)
          break
        case 'click':
          lines.push(`  await page.click('${action.selector}');`)
          break
        case 'type':
          lines.push(`  await page.fill('${action.selector}', '${action.value}');`)
          break
        case 'select':
          lines.push(`  await page.selectOption('${action.selector}', '${action.value}');`)
          break
      }
    }
    
    lines.push('', '  // await browser.close();', '})();')
    
    return lines.join('\n')
  }
}
</file>

<file path="src/commands/repl.ts">
import Interactive from './interactive.js'

export default class Repl extends Interactive {
  static description = 'Alias for interactive command - start an interactive CDP session'
  
  static aliases = ['session']
}
</file>

<file path="src/commands/scroll.ts">
import { Args, Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'

export default class Scroll extends BaseCommand {
  static description = 'Scroll the page or to specific elements'

  static examples = [
    '<%= config.bin %> <%= command.id %> down',
    '<%= config.bin %> <%= command.id %> top',
    '<%= config.bin %> <%= command.id %> bottom',
    '<%= config.bin %> <%= command.id %> --to "#section3"',
    '<%= config.bin %> <%= command.id %> --by 500',
    '<%= config.bin %> <%= command.id %> --percent 50',
  ]

  static args = {
    direction: Args.string({
      description: 'Scroll direction',
      options: ['up', 'down', 'left', 'right', 'top', 'bottom'],
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    to: Flags.string({
      char: 't',
      description: 'CSS selector to scroll to',
      exclusive: ['by', 'percent'],
    }),
    by: Flags.integer({
      char: 'b',
      description: 'Pixels to scroll by',
      exclusive: ['to', 'percent'],
    }),
    percent: Flags.integer({
      char: 'p',
      description: 'Percentage of page to scroll to (0-100)',
      exclusive: ['to', 'by'],
    }),
    smooth: Flags.boolean({
      description: 'Use smooth scrolling',
      default: true,
    }),
    'wait-after': Flags.integer({
      description: 'Wait time in ms after scrolling',
      default: 500,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Scroll)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.performScroll(this.page!)
  }

  private async performScroll(page: Page): Promise<void> {
    const { args, flags } = await this.parse(Scroll)
    
    const behavior = flags.smooth ? 'smooth' : 'auto'
    
    try {
      // Scroll to element
      if (flags.to) {
        await page.evaluate(({ selector, behavior }) => {
          const element = document.querySelector(selector)
          if (!element) throw new Error(`Element not found: ${selector}`)
          
          element.scrollIntoView({ behavior: behavior as ScrollBehavior, block: 'center' })
        }, { selector: flags.to, behavior })
        
        this.log(`‚úÖ Scrolled to element: ${flags.to}`)
      }
      // Scroll by pixels
      else if (flags.by) {
        const direction = args.direction || 'down'
        let x = 0, y = 0
        
        switch (direction) {
          case 'up':
            y = -flags.by
            break
          case 'down':
            y = flags.by
            break
          case 'left':
            x = -flags.by
            break
          case 'right':
            x = flags.by
            break
          default:
            y = flags.by // Default to down
        }
        
        await page.evaluate(({ x, y, behavior }) => {
          window.scrollBy({ left: x, top: y, behavior: behavior as ScrollBehavior })
        }, { x, y, behavior })
        
        this.log(`‚úÖ Scrolled ${direction} by ${flags.by}px`)
      }
      // Scroll to percentage
      else if (flags.percent !== undefined) {
        if (flags.percent < 0 || flags.percent > 100) {
          this.error('Percentage must be between 0 and 100')
        }
        
        await page.evaluate(({ percent, behavior }) => {
          const maxScroll = document.documentElement.scrollHeight - window.innerHeight
          const targetScroll = (maxScroll * percent) / 100
          
          window.scrollTo({ top: targetScroll, behavior: behavior as ScrollBehavior })
        }, { percent: flags.percent, behavior })
        
        this.log(`‚úÖ Scrolled to ${flags.percent}% of page`)
      }
      // Scroll by direction
      else if (args.direction) {
        switch (args.direction) {
          case 'top':
            await page.evaluate(({ behavior }) => {
              window.scrollTo({ top: 0, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled to top')
            break
            
          case 'bottom':
            await page.evaluate(({ behavior }) => {
              window.scrollTo({ 
                top: document.documentElement.scrollHeight, 
                behavior: behavior as ScrollBehavior 
              })
            }, { behavior })
            this.log('‚úÖ Scrolled to bottom')
            break
            
          case 'up':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ top: -window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled up')
            break
            
          case 'down':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ top: window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled down')
            break
            
          case 'left':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ left: -window.innerWidth * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled left')
            break
            
          case 'right':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ left: window.innerWidth * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled right')
            break
        }
      }
      // Default: scroll down one viewport
      else {
        await page.evaluate(({ behavior }) => {
          window.scrollBy({ top: window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
        }, { behavior })
        this.log('‚úÖ Scrolled down')
      }
      
      // Wait after scrolling
      if (flags['wait-after'] > 0) {
        await page.waitForTimeout(flags['wait-after'])
      }
      
      // Log current position if verbose
      if (flags.verbose) {
        const position = await page.evaluate(() => ({
          x: window.pageXOffset,
          y: window.pageYOffset,
          maxX: document.documentElement.scrollWidth - window.innerWidth,
          maxY: document.documentElement.scrollHeight - window.innerHeight,
        }))
        
        this.logVerbose('Scroll position', {
          x: `${position.x}/${position.maxX}`,
          y: `${position.y}/${position.maxY}`,
          percentX: Math.round((position.x / position.maxX) * 100) || 0,
          percentY: Math.round((position.y / position.maxY) * 100) || 0,
        })
      }
      
    } catch (error: any) {
      this.error(`Failed to scroll: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/wait-for-login.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'

export default class WaitForLogin extends BaseCommand {
  static description = 'Navigate to a URL and wait for user to complete login before continuing'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://gmail.com',
    '<%= config.bin %> <%= command.id %> https://github.com --ready-selector ".Header-link--profile"',
    '<%= config.bin %> <%= command.id %> https://app.example.com --ready-selector "#dashboard" --profile work',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'ready-selector': Flags.string({
      char: 'r',
      description: 'CSS selector that indicates successful login (default: body)',
      default: 'body',
    }),
    timeout: Flags.integer({
      char: 't',
      description: 'Maximum time to wait for login in milliseconds',
      default: 300000, // 5 minutes
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to navigate to and wait for login',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(WaitForLogin)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.waitForLogin(args.url, flags['ready-selector'])
  }
}
</file>

<file path="src/types/inquirer-autocomplete-prompt.d.ts">
declare module 'inquirer-autocomplete-prompt' {
  import { Question } from 'inquirer'
  
  interface AutocompleteQuestionOptions extends Question {
    type: 'autocomplete'
    source: (answersSoFar: any, input: string) => Promise<string[]>
    pageSize?: number
    searchText?: string
    emptyText?: string
  }
  
  const AutocompletePrompt: any
  export default AutocompletePrompt
}
</file>

<file path="src/types/schema.ts">
import { Flags } from '@oclif/core'

export interface CommandSchema {
  name: string
  description: string
  flags: Record<string, any>
  args?: Record<string, any>
  examples?: string[]
}

export interface FlagSchema {
  name: string
  char?: string
  description: string
  required: boolean
  type: 'string' | 'boolean' | 'integer'
  options?: string[]
  default?: any
  multiple?: boolean
}

export interface ArgSchema {
  name: string
  description: string
  required: boolean
  options?: string[]
}

export function extractFlagSchema(flag: any): FlagSchema {
  return {
    name: flag.name,
    char: flag.char,
    description: flag.description || '',
    required: flag.required || false,
    type: flag.type || 'string',
    options: flag.options,
    default: flag.default,
    multiple: flag.multiple || false,
  }
}

export function extractCommandSchema(command: any): CommandSchema {
  const flags: Record<string, FlagSchema> = {}
  const args: Record<string, ArgSchema> = {}
  
  // Extract flags
  if (command.flags) {
    for (const [name, flag] of Object.entries(command.flags)) {
      if (name !== 'json' && flag) { // Skip oclif's built-in json flag
        flags[name] = extractFlagSchema({ name, ...flag })
      }
    }
  }
  
  // Extract args
  if (command.args) {
    for (const [name, arg] of Object.entries(command.args)) {
      if (arg) {
        args[name] = {
          name,
          description: (arg as any).description || '',
          required: (arg as any).required || false,
          options: (arg as any).options,
        }
      }
    }
  }
  
  return {
    name: command.id || command.name,
    description: command.description || '',
    flags,
    args: Object.keys(args).length > 0 ? args : undefined,
    examples: command.examples,
  }
}
</file>

<file path="src/utils/errors.ts">
export interface CommandError extends Error {
  action?: string
  selector?: string
  originalError?: Error
  isTimeout?: boolean
}

/**
 * Check if an error is a timeout error
 */
export function isTimeoutError(error: Error): boolean {
  return (
    error.name === 'TimeoutError' ||
    error.message.includes('TimeoutError') ||
    error.message.includes('timeout') ||
    error.message.includes('Timeout') ||
    error.message.includes('Waiting failed')
  )
}

/**
 * Format error message with consistent structure
 */
export function formatErrorMessage(
  action: string,
  message: string,
  selector?: string,
  error?: Error
): string {
  if (error && isTimeoutError(error) && selector) {
    return `Timeout waiting for element: ${selector}`
  }
  
  let formattedMessage = `Failed to ${action}: ${message}`
  if (selector) {
    formattedMessage += ` (${selector})`
  }
  
  return formattedMessage
}

/**
 * Create a standardized command error
 */
export function handleCommandError(
  error: Error,
  action: string,
  selector?: string
): CommandError {
  const commandError = new Error(
    formatErrorMessage(action, error.message, selector, error)
  ) as CommandError
  
  commandError.action = action
  commandError.selector = selector
  commandError.originalError = error
  commandError.isTimeout = isTimeoutError(error)
  
  // Preserve stack trace
  if (error.stack) {
    commandError.stack = error.stack
  }
  
  return commandError
}
</file>

<file path="test/fixtures/buttons.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Button Test Page</title>
</head>
<body>
    <h1>Button Click Testing</h1>
    <div id="click-counter">
        <p>Click count: <span id="count">0</span></p>
    </div>
    <div id="button-container">
        <button id="simple-btn" class="test-button">Simple Button</button>
        <button id="counter-btn" class="test-button">Increment Counter</button>
        <button id="alert-btn" class="test-button">Show Alert</button>
        <button id="toggle-btn" class="test-button">Toggle Content</button>
        <button id="delayed-btn" class="test-button">Delayed Action</button>
        <button disabled id="disabled-btn">Disabled Button</button>
    </div>
    <div id="toggle-content" style="display: none;">
        <p>This content is toggled!</p>
    </div>
    <div id="action-log">
        <h3>Action Log:</h3>
        <ul id="log-list"></ul>
    </div>
    <script>
        let clickCount = 0;
        const logAction = (action) => {
            const li = document.createElement('li');
            li.textContent = `${new Date().toLocaleTimeString()}: ${action}`;
            document.getElementById('log-list').appendChild(li);
        };

        document.getElementById('simple-btn').addEventListener('click', () => {
            logAction('Simple button clicked');
        });

        document.getElementById('counter-btn').addEventListener('click', () => {
            clickCount++;
            document.getElementById('count').textContent = clickCount;
            logAction(`Counter incremented to ${clickCount}`);
        });

        document.getElementById('alert-btn').addEventListener('click', () => {
            alert('Alert button clicked!');
            logAction('Alert shown');
        });

        document.getElementById('toggle-btn').addEventListener('click', () => {
            const content = document.getElementById('toggle-content');
            content.style.display = content.style.display === 'none' ? 'block' : 'none';
            logAction('Content toggled');
        });

        document.getElementById('delayed-btn').addEventListener('click', () => {
            logAction('Delayed action started...');
            setTimeout(() => {
                logAction('Delayed action completed!');
            }, 2000);
        });
    </script>
</body>
</html>
</file>

<file path="test/fixtures/click-edge.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Click Edge Cases</title>
    <style>
        .hover-target {
            padding: 20px;
            background: #f0f0f0;
            transition: all 0.3s;
        }
        .hover-target:hover {
            background: #007bff;
            color: white;
        }
        .drag-item {
            padding: 10px;
            margin: 5px;
            background: #e0e0e0;
            cursor: move;
        }
        .drop-zone {
            min-height: 100px;
            border: 2px dashed #ccc;
            padding: 10px;
            margin: 10px 0;
        }
        .drop-zone.dragover {
            background: #f0f8ff;
        }
        .context-menu {
            display: none;
            position: absolute;
            background: white;
            border: 1px solid #ccc;
            box-shadow: 2px 2px 5px rgba(0,0,0,0.2);
            z-index: 1000;
        }
        .nested-clickable {
            padding: 20px;
            background: #ffe0e0;
        }
        .nested-clickable > div {
            padding: 20px;
            background: #e0ffe0;
        }
        .nested-clickable > div > button {
            padding: 10px;
        }
    </style>
</head>
<body>
    <h1>Click Edge Cases Testing</h1>
    
    <!-- Double Click -->
    <div id="double-click-area" ondblclick="handleDoubleClick()" style="padding: 20px; background: #f0f0f0;">
        Double-click me! (Count: <span id="dbl-count">0</span>)
    </div>
    
    <!-- Right Click / Context Menu -->
    <div id="right-click-area" oncontextmenu="handleRightClick(event)" style="padding: 20px; background: #e0f0e0; margin: 10px 0;">
        Right-click for context menu
    </div>
    <div id="custom-context-menu" class="context-menu">
        <div onclick="contextAction('copy')">Copy</div>
        <div onclick="contextAction('paste')">Paste</div>
        <div onclick="contextAction('delete')">Delete</div>
    </div>
    
    <!-- Hover States -->
    <div class="hover-target" id="hover-div">
        Hover over me to change color
        <span id="hover-state">Not hovered</span>
    </div>
    
    <!-- Click and Hold -->
    <button id="hold-button" 
            onmousedown="startHold()" 
            onmouseup="endHold()" 
            onmouseleave="endHold()">
        Click and Hold (Hold time: <span id="hold-time">0</span>ms)
    </button>
    
    <!-- Nested Clickable Elements -->
    <div class="nested-clickable" onclick="logClick('outer')">
        Outer clickable div
        <div onclick="logClick('middle')">
            Middle clickable div
            <button onclick="logClick('inner')">Inner button</button>
        </div>
    </div>
    <div id="click-log"></div>
    
    <!-- Click on Moving Element -->
    <button id="moving-button" onclick="clickMoving()">Click me while I move!</button>
    
    <!-- Drag and Drop -->
    <div id="drag-container">
        <div class="drag-item" draggable="true" ondragstart="drag(event)" id="drag1">Drag Item 1</div>
        <div class="drag-item" draggable="true" ondragstart="drag(event)" id="drag2">Drag Item 2</div>
    </div>
    <div class="drop-zone" ondrop="drop(event)" ondragover="allowDrop(event)" ondragenter="dragEnter(event)" ondragleave="dragLeave(event)">
        Drop Zone
    </div>
    
    <!-- Click Coordinates -->
    <div id="coordinate-click" onclick="showCoordinates(event)" style="width: 300px; height: 200px; background: #f0f0f0; position: relative;">
        Click anywhere in this box
        <div id="coord-display" style="position: absolute; bottom: 10px; right: 10px;"></div>
    </div>
    
    <!-- Disabled/Enabled Toggle -->
    <button id="toggle-target" onclick="alert('Clicked!')">Target Button</button>
    <button onclick="toggleDisabled()">Toggle Disabled State</button>
    
    <!-- Rapid Clicks -->
    <button id="rapid-click" onclick="handleRapidClick()">
        Rapid Click Test (Count: <span id="rapid-count">0</span>)
    </button>
    
    <script>
        let dblClickCount = 0;
        let holdStartTime = null;
        let holdInterval = null;
        let rapidClickCount = 0;
        let lastRapidClick = 0;
        let movingInterval = null;
        
        function handleDoubleClick() {
            dblClickCount++;
            document.getElementById('dbl-count').textContent = dblClickCount;
        }
        
        function handleRightClick(e) {
            e.preventDefault();
            const menu = document.getElementById('custom-context-menu');
            menu.style.display = 'block';
            menu.style.left = e.pageX + 'px';
            menu.style.top = e.pageY + 'px';
            
            document.addEventListener('click', () => {
                menu.style.display = 'none';
            }, { once: true });
        }
        
        function contextAction(action) {
            alert(`Context action: ${action}`);
        }
        
        function startHold() {
            holdStartTime = Date.now();
            holdInterval = setInterval(() => {
                const elapsed = Date.now() - holdStartTime;
                document.getElementById('hold-time').textContent = elapsed;
            }, 50);
        }
        
        function endHold() {
            if (holdInterval) {
                clearInterval(holdInterval);
                holdInterval = null;
                const totalTime = holdStartTime ? Date.now() - holdStartTime : 0;
                if (totalTime > 1000) {
                    alert(`Held for ${totalTime}ms!`);
                }
            }
        }
        
        function logClick(level) {
            event.stopPropagation();
            const log = document.getElementById('click-log');
            log.innerHTML += `<div>Clicked: ${level} at ${new Date().toLocaleTimeString()}</div>`;
        }
        
        function clickMoving() {
            alert('You caught the moving button!');
        }
        
        // Make button move
        let position = 0;
        setInterval(() => {
            const btn = document.getElementById('moving-button');
            position = (position + 5) % 200;
            btn.style.marginLeft = position + 'px';
        }, 100);
        
        // Drag and drop
        function drag(ev) {
            ev.dataTransfer.setData("text", ev.target.id);
        }
        
        function allowDrop(ev) {
            ev.preventDefault();
        }
        
        function dragEnter(ev) {
            ev.target.classList.add('dragover');
        }
        
        function dragLeave(ev) {
            ev.target.classList.remove('dragover');
        }
        
        function drop(ev) {
            ev.preventDefault();
            ev.target.classList.remove('dragover');
            const data = ev.dataTransfer.getData("text");
            ev.target.appendChild(document.getElementById(data));
        }
        
        function showCoordinates(e) {
            const rect = e.currentTarget.getBoundingClientRect();
            const x = Math.round(e.clientX - rect.left);
            const y = Math.round(e.clientY - rect.top);
            document.getElementById('coord-display').textContent = `Clicked at: ${x}, ${y}`;
        }
        
        function toggleDisabled() {
            const target = document.getElementById('toggle-target');
            target.disabled = !target.disabled;
        }
        
        function handleRapidClick() {
            const now = Date.now();
            if (now - lastRapidClick < 500) {
                rapidClickCount++;
            } else {
                rapidClickCount = 1;
            }
            lastRapidClick = now;
            document.getElementById('rapid-count').textContent = rapidClickCount;
        }
        
        // Hover detection
        document.getElementById('hover-div').addEventListener('mouseenter', () => {
            document.getElementById('hover-state').textContent = 'Hovered!';
        });
        
        document.getElementById('hover-div').addEventListener('mouseleave', () => {
            document.getElementById('hover-state').textContent = 'Not hovered';
        });
    </script>
</body>
</html>
</file>

<file path="test/fixtures/complex-workflow.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Complex Workflow Testing</title>
    <style>
        .wizard-step {
            display: none;
            padding: 20px;
            border: 1px solid #ddd;
            margin: 20px 0;
        }
        .wizard-step.active {
            display: block;
        }
        .progress-bar {
            width: 100%;
            height: 30px;
            background: #f0f0f0;
            margin-bottom: 20px;
        }
        .progress-fill {
            height: 100%;
            background: #4CAF50;
            transition: width 0.3s;
        }
        .error-message {
            color: red;
            display: none;
        }
        .saved-data {
            background: #e8f5e9;
            padding: 10px;
            margin: 10px 0;
            border-radius: 5px;
        }
        .search-results {
            max-height: 200px;
            overflow-y: auto;
            border: 1px solid #ddd;
            display: none;
        }
        .search-result-item {
            padding: 10px;
            cursor: pointer;
        }
        .search-result-item:hover {
            background: #f0f0f0;
        }
        .shopping-item {
            border: 1px solid #ddd;
            padding: 10px;
            margin: 5px 0;
        }
        .cart-summary {
            background: #fff3cd;
            padding: 15px;
            margin: 20px 0;
        }
    </style>
</head>
<body>
    <h1>Complex E-Commerce Workflow</h1>
    
    <div class="progress-bar">
        <div class="progress-fill" id="progress" style="width: 20%"></div>
    </div>
    
    <!-- Step 1: Search and Select Product -->
    <div class="wizard-step active" id="step1">
        <h2>Step 1: Search for Product</h2>
        <input type="text" id="search-input" placeholder="Search products..." oninput="searchProducts(this.value)">
        <div id="search-results" class="search-results"></div>
        <div id="selected-product" class="saved-data" style="display: none;">
            Selected: <span id="product-name"></span>
        </div>
        <button onclick="nextStep()" id="step1-next" disabled>Next</button>
    </div>
    
    <!-- Step 2: Configure Product -->
    <div class="wizard-step" id="step2">
        <h2>Step 2: Configure Your Product</h2>
        <div id="product-config">
            <label>
                Size:
                <select id="size-select" onchange="updatePrice()">
                    <option value="">Choose size</option>
                    <option value="small" data-price="10">Small ($10)</option>
                    <option value="medium" data-price="15">Medium ($15)</option>
                    <option value="large" data-price="20">Large ($20)</option>
                </select>
            </label>
            <br><br>
            <label>
                Color:
                <select id="color-select">
                    <option value="">Choose color</option>
                    <option value="red">Red</option>
                    <option value="blue">Blue</option>
                    <option value="green">Green</option>
                </select>
            </label>
            <br><br>
            <label>
                Quantity:
                <input type="number" id="quantity" value="1" min="1" max="10" onchange="updatePrice()">
            </label>
            <br><br>
            <div>Total Price: $<span id="total-price">0</span></div>
        </div>
        <button onclick="previousStep()">Previous</button>
        <button onclick="nextStep()" id="step2-next" disabled>Next</button>
        <div class="error-message" id="config-error">Please complete all configuration options</div>
    </div>
    
    <!-- Step 3: Customer Information -->
    <div class="wizard-step" id="step3">
        <h2>Step 3: Your Information</h2>
        <form id="customer-form">
            <label>
                Full Name:
                <input type="text" id="customer-name" required>
            </label>
            <br><br>
            <label>
                Email:
                <input type="email" id="customer-email" required>
            </label>
            <br><br>
            <label>
                Phone:
                <input type="tel" id="customer-phone" pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}" placeholder="123-456-7890">
            </label>
            <br><br>
            <label>
                Shipping Address:
                <textarea id="shipping-address" rows="3" required></textarea>
            </label>
            <br><br>
            <label>
                <input type="checkbox" id="save-info" checked>
                Save my information for next time
            </label>
        </form>
        <button onclick="previousStep()">Previous</button>
        <button onclick="validateAndNext()" id="step3-next">Next</button>
        <div class="error-message" id="form-error">Please fill in all required fields</div>
    </div>
    
    <!-- Step 4: Review and Confirm -->
    <div class="wizard-step" id="step4">
        <h2>Step 4: Review Your Order</h2>
        <div class="cart-summary" id="order-summary">
            <!-- Order details will be populated here -->
        </div>
        <label>
            <input type="checkbox" id="terms-agree">
            I agree to the terms and conditions
        </label>
        <br><br>
        <button onclick="previousStep()">Previous</button>
        <button onclick="placeOrder()" id="place-order" disabled>Place Order</button>
        <div class="error-message" id="terms-error">Please agree to terms and conditions</div>
    </div>
    
    <!-- Step 5: Confirmation -->
    <div class="wizard-step" id="step5">
        <h2>Order Confirmed!</h2>
        <div class="saved-data">
            <h3>Thank you for your order!</h3>
            <p>Order ID: <span id="order-id"></span></p>
            <p>Confirmation email sent to: <span id="confirm-email"></span></p>
        </div>
        <button onclick="startOver()">Place Another Order</button>
    </div>
    
    <!-- Hidden state management -->
    <div id="state-tracker" style="display: none;" 
         data-current-step="1" 
         data-product="" 
         data-config=""
         data-customer="">
    </div>
    
    <script>
        const products = [
            { id: 1, name: 'Laptop Case', basePrice: 25 },
            { id: 2, name: 'Wireless Mouse', basePrice: 30 },
            { id: 3, name: 'USB Hub', basePrice: 20 },
            { id: 4, name: 'Laptop Stand', basePrice: 35 },
            { id: 5, name: 'Cable Organizer', basePrice: 15 }
        ];
        
        let currentStep = 1;
        let orderData = {
            product: null,
            configuration: {},
            customer: {},
            totalPrice: 0
        };
        
        function searchProducts(query) {
            const resultsDiv = document.getElementById('search-results');
            if (query.length < 2) {
                resultsDiv.style.display = 'none';
                return;
            }
            
            const filtered = products.filter(p => 
                p.name.toLowerCase().includes(query.toLowerCase())
            );
            
            resultsDiv.innerHTML = filtered.map(p => 
                `<div class="search-result-item" onclick="selectProduct(${p.id})">${p.name} - $${p.basePrice}</div>`
            ).join('');
            
            resultsDiv.style.display = filtered.length > 0 ? 'block' : 'none';
        }
        
        function selectProduct(productId) {
            const product = products.find(p => p.id === productId);
            orderData.product = product;
            
            document.getElementById('search-results').style.display = 'none';
            document.getElementById('selected-product').style.display = 'block';
            document.getElementById('product-name').textContent = product.name;
            document.getElementById('step1-next').disabled = false;
            
            // Update state tracker
            document.getElementById('state-tracker').dataset.product = JSON.stringify(product);
        }
        
        function updatePrice() {
            const size = document.getElementById('size-select').value;
            const quantity = parseInt(document.getElementById('quantity').value) || 1;
            
            if (size && orderData.product) {
                const sizePrice = parseInt(document.querySelector(`#size-select option[value="${size}"]`).dataset.price);
                const total = (orderData.product.basePrice + sizePrice) * quantity;
                orderData.totalPrice = total;
                document.getElementById('total-price').textContent = total;
            }
            
            checkConfigComplete();
        }
        
        function checkConfigComplete() {
            const size = document.getElementById('size-select').value;
            const color = document.getElementById('color-select').value;
            const complete = size && color;
            
            document.getElementById('step2-next').disabled = !complete;
            document.getElementById('config-error').style.display = complete ? 'none' : 'block';
        }
        
        function validateAndNext() {
            const form = document.getElementById('customer-form');
            if (form.checkValidity()) {
                orderData.customer = {
                    name: document.getElementById('customer-name').value,
                    email: document.getElementById('customer-email').value,
                    phone: document.getElementById('customer-phone').value,
                    address: document.getElementById('shipping-address').value,
                    saveInfo: document.getElementById('save-info').checked
                };
                nextStep();
            } else {
                document.getElementById('form-error').style.display = 'block';
            }
        }
        
        function nextStep() {
            if (currentStep === 2) {
                orderData.configuration = {
                    size: document.getElementById('size-select').value,
                    color: document.getElementById('color-select').value,
                    quantity: document.getElementById('quantity').value
                };
            }
            
            if (currentStep === 3) {
                // Populate order summary
                const summary = document.getElementById('order-summary');
                summary.innerHTML = `
                    <h3>Order Details</h3>
                    <p><strong>Product:</strong> ${orderData.product.name}</p>
                    <p><strong>Configuration:</strong> ${orderData.configuration.size}, ${orderData.configuration.color}</p>
                    <p><strong>Quantity:</strong> ${orderData.configuration.quantity}</p>
                    <p><strong>Total Price:</strong> $${orderData.totalPrice}</p>
                    <hr>
                    <p><strong>Ship to:</strong><br>
                    ${orderData.customer.name}<br>
                    ${orderData.customer.address}<br>
                    ${orderData.customer.email}<br>
                    ${orderData.customer.phone}</p>
                `;
            }
            
            document.getElementById(`step${currentStep}`).classList.remove('active');
            currentStep++;
            document.getElementById(`step${currentStep}`).classList.add('active');
            updateProgress();
        }
        
        function previousStep() {
            document.getElementById(`step${currentStep}`).classList.remove('active');
            currentStep--;
            document.getElementById(`step${currentStep}`).classList.add('active');
            updateProgress();
        }
        
        function updateProgress() {
            const progress = (currentStep / 5) * 100;
            document.getElementById('progress').style.width = progress + '%';
            document.getElementById('state-tracker').dataset.currentStep = currentStep;
        }
        
        function placeOrder() {
            const orderId = 'ORD-' + Date.now();
            document.getElementById('order-id').textContent = orderId;
            document.getElementById('confirm-email').textContent = orderData.customer.email;
            nextStep();
        }
        
        function startOver() {
            currentStep = 1;
            orderData = {
                product: null,
                configuration: {},
                customer: {},
                totalPrice: 0
            };
            
            // Reset all steps
            document.querySelectorAll('.wizard-step').forEach(step => {
                step.classList.remove('active');
            });
            document.getElementById('step1').classList.add('active');
            
            // Reset form
            document.getElementById('search-input').value = '';
            document.getElementById('selected-product').style.display = 'none';
            document.getElementById('step1-next').disabled = true;
            
            updateProgress();
        }
        
        // Terms checkbox handler
        document.getElementById('terms-agree').addEventListener('change', (e) => {
            document.getElementById('place-order').disabled = !e.target.checked;
            document.getElementById('terms-error').style.display = e.target.checked ? 'none' : 'block';
        });
        
        // Save form state on input
        document.querySelectorAll('input, select, textarea').forEach(element => {
            element.addEventListener('change', () => {
                const state = {
                    step: currentStep,
                    data: orderData,
                    timestamp: Date.now()
                };
                sessionStorage.setItem('workflow-state', JSON.stringify(state));
            });
        });
    </script>
</body>
</html>
</file>

<file path="test/fixtures/dynamic.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Dynamic Content Test</title>
</head>
<body>
    <h1>Dynamic Content Testing</h1>
    <button id="load-content">Load Dynamic Content</button>
    <button id="add-item">Add List Item</button>
    <button id="start-timer">Start Timer</button>
    <button id="stop-timer">Stop Timer</button>
    
    <div id="dynamic-area">
        <p>Initial content</p>
    </div>
    
    <ul id="dynamic-list">
        <li>Initial item</li>
    </ul>
    
    <div id="timer-display">
        <p>Timer: <span id="timer">0</span> seconds</p>
    </div>
    
    <div id="ajax-content"></div>
    
    <script>
        let itemCount = 1;
        let timerInterval = null;
        let timerCount = 0;

        document.getElementById('load-content').addEventListener('click', () => {
            setTimeout(() => {
                document.getElementById('dynamic-area').innerHTML = `
                    <div class="loaded-content">
                        <h2>Dynamically Loaded!</h2>
                        <p>This content was loaded after a delay.</p>
                        <button id="nested-btn">Nested Button</button>
                    </div>
                `;
                
                // Add event listener to dynamically created button
                document.getElementById('nested-btn')?.addEventListener('click', () => {
                    alert('Nested button clicked!');
                });
            }, 1000);
        });

        document.getElementById('add-item').addEventListener('click', () => {
            itemCount++;
            const li = document.createElement('li');
            li.textContent = `Dynamic item ${itemCount}`;
            li.className = 'dynamic-item';
            document.getElementById('dynamic-list').appendChild(li);
        });

        document.getElementById('start-timer').addEventListener('click', () => {
            if (!timerInterval) {
                timerInterval = setInterval(() => {
                    timerCount++;
                    document.getElementById('timer').textContent = timerCount;
                }, 1000);
            }
        });

        document.getElementById('stop-timer').addEventListener('click', () => {
            if (timerInterval) {
                clearInterval(timerInterval);
                timerInterval = null;
            }
        });

        // Simulate AJAX content loading
        setTimeout(() => {
            document.getElementById('ajax-content').innerHTML = `
                <div class="ajax-loaded" data-loaded="true">
                    <h3>AJAX Content</h3>
                    <p>This content appeared after page load.</p>
                </div>
            `;
        }, 3000);
    </script>
</body>
</html>
</file>

<file path="test/fixtures/form.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Form Test Page</title>
</head>
<body>
    <h1>Form Testing</h1>
    <form id="test-form">
        <div>
            <label for="username">Username:</label>
            <input type="text" id="username" name="username" placeholder="Enter username">
        </div>
        <div>
            <label for="email">Email:</label>
            <input type="email" id="email" name="email" placeholder="test@example.com">
        </div>
        <div>
            <label for="password">Password:</label>
            <input type="password" id="password" name="password">
        </div>
        <div>
            <label for="message">Message:</label>
            <textarea id="message" name="message" rows="4" cols="50"></textarea>
        </div>
        <div>
            <label>
                <input type="checkbox" id="agree" name="agree" value="yes">
                I agree to terms
            </label>
        </div>
        <div>
            <label>
                <input type="radio" name="plan" value="basic" checked>
                Basic Plan
            </label>
            <label>
                <input type="radio" name="plan" value="premium">
                Premium Plan
            </label>
        </div>
        <button type="submit" id="submit-btn">Submit Form</button>
    </form>
    <div id="form-result" style="display: none;">
        <h2>Form Submitted!</h2>
        <p id="result-text"></p>
    </div>
    <script>
        document.getElementById('test-form').addEventListener('submit', function(e) {
            e.preventDefault();
            const formData = new FormData(this);
            const result = [];
            for (let [key, value] of formData.entries()) {
                result.push(`${key}: ${value}`);
            }
            document.getElementById('result-text').textContent = result.join(', ');
            document.getElementById('form-result').style.display = 'block';
        });
    </script>
</body>
</html>
</file>

<file path="test/fixtures/index.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Test Home Page</title>
</head>
<body>
    <h1 id="main-title">Welcome to Test Site</h1>
    <nav>
        <a href="/form.html" class="nav-link">Form Test</a>
        <a href="/buttons.html" class="nav-link">Button Test</a>
        <a href="/dynamic.html" class="nav-link">Dynamic Content</a>
        <a href="/selects.html" class="nav-link">Select Test</a>
    </nav>
    <p class="description">This is a test page for chromancer CLI testing.</p>
    <div id="content-area">
        <p data-testid="paragraph-1">First paragraph with test data.</p>
        <p data-testid="paragraph-2">Second paragraph with more content.</p>
    </div>
</body>
</html>
</file>

<file path="test/fixtures/navigation-edge.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Navigation Edge Cases</title>
</head>
<body>
    <h1>Navigation Testing</h1>
    
    <!-- Hash Navigation -->
    <nav id="hash-nav">
        <a href="#section1">Section 1</a>
        <a href="#section2">Section 2</a>
        <a href="#section3">Section 3</a>
    </nav>
    
    <!-- JavaScript Navigation -->
    <button onclick="window.location.href = '/form.html'">JS Navigate</button>
    <button onclick="window.open('/buttons.html', '_blank')">Open New Window</button>
    <button onclick="history.back()">Go Back</button>
    <button onclick="history.forward()">Go Forward</button>
    
    <!-- Meta Refresh -->
    <button id="trigger-refresh" onclick="addMetaRefresh()">Trigger Meta Refresh</button>
    
    <!-- Form Submission Navigation -->
    <form action="/form.html" method="GET" id="nav-form">
        <input type="hidden" name="source" value="navigation-edge">
        <button type="submit">Form Navigate</button>
    </form>
    
    <!-- Sections for hash navigation -->
    <div id="section1" style="height: 500px; padding-top: 50px;">
        <h2>Section 1</h2>
        <p>First section content</p>
    </div>
    
    <div id="section2" style="height: 500px; padding-top: 50px;">
        <h2>Section 2</h2>
        <p>Second section content</p>
    </div>
    
    <div id="section3" style="height: 500px; padding-top: 50px;">
        <h2>Section 3</h2>
        <p>Third section content</p>
    </div>
    
    <script>
        // Track navigation events
        let navHistory = [];
        
        window.addEventListener('hashchange', (e) => {
            navHistory.push({
                type: 'hashchange',
                from: e.oldURL,
                to: e.newURL,
                timestamp: Date.now()
            });
            document.getElementById('nav-log').textContent = JSON.stringify(navHistory, null, 2);
        });
        
        function addMetaRefresh() {
            const meta = document.createElement('meta');
            meta.httpEquiv = 'refresh';
            meta.content = '2;url=/index.html';
            document.head.appendChild(meta);
            alert('Page will redirect in 2 seconds');
        }
    </script>
    
    <pre id="nav-log">[]</pre>
</body>
</html>
</file>

<file path="test/fixtures/selects.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Select Elements Test</title>
</head>
<body>
    <h1>Select & Option Testing</h1>
    
    <div class="select-group">
        <label for="single-select">Single Select:</label>
        <select id="single-select" name="country">
            <option value="">Choose a country</option>
            <option value="us">United States</option>
            <option value="uk">United Kingdom</option>
            <option value="ca">Canada</option>
            <option value="au">Australia</option>
        </select>
    </div>
    
    <div class="select-group">
        <label for="multi-select">Multi Select:</label>
        <select id="multi-select" name="languages" multiple size="5">
            <option value="js">JavaScript</option>
            <option value="py">Python</option>
            <option value="java">Java</option>
            <option value="go">Go</option>
            <option value="rust">Rust</option>
        </select>
    </div>
    
    <div class="select-group">
        <label for="grouped-select">Grouped Options:</label>
        <select id="grouped-select" name="vehicle">
            <optgroup label="Cars">
                <option value="sedan">Sedan</option>
                <option value="suv">SUV</option>
                <option value="truck">Truck</option>
            </optgroup>
            <optgroup label="Motorcycles">
                <option value="sport">Sport Bike</option>
                <option value="cruiser">Cruiser</option>
                <option value="touring">Touring</option>
            </optgroup>
        </select>
    </div>
    
    <div id="selection-display">
        <h3>Current Selections:</h3>
        <p id="single-result">Single: None</p>
        <p id="multi-result">Multiple: None</p>
        <p id="grouped-result">Grouped: None</p>
    </div>
    
    <script>
        document.getElementById('single-select').addEventListener('change', (e) => {
            const selected = e.target.options[e.target.selectedIndex];
            document.getElementById('single-result').textContent = 
                `Single: ${selected.text} (${selected.value})`;
        });
        
        document.getElementById('multi-select').addEventListener('change', (e) => {
            const selected = Array.from(e.target.selectedOptions)
                .map(opt => `${opt.text} (${opt.value})`)
                .join(', ');
            document.getElementById('multi-result').textContent = 
                `Multiple: ${selected || 'None'}`;
        });
        
        document.getElementById('grouped-select').addEventListener('change', (e) => {
            const selected = e.target.options[e.target.selectedIndex];
            document.getElementById('grouped-result').textContent = 
                `Grouped: ${selected.text} (${selected.value})`;
        });
    </script>
</body>
</html>
</file>

<file path="test/fixtures/type-edge.html">
<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Type Edge Cases</title>
    <style>
        .input-group {
            margin: 20px 0;
            padding: 10px;
            background: #f5f5f5;
        }
        .readonly-input {
            background: #e0e0e0;
        }
        .validation-error {
            color: red;
            font-size: 0.9em;
        }
        .char-counter {
            float: right;
            color: #666;
        }
    </style>
</head>
<body>
    <h1>Type Input Edge Cases</h1>
    
    <!-- Readonly and Disabled Inputs -->
    <div class="input-group">
        <h3>Readonly/Disabled Fields</h3>
        <input type="text" id="readonly-input" value="Can't edit me!" readonly class="readonly-input">
        <input type="text" id="disabled-input" value="I'm disabled!" disabled>
        <button onclick="toggleReadonly()">Toggle Readonly</button>
    </div>
    
    <!-- Input with Validation -->
    <div class="input-group">
        <h3>Input Validation</h3>
        <input type="email" id="email-validation" placeholder="Enter valid email" oninput="validateEmail(this)">
        <span id="email-error" class="validation-error"></span>
        <br><br>
        <input type="number" id="number-input" min="0" max="100" placeholder="0-100">
        <input type="tel" id="phone-input" pattern="[0-9]{3}-[0-9]{3}-[0-9]{4}" placeholder="123-456-7890">
    </div>
    
    <!-- Character Limits -->
    <div class="input-group">
        <h3>Character Limits</h3>
        <input type="text" id="maxlength-input" maxlength="10" placeholder="Max 10 chars" oninput="updateCounter(this, 'counter1')">
        <span id="counter1" class="char-counter">0/10</span>
        <br><br>
        <textarea id="textarea-limit" maxlength="50" rows="3" cols="40" oninput="updateCounter(this, 'counter2')" placeholder="Max 50 chars"></textarea>
        <span id="counter2" class="char-counter">0/50</span>
    </div>
    
    <!-- Auto-formatting Inputs -->
    <div class="input-group">
        <h3>Auto-formatting</h3>
        <input type="text" id="phone-format" placeholder="Phone: (123) 456-7890" oninput="formatPhone(this)">
        <input type="text" id="credit-card" placeholder="Card: 1234 5678 9012 3456" oninput="formatCreditCard(this)">
        <input type="text" id="uppercase-input" placeholder="Auto uppercase" oninput="this.value = this.value.toUpperCase()">
    </div>
    
    <!-- Paste Events -->
    <div class="input-group">
        <h3>Paste Handling</h3>
        <input type="text" id="paste-input" placeholder="Try pasting here" onpaste="handlePaste(event)">
        <div id="paste-log"></div>
        <input type="text" id="no-paste" placeholder="Paste disabled" onpaste="return false;">
    </div>
    
    <!-- Input with Keyboard Shortcuts -->
    <div class="input-group">
        <h3>Keyboard Shortcuts</h3>
        <input type="text" id="shortcut-input" placeholder="Try Ctrl+S, Ctrl+Enter" onkeydown="handleShortcut(event)">
        <div id="shortcut-log"></div>
    </div>
    
    <!-- Contenteditable -->
    <div class="input-group">
        <h3>ContentEditable</h3>
        <div id="contenteditable" contenteditable="true" style="border: 1px solid #ccc; padding: 10px; min-height: 50px;">
            This is editable content. Try typing here!
        </div>
        <button onclick="getEditableContent()">Get Content</button>
        <div id="editable-output"></div>
    </div>
    
    <!-- Input with Debounce -->
    <div class="input-group">
        <h3>Debounced Input</h3>
        <input type="text" id="debounce-input" placeholder="Type to search..." oninput="debounceSearch(this.value)">
        <div id="search-status">Ready</div>
        <div id="search-results"></div>
    </div>
    
    <!-- Hidden/Visible Toggle -->
    <div class="input-group">
        <h3>Dynamic Visibility</h3>
        <input type="text" id="toggle-input" style="display: none;" placeholder="Initially hidden">
        <button onclick="toggleVisibility()">Toggle Input Visibility</button>
    </div>
    
    <!-- Input with Focus/Blur Events -->
    <div class="input-group">
        <h3>Focus Events</h3>
        <input type="text" id="focus-input" 
               placeholder="Focus/blur events" 
               onfocus="logEvent('focus')" 
               onblur="logEvent('blur')"
               onchange="logEvent('change')">
        <div id="event-log"></div>
    </div>
    
    <!-- Input in iframe -->
    <div class="input-group">
        <h3>iFrame Input</h3>
        <iframe id="input-iframe" srcdoc="<input type='text' id='iframe-input' placeholder='Input in iframe'>" style="width: 300px; height: 60px; border: 1px solid #ccc;"></iframe>
    </div>
    
    <script>
        function toggleReadonly() {
            const input = document.getElementById('readonly-input');
            input.readOnly = !input.readOnly;
        }
        
        function validateEmail(input) {
            const error = document.getElementById('email-error');
            const valid = /^[^\s@]+@[^\s@]+\.[^\s@]+$/.test(input.value);
            error.textContent = input.value && !valid ? 'Invalid email format' : '';
        }
        
        function updateCounter(input, counterId) {
            const counter = document.getElementById(counterId);
            counter.textContent = `${input.value.length}/${input.maxLength}`;
        }
        
        function formatPhone(input) {
            let value = input.value.replace(/\D/g, '');
            if (value.length >= 6) {
                value = `(${value.slice(0,3)}) ${value.slice(3,6)}-${value.slice(6,10)}`;
            } else if (value.length >= 3) {
                value = `(${value.slice(0,3)}) ${value.slice(3)}`;
            }
            input.value = value;
        }
        
        function formatCreditCard(input) {
            let value = input.value.replace(/\s/g, '');
            let formatted = value.match(/.{1,4}/g)?.join(' ') || value;
            input.value = formatted;
        }
        
        function handlePaste(e) {
            e.preventDefault();
            const pastedText = e.clipboardData.getData('text');
            document.getElementById('paste-log').innerHTML = `Pasted: "${pastedText}" at ${new Date().toLocaleTimeString()}`;
            e.target.value = pastedText.toUpperCase(); // Transform pasted text
        }
        
        function handleShortcut(e) {
            if (e.ctrlKey || e.metaKey) {
                if (e.key === 's') {
                    e.preventDefault();
                    document.getElementById('shortcut-log').innerHTML += '<div>Ctrl+S pressed - Save triggered</div>';
                } else if (e.key === 'Enter') {
                    e.preventDefault();
                    document.getElementById('shortcut-log').innerHTML += '<div>Ctrl+Enter pressed - Submit triggered</div>';
                }
            }
        }
        
        function getEditableContent() {
            const content = document.getElementById('contenteditable').innerHTML;
            document.getElementById('editable-output').textContent = `Content: ${content}`;
        }
        
        let debounceTimer;
        function debounceSearch(value) {
            document.getElementById('search-status').textContent = 'Typing...';
            clearTimeout(debounceTimer);
            debounceTimer = setTimeout(() => {
                document.getElementById('search-status').textContent = 'Searching...';
                setTimeout(() => {
                    document.getElementById('search-results').innerHTML = `Results for "${value}"`;
                    document.getElementById('search-status').textContent = 'Ready';
                }, 500);
            }, 300);
        }
        
        function toggleVisibility() {
            const input = document.getElementById('toggle-input');
            input.style.display = input.style.display === 'none' ? 'block' : 'none';
        }
        
        function logEvent(eventType) {
            const log = document.getElementById('event-log');
            log.innerHTML = `<div>${eventType} at ${new Date().toLocaleTimeString()}</div>` + log.innerHTML;
        }
    </script>
</body>
</html>
</file>

<file path="test/utils/errors.test.js">
import { describe, it, expect } from 'vitest';
import { handleCommandError, isTimeoutError, formatErrorMessage } from '../../src/utils/errors.js';

describe('Error Utilities', () => {
  describe('isTimeoutError', () => {
    it('should identify timeout errors by name', () => {
      const error = new Error('Timeout');
      error.name = 'TimeoutError';
      
      expect(isTimeoutError(error)).toBe(true);
    });

    it('should identify timeout errors by message', () => {
      const error = new Error('TimeoutError: Waiting failed');
      
      expect(isTimeoutError(error)).toBe(true);
    });

    it('should identify puppeteer timeout errors', () => {
      const error = new Error('Waiting failed: timeout 30000ms exceeded');
      
      expect(isTimeoutError(error)).toBe(true);
    });

    it('should return false for non-timeout errors', () => {
      const error = new Error('Click failed');
      
      expect(isTimeoutError(error)).toBe(false);
    });
  });

  describe('formatErrorMessage', () => {
    it('should format error message for element not found', () => {
      const message = formatErrorMessage('click', 'Element not found: #button');
      
      expect(message).toBe('Failed to click: Element not found: #button');
    });

    it('should format error message with selector', () => {
      const message = formatErrorMessage('type', 'Cannot type in element', '#input');
      
      expect(message).toBe('Failed to type: Cannot type in element (#input)');
    });

    it('should handle timeout errors specially', () => {
      const error = new Error('Timeout');
      error.name = 'TimeoutError';
      
      const message = formatErrorMessage('wait', error.message, '#modal', error);
      
      expect(message).toBe('Timeout waiting for element: #modal');
    });
  });

  describe('handleCommandError', () => {
    it('should create CommandError with proper structure', () => {
      const originalError = new Error('Element not found');
      
      const commandError = handleCommandError(originalError, 'click', '#button');
      
      expect(commandError).toBeInstanceOf(Error);
      expect(commandError.message).toBe('Failed to click: Element not found (#button)');
      expect(commandError.action).toBe('click');
      expect(commandError.selector).toBe('#button');
      expect(commandError.originalError).toBe(originalError);
    });

    it('should handle timeout errors', () => {
      const timeoutError = new Error('Waiting failed');
      timeoutError.name = 'TimeoutError';
      
      const commandError = handleCommandError(timeoutError, 'wait', '.loading');
      
      expect(commandError.message).toBe('Timeout waiting for element: .loading');
      expect(commandError.isTimeout).toBe(true);
    });

    it('should preserve stack trace', () => {
      const originalError = new Error('Test error');
      const stack = originalError.stack;
      
      const commandError = handleCommandError(originalError, 'evaluate');
      
      expect(commandError.stack).toContain(stack);
    });
  });
});
</file>

<file path="test/utils/evaluation.test.js">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { safeEvaluate, evaluateElementProperty, evaluateElementProperties } from '../../src/utils/evaluation.js';

describe('Evaluation Utilities', () => {
  let mockPage;
  let mockElement;

  beforeEach(() => {
    mockElement = {};
    mockPage = {
      evaluate: vi.fn(),
      $: vi.fn().mockResolvedValue(mockElement),
    };
  });

  describe('safeEvaluate', () => {
    it('should evaluate expression successfully', async () => {
      mockPage.evaluate.mockResolvedValue('test result');
      
      const result = await safeEvaluate(mockPage, 'document.title');
      
      expect(result).toBe('test result');
      expect(mockPage.evaluate).toHaveBeenCalledWith('document.title');
    });

    it('should evaluate function successfully', async () => {
      const testFn = () => window.location.href;
      mockPage.evaluate.mockResolvedValue('https://example.com');
      
      const result = await safeEvaluate(mockPage, testFn);
      
      expect(result).toBe('https://example.com');
      expect(mockPage.evaluate).toHaveBeenCalledWith(testFn);
    });

    it('should handle evaluation errors gracefully', async () => {
      mockPage.evaluate.mockRejectedValue(new Error('Evaluation failed'));
      
      await expect(safeEvaluate(mockPage, 'invalid.code')).rejects.toThrow(
        'Failed to evaluate: Evaluation failed'
      );
    });

    it('should handle syntax errors', async () => {
      mockPage.evaluate.mockRejectedValue(new SyntaxError('Unexpected token'));
      
      await expect(safeEvaluate(mockPage, 'bad syntax {')).rejects.toThrow(
        'Invalid JavaScript expression: Unexpected token'
      );
    });
  });

  describe('evaluateElementProperty', () => {
    it('should get element text content', async () => {
      mockPage.evaluate.mockResolvedValue('Button Text');
      
      const result = await evaluateElementProperty(mockPage, mockElement, 'textContent');
      
      expect(result).toBe('Button Text');
      expect(mockPage.evaluate).toHaveBeenCalledWith(
        expect.any(Function),
        mockElement,
        'textContent'
      );
    });

    it('should get element value', async () => {
      mockPage.evaluate.mockResolvedValue('input value');
      
      const result = await evaluateElementProperty(mockPage, mockElement, 'value');
      
      expect(result).toBe('input value');
    });

    it('should get element attribute', async () => {
      mockPage.evaluate.mockResolvedValue('https://example.com');
      
      const result = await evaluateElementProperty(mockPage, mockElement, 'href');
      
      expect(result).toBe('https://example.com');
    });

    it('should return null for non-existent property', async () => {
      mockPage.evaluate.mockResolvedValue(null);
      
      const result = await evaluateElementProperty(mockPage, mockElement, 'nonExistent');
      
      expect(result).toBeNull();
    });
  });

  describe('evaluateElementProperties', () => {
    it('should get multiple properties at once', async () => {
      const properties = {
        textContent: 'Click me',
        id: 'submit-btn',
        className: 'btn primary',
        disabled: false,
      };
      mockPage.evaluate.mockResolvedValue(properties);
      
      const result = await evaluateElementProperties(mockPage, mockElement, [
        'textContent',
        'id',
        'className',
        'disabled',
      ]);
      
      expect(result).toEqual(properties);
      expect(mockPage.evaluate).toHaveBeenCalledWith(
        expect.any(Function),
        mockElement,
        ['textContent', 'id', 'className', 'disabled']
      );
    });

    it('should handle empty properties array', async () => {
      const result = await evaluateElementProperties(mockPage, mockElement, []);
      
      expect(result).toEqual({});
      expect(mockPage.evaluate).toHaveBeenCalled();
    });

    it('should get all default properties when none specified', async () => {
      const defaultProps = {
        textContent: 'Text',
        value: '',
        id: 'element-id',
        className: 'class',
        tagName: 'DIV',
        href: null,
      };
      mockPage.evaluate.mockResolvedValue(defaultProps);
      
      const result = await evaluateElementProperties(mockPage, mockElement);
      
      expect(result).toEqual(defaultProps);
    });
  });
});
</file>

<file path="test/utils/selectors.test.js">
import { describe, it, expect, beforeEach, vi } from 'vitest';
import { waitForElement, isElementVisible, getElementInfo } from '../../src/utils/selectors.js';

describe('Selector Utilities', () => {
  let mockPage;
  let mockElement;

  beforeEach(() => {
    mockElement = {
      hover: vi.fn(),
      click: vi.fn(),
      type: vi.fn(),
    };
    
    mockPage = {
      waitForSelector: vi.fn().mockResolvedValue(mockElement),
      $: vi.fn().mockResolvedValue(mockElement),
      $$: vi.fn().mockResolvedValue([mockElement]),
      evaluate: vi.fn(),
    };
  });

  describe('waitForElement', () => {
    it('should wait for element with default timeout', async () => {
      const element = await waitForElement(mockPage, '#test');
      
      expect(mockPage.waitForSelector).toHaveBeenCalledWith('#test', {
        timeout: 30000,
      });
      expect(element).toBe(mockElement);
    });

    it('should wait for element with custom timeout', async () => {
      await waitForElement(mockPage, '.button', { timeout: 5000 });
      
      expect(mockPage.waitForSelector).toHaveBeenCalledWith('.button', {
        timeout: 5000,
      });
    });

    it('should wait for visible element', async () => {
      await waitForElement(mockPage, '#modal', { visible: true });
      
      expect(mockPage.waitForSelector).toHaveBeenCalledWith('#modal', {
        timeout: 30000,
        visible: true,
      });
    });

    it('should wait for hidden element', async () => {
      await waitForElement(mockPage, '#loader', { hidden: true });
      
      expect(mockPage.waitForSelector).toHaveBeenCalledWith('#loader', {
        timeout: 30000,
        hidden: true,
      });
    });

    it('should throw error when element not found', async () => {
      mockPage.waitForSelector.mockRejectedValue(new Error('TimeoutError: Waiting failed'));
      
      await expect(waitForElement(mockPage, '#missing')).rejects.toThrow('Element not found: #missing');
    });
  });

  describe('isElementVisible', () => {
    it('should return true for visible element', async () => {
      mockPage.evaluate.mockResolvedValue(true);
      
      const visible = await isElementVisible(mockPage, '#visible');
      
      expect(visible).toBe(true);
      expect(mockPage.evaluate).toHaveBeenCalledWith(expect.any(Function), '#visible');
    });

    it('should return false for hidden element', async () => {
      mockPage.evaluate.mockResolvedValue(false);
      
      const visible = await isElementVisible(mockPage, '#hidden');
      
      expect(visible).toBe(false);
    });

    it('should return false for non-existent element', async () => {
      mockPage.evaluate.mockResolvedValue(false);
      
      const visible = await isElementVisible(mockPage, '#nonexistent');
      
      expect(visible).toBe(false);
    });
  });

  describe('getElementInfo', () => {
    it('should return element information', async () => {
      const expectedInfo = {
        text: 'Click me',
        value: '',
        tagName: 'BUTTON',
        id: 'submit-btn',
        className: 'btn primary',
        isVisible: true,
        isDisabled: false,
        href: null,
      };
      
      mockPage.evaluate.mockResolvedValue(expectedInfo);
      
      const info = await getElementInfo(mockPage, '#submit-btn');
      
      expect(info).toEqual(expectedInfo);
      expect(mockPage.evaluate).toHaveBeenCalledWith(expect.any(Function), mockElement);
    });

    it('should handle input elements', async () => {
      const inputInfo = {
        text: '',
        value: 'test@example.com',
        tagName: 'INPUT',
        id: 'email',
        className: 'form-control',
        isVisible: true,
        isDisabled: false,
        type: 'email',
        placeholder: 'Enter email',
      };
      
      mockPage.evaluate.mockResolvedValue(inputInfo);
      
      const info = await getElementInfo(mockPage, '#email');
      
      expect(info.value).toBe('test@example.com');
      expect(info.type).toBe('email');
    });

    it('should return null for non-existent element', async () => {
      mockPage.$.mockResolvedValue(null);
      
      const info = await getElementInfo(mockPage, '#missing');
      
      expect(info).toBeNull();
    });
  });
});
</file>

<file path="test/assert.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Assert Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should assert element exists', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert element exists - should pass
    const result = await runChromancer('assert', ['--selector', '#main-title']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('‚úì Assertion passed');
    expect(result.stdout).toContain('Element exists');
    
    // Assert non-existent element - should fail
    const failResult = await runChromancer('assert', ['--selector', '#non-existent']);
    expect(failResult.success).toBe(false);
    expect(failResult.stderr).toContain('Assertion failed');
    expect(failResult.stderr).toContain('Element not found');
  });
  
  it('should assert text content contains', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert contains text - should pass
    const result = await runChromancer('assert', ['--selector', '#main-title', '--contains', 'Welcome']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('‚úì Assertion passed');
    expect(result.stdout).toContain('contains "Welcome"');
    
    // Assert wrong text - should fail
    const failResult = await runChromancer('assert', ['--selector', '#main-title', '--contains', 'Goodbye']);
    expect(failResult.success).toBe(false);
    expect(failResult.stderr).toContain('does not contain "Goodbye"');
  });
  
  it('should assert exact text match', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Assert exact text - should pass
    const result = await runChromancer('assert', ['--selector', '#count', '--equals', '0']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('equals "0"');
    
    // Click to change value
    await runChromancer('click', ['#counter-btn']);
    
    // Assert new value
    const newResult = await runChromancer('assert', ['--selector', '#count', '--equals', '1']);
    expect(newResult.success).toBe(true);
  });
  
  it('should assert evaluation results', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Assert page title
    const result = await runChromancer('assert', ['--eval', 'document.title', '--equals', 'Form Test Page']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('‚úì Assertion passed');
    
    // Assert URL contains
    const urlResult = await runChromancer('assert', ['--eval', 'window.location.href', '--contains', 'form.html']);
    expect(urlResult.success).toBe(true);
  });
  
  it('should assert boolean evaluations', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert true condition
    const result = await runChromancer('assert', ['--eval', 'document.querySelectorAll("a").length > 0']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Expression evaluated to true');
    
    // Assert false condition - should fail
    const failResult = await runChromancer('assert', ['--eval', 'document.querySelectorAll("video").length > 0']);
    expect(failResult.success).toBe(false);
    expect(failResult.stderr).toContain('Expression evaluated to false');
  });
  
  it('should assert element count', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert count of elements
    const result = await runChromancer('assert', ['--selector', '.nav-link', '--count', '4']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Element count equals 4');
    
    // Wrong count should fail
    const failResult = await runChromancer('assert', ['--selector', '.nav-link', '--count', '10']);
    expect(failResult.success).toBe(false);
    expect(failResult.stderr).toContain('Expected 10 elements, found');
  });
  
  it('should assert element visibility', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Assert element is visible
    const visibleResult = await runChromancer('assert', ['--selector', '#readonly-input', '--visible']);
    expect(visibleResult.success).toBe(true);
    expect(visibleResult.stdout).toContain('Element is visible');
    
    // Assert hidden element is not visible
    const hiddenResult = await runChromancer('assert', ['--selector', '#toggle-input', '--not-visible']);
    expect(hiddenResult.success).toBe(true);
    expect(hiddenResult.stdout).toContain('Element is not visible');
  });
  
  it('should assert input values', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Type value
    await runChromancer('type', ['#username', 'testuser']);
    
    // Assert input value
    const result = await runChromancer('assert', ['--selector', '#username', '--value', 'testuser']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Input value equals "testuser"');
  });
  
  it('should assert with custom error messages', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert with custom message
    const result = await runChromancer('assert', [
      '--selector', '#non-existent',
      '--message', 'Critical element missing!'
    ]);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('Critical element missing!');
  });
  
  it('should support regex matching', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Assert text matches regex
    const result = await runChromancer('assert', [
      '--selector', '#main-title',
      '--matches', '^Welcome.*Site$'
    ]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('matches pattern');
  });
});
</file>

<file path="test/chromancer.test.js">
import { describe, it, expect } from 'vitest';
import { runChromancer } from './test-utils.js';

describe('Chromancer CLI', () => {
  it('should show help when run without arguments', async () => {
    const result = await runChromancer('--help');
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('chromancer');
    expect(result.stdout).toContain('COMMANDS');
  });
  
  it('should show version', async () => {
    const result = await runChromancer('--version');
    expect(result.success).toBe(true);
    expect(result.stdout).toMatch(/chromancer\/\d+\.\d+\.\d+/);
  });
  
  it('should connect to Chrome', async () => {
    // Try to navigate to verify Chrome connection works
    const result = await runChromancer('navigate', ['https://example.com']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Navigated to');
  });
});
</file>

<file path="test/click.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Click Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should click a button by ID', async () => {
    // Navigate to buttons page
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Click the counter button
    const clickResult = await runChromancer('click', ['#counter-btn']);
    expect(clickResult.success).toBe(true);
    expect(clickResult.stdout).toContain('Clicked element');
    
    // Verify counter was incremented
    const countResult = await runChromancer('evaluate', ['document.getElementById("count").textContent']);
    expect(countResult.stdout).toContain('1');
  });
  
  it('should click multiple times', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Click counter button 3 times
    await runChromancer('click', ['#counter-btn']);
    await runChromancer('click', ['#counter-btn']);
    await runChromancer('click', ['#counter-btn']);
    
    // Verify counter is at 3
    const countResult = await runChromancer('evaluate', ['document.getElementById("count").textContent']);
    expect(countResult.stdout).toContain('3');
  });
  
  it('should click links for navigation', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Click form link
    const clickResult = await runChromancer('click', ['a[href="/form.html"]']);
    expect(clickResult.success).toBe(true);
    
    // Verify we're on the form page
    const titleResult = await runChromancer('evaluate', ['document.title']);
    expect(titleResult.stdout).toContain('Form Test Page');
  });
  
  it('should handle click on toggle elements', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Click toggle button
    await runChromancer('click', ['#toggle-btn']);
    
    // Check that content is visible
    const visibleResult = await runChromancer('evaluate', [
      'window.getComputedStyle(document.getElementById("toggle-content")).display'
    ]);
    expect(visibleResult.stdout).toContain('block');
    
    // Click again to hide
    await runChromancer('click', ['#toggle-btn']);
    
    // Check that content is hidden
    const hiddenResult = await runChromancer('evaluate', [
      'window.getComputedStyle(document.getElementById("toggle-content")).display'
    ]);
    expect(hiddenResult.stdout).toContain('none');
  });
  
  it('should fail when clicking non-existent elements', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('click', ['#non-existent-button']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('not found');
  });
  
  it('should handle disabled buttons', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Try to click disabled button - should succeed but button won't do anything
    const result = await runChromancer('click', ['#disabled-btn']);
    expect(result.success).toBe(true);
  });
});
</file>

<file path="test/edge-cases.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Edge Cases - Navigation', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should handle hash navigation within same page', async () => {
    const url = getTestUrl('/navigation-edge.html');
    await runChromancer('navigate', [url]);
    
    // Click hash link
    await runChromancer('click', ['a[href="#section2"]']);
    
    // Verify we're still on same page but hash changed
    const urlResult = await runChromancer('evaluate', ['window.location.href']);
    expect(urlResult.stdout).toContain('#section2');
    
    // Verify scroll position changed
    const scrollResult = await runChromancer('evaluate', ['window.pageYOffset > 0']);
    expect(scrollResult.stdout).toContain('true');
  });
  
  it('should handle JavaScript-based navigation', async () => {
    const url = getTestUrl('/navigation-edge.html');
    await runChromancer('navigate', [url]);
    
    // Click JS navigation button
    await runChromancer('click', ['button:has-text("JS Navigate")']);
    
    // Verify navigation occurred
    const titleResult = await runChromancer('evaluate', ['document.title']);
    expect(titleResult.stdout).toContain('Form Test Page');
  });
  
  it('should handle form submission navigation', async () => {
    const url = getTestUrl('/navigation-edge.html');
    await runChromancer('navigate', [url]);
    
    // Submit form
    await runChromancer('click', ['button[type="submit"]']);
    
    // Check URL has query params
    const urlResult = await runChromancer('evaluate', ['window.location.search']);
    expect(urlResult.stdout).toContain('source=navigation-edge');
  });
  
  it('should track navigation history for back/forward', async () => {
    // Navigate through multiple pages
    await runChromancer('navigate', [getTestUrl('/index.html')]);
    await runChromancer('navigate', [getTestUrl('/form.html')]);
    await runChromancer('navigate', [getTestUrl('/buttons.html')]);
    
    // Try to go back
    await runChromancer('evaluate', ['history.back()']);
    await new Promise(resolve => setTimeout(resolve, 500));
    
    const titleResult = await runChromancer('evaluate', ['document.title']);
    expect(titleResult.stdout).toContain('Form Test Page');
  });
});

describe('Edge Cases - Click Interactions', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should handle double-click events', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Simulate double-click (two rapid clicks)
    await runChromancer('click', ['#double-click-area']);
    await runChromancer('click', ['#double-click-area']);
    
    // Note: True double-click would need a new command
    // This tests rapid clicking which is different
    const countResult = await runChromancer('evaluate', ['document.getElementById("dbl-count").textContent']);
    expect(parseInt(countResult.stdout)).toBeGreaterThan(0);
  });
  
  it('should handle nested clickable elements', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Click inner button (should stop propagation)
    await runChromancer('click', ['button:has-text("Inner button")']);
    
    // Check click log
    const logResult = await runChromancer('evaluate', ['document.getElementById("click-log").textContent']);
    expect(logResult.stdout).toContain('inner');
    expect(logResult.stdout).not.toContain('outer');
  });
  
  it('should handle rapidly changing element states', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Rapid clicks on counter
    for (let i = 0; i < 5; i++) {
      await runChromancer('click', ['#rapid-click']);
    }
    
    const countResult = await runChromancer('evaluate', ['document.getElementById("rapid-count").textContent']);
    expect(parseInt(countResult.stdout)).toBeGreaterThanOrEqual(1);
  });
  
  it('should click at specific coordinates', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Click the coordinate tracking div
    await runChromancer('click', ['#coordinate-click']);
    
    // Verify coordinates were captured
    const coordResult = await runChromancer('evaluate', ['document.getElementById("coord-display").textContent']);
    expect(coordResult.stdout).toContain('Clicked at:');
  });
});

describe('Edge Cases - Type Inputs', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should not type in readonly fields', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    const initialValue = await runChromancer('evaluate', ['document.getElementById("readonly-input").value']);
    
    // Try to type in readonly field
    await runChromancer('type', ['#readonly-input', 'new text', '--clear']);
    
    // Value should not change
    const afterValue = await runChromancer('evaluate', ['document.getElementById("readonly-input").value']);
    expect(afterValue.stdout).toBe(initialValue.stdout);
  });
  
  it('should handle maxlength restrictions', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Type more than maxlength
    await runChromancer('type', ['#maxlength-input', 'This is a very long text that exceeds the limit']);
    
    // Check length is restricted
    const valueResult = await runChromancer('evaluate', ['document.getElementById("maxlength-input").value.length']);
    expect(valueResult.stdout).toContain('10');
  });
  
  it('should handle auto-formatting inputs', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Type unformatted phone number
    await runChromancer('type', ['#phone-format', '1234567890']);
    
    // Check it was auto-formatted
    const valueResult = await runChromancer('evaluate', ['document.getElementById("phone-format").value']);
    expect(valueResult.stdout).toContain('(123) 456-7890');
  });
  
  it('should handle contenteditable elements', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Clear and type in contenteditable
    await runChromancer('click', ['#contenteditable']);
    await runChromancer('evaluate', ['document.getElementById("contenteditable").innerHTML = ""']);
    
    // Note: typing in contenteditable would need special handling
    await runChromancer('evaluate', ['document.getElementById("contenteditable").textContent = "New content"']);
    
    const contentResult = await runChromancer('evaluate', ['document.getElementById("contenteditable").textContent']);
    expect(contentResult.stdout).toContain('New content');
  });
  
  it('should handle dynamically visible inputs', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Toggle visibility
    await runChromancer('click', ['button:has-text("Toggle Input Visibility")']);
    
    // Now type in the visible input
    await runChromancer('type', ['#toggle-input', 'Now visible!']);
    
    const valueResult = await runChromancer('evaluate', ['document.getElementById("toggle-input").value']);
    expect(valueResult.stdout).toContain('Now visible!');
  });
});

describe('Edge Cases - Complex Workflows', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should complete multi-step e-commerce workflow', async () => {
    const url = getTestUrl('/complex-workflow.html');
    await runChromancer('navigate', [url]);
    
    // Step 1: Search and select product
    await runChromancer('type', ['#search-input', 'laptop']);
    await new Promise(resolve => setTimeout(resolve, 500));
    await runChromancer('click', ['.search-result-item:first-child']);
    await runChromancer('click', ['#step1-next']);
    
    // Step 2: Configure product
    await runChromancer('select', ['#size-select', 'medium']);
    await runChromancer('select', ['#color-select', 'blue']);
    await runChromancer('type', ['#quantity', '2', '--clear']);
    await runChromancer('click', ['#step2-next']);
    
    // Step 3: Fill customer info
    await runChromancer('type', ['#customer-name', 'John Doe']);
    await runChromancer('type', ['#customer-email', 'john@example.com']);
    await runChromancer('type', ['#customer-phone', '123-456-7890']);
    await runChromancer('type', ['#shipping-address', '123 Main St, City, State 12345']);
    await runChromancer('click', ['#step3-next']);
    
    // Step 4: Review and confirm
    await runChromancer('click', ['#terms-agree']);
    await runChromancer('click', ['#place-order']);
    
    // Verify order completion
    const orderIdResult = await runChromancer('evaluate', ['document.getElementById("order-id").textContent']);
    expect(orderIdResult.stdout).toContain('ORD-');
  });
  
  it('should maintain state across workflow steps', async () => {
    const url = getTestUrl('/complex-workflow.html');
    await runChromancer('navigate', [url]);
    
    // Select product
    await runChromancer('type', ['#search-input', 'mouse']);
    await new Promise(resolve => setTimeout(resolve, 500));
    await runChromancer('click', ['.search-result-item:has-text("Wireless Mouse")']);
    
    // Get state
    const stateResult = await runChromancer('evaluate', ['document.getElementById("state-tracker").dataset.product']);
    expect(stateResult.stdout).toContain('Wireless Mouse');
    
    // Navigate forward then back
    await runChromancer('click', ['#step1-next']);
    await runChromancer('click', ['button:has-text("Previous")']);
    
    // Product should still be selected
    const selectedResult = await runChromancer('evaluate', ['document.getElementById("product-name").textContent']);
    expect(selectedResult.stdout).toContain('Wireless Mouse');
  });
  
  it('should validate form inputs before proceeding', async () => {
    const url = getTestUrl('/complex-workflow.html');
    await runChromancer('navigate', [url]);
    
    // Try to proceed without selecting product
    const nextDisabled = await runChromancer('evaluate', ['document.getElementById("step1-next").disabled']);
    expect(nextDisabled.stdout).toContain('true');
    
    // Select product and go to step 2
    await runChromancer('type', ['#search-input', 'hub']);
    await new Promise(resolve => setTimeout(resolve, 500));
    await runChromancer('click', ['.search-result-item:first-child']);
    await runChromancer('click', ['#step1-next']);
    
    // Try to proceed without configuration
    const step2Disabled = await runChromancer('evaluate', ['document.getElementById("step2-next").disabled']);
    expect(step2Disabled.stdout).toContain('true');
    
    // Partial configuration should still be disabled
    await runChromancer('select', ['#size-select', 'small']);
    const stillDisabled = await runChromancer('evaluate', ['document.getElementById("step2-next").disabled']);
    expect(stillDisabled.stdout).toContain('true');
  });
});

describe('Edge Cases - Selector Caching', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should handle elements that change ID', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Store initial element reference
    const initialId = 'dynamic-list';
    
    // Add items which might change DOM
    for (let i = 0; i < 3; i++) {
      await runChromancer('click', ['#add-item']);
    }
    
    // Original selector should still work
    const itemCount = await runChromancer('evaluate', [`document.getElementById("${initialId}").children.length`]);
    expect(parseInt(itemCount.stdout)).toBe(4); // 1 initial + 3 added
  });
  
  it('should handle dynamically created elements', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Load dynamic content
    await runChromancer('click', ['#load-content']);
    
    // Wait for content to load
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Try to click dynamically created button
    const result = await runChromancer('click', ['#nested-btn']);
    expect(result.success).toBe(true);
  });
  
  it('should work with elements that move in DOM', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // The moving button changes position
    // Try to click it multiple times
    for (let i = 0; i < 3; i++) {
      await runChromancer('click', ['#moving-button']);
      await new Promise(resolve => setTimeout(resolve, 200));
    }
    
    // If any click succeeded, we handled the moving element
    expect(true).toBe(true); // Test passes if no errors
  });
});
</file>

<file path="test/evaluate.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Evaluate Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should evaluate simple expressions', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Evaluate simple math
    const mathResult = await runChromancer('evaluate', ['2 + 2']);
    expect(mathResult.success).toBe(true);
    expect(mathResult.stdout).toContain('4');
    
    // Evaluate string
    const stringResult = await runChromancer('evaluate', ['"Hello" + " " + "World"']);
    expect(stringResult.stdout).toContain('Hello World');
  });
  
  it('should access DOM elements', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Get page title
    const titleResult = await runChromancer('evaluate', ['document.title']);
    expect(titleResult.stdout).toContain('Test Home Page');
    
    // Get element text
    const h1Result = await runChromancer('evaluate', ['document.getElementById("main-title").textContent']);
    expect(h1Result.stdout).toContain('Welcome to Test Site');
    
    // Count elements
    const linkResult = await runChromancer('evaluate', ['document.querySelectorAll(".nav-link").length']);
    expect(linkResult.stdout).toContain('4');
  });
  
  it('should evaluate complex expressions', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Get all link hrefs
    const expression = 'Array.from(document.querySelectorAll("a")).map(a => a.href)';
    const result = await runChromancer('evaluate', [expression]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('form.html');
    expect(result.stdout).toContain('buttons.html');
  });
  
  it('should handle async expressions with --async flag', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Wait for dynamic content
    const asyncExpression = 'await new Promise(r => setTimeout(r, 100)); document.querySelectorAll("li").length';
    const result = await runChromancer('evaluate', [asyncExpression, '--async']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('1'); // Initial item
  });
  
  it('should return different data types', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Boolean
    const boolResult = await runChromancer('evaluate', ['document.body !== null']);
    expect(boolResult.stdout).toContain('true');
    
    // Number
    const numResult = await runChromancer('evaluate', ['window.innerWidth']);
    expect(numResult.stdout).toMatch(/\d+/);
    
    // Object
    const objResult = await runChromancer('evaluate', ['({name: "test", value: 123})']);
    expect(objResult.stdout).toContain('name');
    expect(objResult.stdout).toContain('test');
    expect(objResult.stdout).toContain('123');
  });
  
  it('should handle errors gracefully', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Syntax error
    const result = await runChromancer('evaluate', ['this is not valid javascript']);
    expect(result.success).toBe(false);
    
    // Reference error
    const refResult = await runChromancer('evaluate', ['nonExistentVariable']);
    expect(refResult.success).toBe(false);
  });
  
  it('should work with page state changes', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Check initial count
    const initialResult = await runChromancer('evaluate', ['document.getElementById("count").textContent']);
    expect(initialResult.stdout).toContain('0');
    
    // Click button
    await runChromancer('click', ['#counter-btn']);
    
    // Check updated count
    const updatedResult = await runChromancer('evaluate', ['document.getElementById("count").textContent']);
    expect(updatedResult.stdout).toContain('1');
  });
});
</file>

<file path="test/hover.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Hover Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should hover over element and trigger hover state', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Verify initial state
    const initialState = await runChromancer('evaluate', ['document.getElementById("hover-state").textContent']);
    expect(initialState.stdout).toContain('Not hovered');
    
    // Hover over element
    const result = await runChromancer('hover', ['#hover-div']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Hovered over element');
    
    // Verify hover state changed
    const hoverState = await runChromancer('evaluate', ['document.getElementById("hover-state").textContent']);
    expect(hoverState.stdout).toContain('Hovered!');
  });
  
  it('should hover with duration', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Hover for specific duration
    const result = await runChromancer('hover', ['#hover-div', '--duration', '1000']);
    expect(result.success).toBe(true);
    
    // Should still be hovered after 500ms
    await new Promise(resolve => setTimeout(resolve, 500));
    const midState = await runChromancer('evaluate', ['document.getElementById("hover-state").textContent']);
    expect(midState.stdout).toContain('Hovered!');
  });
  
  it('should trigger CSS hover effects', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Hover over link to trigger CSS :hover
    const result = await runChromancer('hover', ['.nav-link:first-child']);
    expect(result.success).toBe(true);
    
    // In real scenario, CSS hover state would change styles
    // We can verify the element was found and hovered
    expect(result.stdout).toContain('Hovered over element');
  });
  
  it('should show tooltips on hover', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Add a tooltip element for testing
    await runChromancer('evaluate', [`
      const link = document.querySelector('.nav-link');
      link.title = 'This is a tooltip';
      link.setAttribute('data-tooltip', 'Custom tooltip');
    `]);
    
    // Hover to show tooltip
    const result = await runChromancer('hover', ['.nav-link']);
    expect(result.success).toBe(true);
  });
  
  it('should handle hover on moving elements', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Try to hover on moving button
    const result = await runChromancer('hover', ['#moving-button']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Hovered over element');
  });
  
  it('should fail when hovering non-existent elements', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('hover', ['#non-existent-element']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('Element not found');
  });
  
  it('should hover and then move away', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Hover over element
    await runChromancer('hover', ['#hover-div']);
    
    // Verify hovered
    const hoverState = await runChromancer('evaluate', ['document.getElementById("hover-state").textContent']);
    expect(hoverState.stdout).toContain('Hovered!');
    
    // Move mouse away by hovering on body
    await runChromancer('hover', ['body']);
    
    // Verify no longer hovered
    await new Promise(resolve => setTimeout(resolve, 100));
    const afterState = await runChromancer('evaluate', ['document.getElementById("hover-state").textContent']);
    expect(afterState.stdout).toContain('Not hovered');
  });
  
  it('should work with dropdown menus', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Create a dropdown menu for testing
    await runChromancer('evaluate', [`
      const nav = document.querySelector('nav');
      nav.innerHTML = \`
        <div class="dropdown" style="position: relative;">
          <button class="dropdown-toggle">Menu</button>
          <div class="dropdown-menu" style="display: none; position: absolute;">
            <a href="#1">Option 1</a>
            <a href="#2">Option 2</a>
          </div>
        </div>
      \`;
      
      // Add hover effect
      const dropdown = document.querySelector('.dropdown');
      dropdown.addEventListener('mouseenter', () => {
        document.querySelector('.dropdown-menu').style.display = 'block';
      });
      dropdown.addEventListener('mouseleave', () => {
        document.querySelector('.dropdown-menu').style.display = 'none';
      });
    `]);
    
    // Hover to show dropdown
    const result = await runChromancer('hover', ['.dropdown-toggle']);
    expect(result.success).toBe(true);
    
    // Verify dropdown is visible
    const menuVisible = await runChromancer('evaluate', [
      'window.getComputedStyle(document.querySelector(".dropdown-menu")).display'
    ]);
    expect(menuVisible.stdout).toContain('block');
  });
});
</file>

<file path="test/interactive.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Interactive Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should list interactive elements on page', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Since interactive mode requires user input, we can test the evaluate part
    // that lists all interactive elements
    const expression = `
      const interactiveSelectors = 'a, button, input, select, textarea, [onclick], [role="button"], [role="link"]';
      const elements = Array.from(document.querySelectorAll(interactiveSelectors));
      elements.map((el, i) => ({
        index: i,
        tag: el.tagName.toLowerCase(),
        text: el.textContent?.trim() || el.value || '',
        id: el.id || '',
        class: el.className || ''
      }))
    `;
    
    const result = await runChromancer('evaluate', [expression]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Form Test');
    expect(result.stdout).toContain('Button Test');
  });
  
  it('should find interactive elements in forms', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Check for form elements
    const expression = `
      const inputs = document.querySelectorAll('input, textarea, select, button');
      Array.from(inputs).map(el => ({
        type: el.type || el.tagName.toLowerCase(),
        id: el.id,
        name: el.name || ''
      }))
    `;
    
    const result = await runChromancer('evaluate', [expression]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('username');
    expect(result.stdout).toContain('email');
    expect(result.stdout).toContain('password');
    expect(result.stdout).toContain('textarea');
    expect(result.stdout).toContain('submit');
  });
  
  it('should identify clickable elements', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Find all buttons
    const expression = `
      const buttons = document.querySelectorAll('button');
      Array.from(buttons).map(btn => ({
        id: btn.id,
        text: btn.textContent,
        disabled: btn.disabled
      }))
    `;
    
    const result = await runChromancer('evaluate', [expression]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('simple-btn');
    expect(result.stdout).toContain('counter-btn');
    expect(result.stdout).toContain('alert-btn');
    expect(result.stdout).toContain('disabled-btn');
  });
  
  it('should handle pages with many interactive elements', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Count all interactive elements
    const countExpression = `
      const selectors = 'a, button, input, select, textarea, [onclick], [role="button"]';
      document.querySelectorAll(selectors).length
    `;
    
    const countResult = await runChromancer('evaluate', [countExpression]);
    expect(countResult.success).toBe(true);
    const count = parseInt(countResult.stdout.trim());
    expect(count).toBeGreaterThan(0);
  });
  
  it('should work with dynamically added elements', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Click to add dynamic content
    await runChromancer('click', ['#load-content']);
    await new Promise(resolve => setTimeout(resolve, 1500));
    
    // Check for dynamically added button
    const expression = `document.querySelector('#nested-btn') !== null`;
    const result = await runChromancer('evaluate', [expression]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('true');
  });
});
</file>

<file path="test/mock-chrome-test.js">
#!/usr/bin/env node

const http = require('http');
const { execSync } = require('child_process');

// Color codes
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const RESET = '\x1b[0m';

function log(message, color = RESET) {
  console.log(`${color}${message}${RESET}`);
}

// Create a mock Chrome DevTools server
function createMockServer() {
  const server = http.createServer((req, res) => {
    if (req.url === '/json/version') {
      res.writeHead(200, { 'Content-Type': 'application/json' });
      res.end(JSON.stringify({
        "Browser": "Mock Chrome",
        "Protocol-Version": "1.3",
        "User-Agent": "Mock",
        "V8-Version": "9.0",
        "WebKit-Version": "537.36",
        "webSocketDebuggerUrl": "ws://localhost:9222/devtools/browser/mock"
      }));
    } else {
      res.writeHead(404);
      res.end('Not Found');
    }
  });

  return server;
}

log('Mock Chrome Test', YELLOW);
log('================', YELLOW);

const server = createMockServer();

server.listen(9222, 'localhost', () => {
  log('Mock Chrome server started on port 9222', GREEN);
  
  // Test that we can detect the mock server
  try {
    const output = execSync('curl -s http://localhost:9222/json/version', { encoding: 'utf8' });
    const version = JSON.parse(output);
    log(`Mock server responding: ${version.Browser}`, GREEN);
  } catch (error) {
    log('Failed to connect to mock server', RED);
    server.close();
    process.exit(1);
  }

  log('\nNote: This is a basic connectivity test only.', YELLOW);
  log('The mock server does not implement full Chrome DevTools Protocol.', YELLOW);
  log('For full testing, please use a real Chrome instance.', YELLOW);
  
  // Close the server after tests
  setTimeout(() => {
    server.close();
    log('\nMock server stopped', GREEN);
  }, 2000);
});
</file>

<file path="test/navigate.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Navigate Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    // Wait for server to start
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should navigate to a URL', async () => {
    const url = getTestUrl('/index.html');
    const result = await runChromancer('navigate', [url]);
    
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Navigated to');
    expect(result.stdout).toContain(url);
  });
  
  it('should navigate to different pages', async () => {
    // First navigate to index
    const indexUrl = getTestUrl('/index.html');
    const indexResult = await runChromancer('navigate', [indexUrl]);
    expect(indexResult.success).toBe(true);
    
    // Then navigate to form page
    const formUrl = getTestUrl('/form.html');
    const formResult = await runChromancer('navigate', [formUrl]);
    expect(formResult.success).toBe(true);
    expect(formResult.stdout).toContain(formUrl);
  });
  
  it('should handle 404 pages', async () => {
    const url = getTestUrl('/non-existent.html');
    const result = await runChromancer('navigate', [url]);
    
    // Navigation should still succeed even for 404
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Navigated to');
  });
  
  it('should preserve page state after navigation', async () => {
    // Navigate to buttons page
    const url = getTestUrl('/buttons.html');
    const navResult = await runChromancer('navigate', [url]);
    expect(navResult.success).toBe(true);
    
    // Check that we can evaluate on the page
    const evalResult = await runChromancer('evaluate', ['document.title']);
    expect(evalResult.success).toBe(true);
    expect(evalResult.stdout).toContain('Button Test Page');
  });
});
</file>

<file path="test/README.md">
# Chromancer Test Suite

This directory contains comprehensive Vitest tests for the Chromancer CLI tool.

## Prerequisites

1. **Chrome/Chromium**: Must be installed on your system
2. **Node.js**: Version 18 or higher
3. **Built Project**: Run `npm run build` before testing

## Test Structure

- `fixtures/`: Mock HTML pages for testing various scenarios
  - `index.html`: Main test page with navigation
  - `form.html`: Form input testing
  - `buttons.html`: Click interaction testing
  - `dynamic.html`: Dynamic content testing
  - `selects.html`: Select dropdown testing

- Test files:
  - `navigate.test.js`: Tests for navigation command
  - `click.test.js`: Tests for click interactions
  - `type.test.js`: Tests for typing into inputs
  - `evaluate.test.js`: Tests for JavaScript evaluation
  - `screenshot.test.js`: Tests for screenshot capture
  - `select.test.js`: Tests for select dropdown interactions
  - `interactive.test.js`: Tests for interactive element selection
  - `chromancer.test.js`: General CLI tests

## Running Tests

### Method 1: Using npm scripts
```bash
# Build the project first
npm run build

# Run all tests
npm run test:vitest:run

# Run tests in watch mode
npm run test:vitest

# Run tests with UI
npm run test:vitest:ui
```

### Method 2: Manual setup
```bash
# 1. Start Chrome with remote debugging
chromancer spawn --headless
# Or use Docker:
docker run -d -p 9222:9222 zenika/alpine-chrome --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222

# 2. Start test server (optional - tests handle this)
npm run test:server

# 3. Run tests
npx vitest run
```

### Method 3: Using the test runner
```bash
node test/run-tests.js
```

## Test Scenarios Covered

1. **Navigation**
   - Navigate to URLs
   - Handle 404 pages
   - Preserve page state

2. **Click Interactions**
   - Click buttons by ID/selector
   - Multiple clicks
   - Click links for navigation
   - Toggle elements
   - Handle disabled buttons

3. **Form Input**
   - Type into text fields
   - Handle different input types (email, password)
   - Type into textareas
   - Clear existing text
   - Special characters

4. **JavaScript Evaluation**
   - Simple expressions
   - DOM access
   - Complex queries
   - Async operations
   - Error handling

5. **Screenshots**
   - Default filename generation
   - Custom filenames
   - Full page captures
   - Element-specific screenshots
   - Different formats (PNG, JPEG)

6. **Select Dropdowns**
   - Select by value
   - Select by visible text
   - Multiple selections
   - Grouped options
   - Change event triggering

7. **Interactive Mode**
   - List interactive elements
   - Find form elements
   - Identify clickable elements
   - Handle dynamic content

## Troubleshooting

1. **Chrome not found**: Ensure Chrome/Chromium is installed and in PATH
2. **Port 9222 in use**: Kill existing Chrome processes or use a different port
3. **Tests timeout**: Increase timeout in `vitest.config.js`
4. **Build errors**: Run `npm run build` before testing

## Writing New Tests

1. Create a new `.test.js` file in the `test/` directory
2. Import test utilities:
   ```javascript
   const { describe, it, expect } = require('vitest');
   const { runChromancer, getTestUrl } = require('./test-utils');
   ```
3. Follow existing test patterns for consistency
4. Add new HTML fixtures if needed in `test/fixtures/`
</file>

<file path="test/run-tests.js">
const { spawn } = require('child_process');
const path = require('path');

console.log('Starting Chromancer Vitest Tests...\n');

// Start Chrome first using the chromancer spawn command
console.log('Starting Chrome with remote debugging...');
const chromancerPath = path.join(__dirname, '..', 'bin', 'run.js');
const chromeProcess = spawn('node', [chromancerPath, 'spawn', '--headless'], {
  stdio: 'inherit'
});

// Wait for Chrome to start
setTimeout(() => {
  console.log('\nRunning tests...\n');
  
  // Run vitest
  const testProcess = spawn('npx', ['vitest', 'run'], {
    stdio: 'inherit',
    shell: true
  });
  
  testProcess.on('close', (code) => {
    console.log('\nTests completed. Stopping Chrome...');
    chromeProcess.kill();
    process.exit(code);
  });
}, 3000);

// Handle interrupts
process.on('SIGINT', () => {
  console.log('\nInterrupted. Stopping Chrome...');
  chromeProcess.kill();
  process.exit(1);
});
</file>

<file path="test/screenshot.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';
import fs from 'fs/promises';
import path from 'path';

describe('Screenshot Command', () => {
  let server;
  const screenshotDir = path.join(process.cwd(), 'test-screenshots');
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Create screenshot directory
    await fs.mkdir(screenshotDir, { recursive: true });
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
    
    // Clean up screenshots
    try {
      await fs.rm(screenshotDir, { recursive: true });
    } catch (e) {
      // Ignore if doesn't exist
    }
  });
  
  it('should take a screenshot with default filename', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('screenshot');
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Screenshot saved');
    expect(result.stdout).toMatch(/screenshot-\d+\.png/);
  });
  
  it('should take a screenshot with custom filename', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    const filename = path.join(screenshotDir, 'buttons-test.png');
    const result = await runChromancer('screenshot', [filename]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('buttons-test.png');
    
    // Verify file exists
    const stats = await fs.stat(filename);
    expect(stats.isFile()).toBe(true);
    expect(stats.size).toBeGreaterThan(0);
  });
  
  it('should take fullpage screenshot with --fullpage flag', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    const filename = path.join(screenshotDir, 'fullpage.png');
    const result = await runChromancer('screenshot', [filename, '--fullpage']);
    expect(result.success).toBe(true);
    
    // Fullpage screenshots are typically larger
    const stats = await fs.stat(filename);
    expect(stats.size).toBeGreaterThan(0);
  });
  
  it('should capture element screenshot with --selector', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    const filename = path.join(screenshotDir, 'element.png');
    const result = await runChromancer('screenshot', [filename, '--selector', '#main-title']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('element.png');
    
    // Element screenshots should be smaller than full page
    const stats = await fs.stat(filename);
    expect(stats.isFile()).toBe(true);
  });
  
  it('should handle different image formats', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // JPEG format
    const jpegFile = path.join(screenshotDir, 'test.jpg');
    const jpegResult = await runChromancer('screenshot', [jpegFile]);
    expect(jpegResult.success).toBe(true);
    
    const jpegStats = await fs.stat(jpegFile);
    expect(jpegStats.isFile()).toBe(true);
  });
  
  it('should fail when selector not found', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    const filename = path.join(screenshotDir, 'fail.png');
    const result = await runChromancer('screenshot', [filename, '--selector', '#non-existent']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('not found');
  });
  
  it('should create directory if it does not exist', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    const nestedPath = path.join(screenshotDir, 'nested', 'dir', 'screenshot.png');
    const result = await runChromancer('screenshot', [nestedPath]);
    expect(result.success).toBe(true);
    
    const stats = await fs.stat(nestedPath);
    expect(stats.isFile()).toBe(true);
  });
});
</file>

<file path="test/select.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Select Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should select option by value', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Select by value
    const result = await runChromancer('select', ['#single-select', 'uk']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Selected');
    
    // Verify selection
    const valueResult = await runChromancer('evaluate', ['document.getElementById("single-select").value']);
    expect(valueResult.stdout).toContain('uk');
  });
  
  it('should select option by visible text', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Select by text
    const result = await runChromancer('select', ['#single-select', 'Canada']);
    expect(result.success).toBe(true);
    
    // Verify selection
    const valueResult = await runChromancer('evaluate', ['document.getElementById("single-select").value']);
    expect(valueResult.stdout).toContain('ca');
  });
  
  it('should handle multiple selections', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Select multiple options
    await runChromancer('select', ['#multi-select', 'js']);
    await runChromancer('select', ['#multi-select', 'Python']); // By text
    await runChromancer('select', ['#multi-select', 'go']);
    
    // Verify selections
    const selectedResult = await runChromancer('evaluate', [
      'Array.from(document.getElementById("multi-select").selectedOptions).map(o => o.value)'
    ]);
    expect(selectedResult.stdout).toContain('js');
    expect(selectedResult.stdout).toContain('py');
    expect(selectedResult.stdout).toContain('go');
  });
  
  it('should work with grouped options', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Select from grouped options
    const result = await runChromancer('select', ['#grouped-select', 'Sport Bike']);
    expect(result.success).toBe(true);
    
    // Verify selection
    const valueResult = await runChromancer('evaluate', ['document.getElementById("grouped-select").value']);
    expect(valueResult.stdout).toContain('sport');
  });
  
  it('should trigger change events', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // Select an option
    await runChromancer('select', ['#single-select', 'us']);
    
    // Check that the display was updated
    const displayResult = await runChromancer('evaluate', ['document.getElementById("single-result").textContent']);
    expect(displayResult.stdout).toContain('United States');
    expect(displayResult.stdout).toContain('(us)');
  });
  
  it('should handle non-existent select elements', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('select', ['#non-existent-select', 'value']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('not found');
  });
  
  it('should handle non-existent option values', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('select', ['#single-select', 'non-existent-value']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('Option');
  });
  
  it('should clear selection when selecting empty value', async () => {
    const url = getTestUrl('/selects.html');
    await runChromancer('navigate', [url]);
    
    // First select something
    await runChromancer('select', ['#single-select', 'us']);
    
    // Then select empty option
    await runChromancer('select', ['#single-select', '']);
    
    // Verify empty selection
    const valueResult = await runChromancer('evaluate', ['document.getElementById("single-select").value']);
    expect(valueResult.stdout).toContain('""');
  });
});
</file>

<file path="test/setup.js">
import { spawn, exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { fileURLToPath } from 'url';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

let chromeProcess;

// Global setup - runs once before all tests
export async function setup() {
  console.log('Building project before tests...');
  await execAsync('npm run build');
  
  console.log('Starting Chrome with remote debugging...');
  
  // First, kill any existing Chrome processes on port 9222
  try {
    await execAsync('lsof -ti:9222 | xargs kill -9');
  } catch (e) {
    // Ignore if no process found
  }
  
  // Use the chromancer spawn command
  const chromancerPath = path.join(__dirname, '..', 'bin', 'run.js');
  chromeProcess = spawn('node', [chromancerPath, 'spawn', '--headless'], {
    stdio: 'pipe',
    detached: false
  });
  
  // Wait for Chrome to be ready
  console.log('Waiting for Chrome to start...');
  let ready = false;
  let attempts = 0;
  
  while (!ready && attempts < 30) {
    try {
      const { stdout } = await execAsync('curl -s http://localhost:9222/json/version');
      if (stdout.includes('Chrome')) {
        ready = true;
        console.log('Chrome is ready!');
      }
    } catch (e) {
      // Not ready yet
    }
    
    if (!ready) {
      await new Promise(resolve => setTimeout(resolve, 1000));
      attempts++;
    }
  }
  
  if (!ready) {
    throw new Error('Chrome failed to start after 30 seconds');
  }
}

// Global teardown - runs once after all tests
export async function teardown() {
  console.log('Stopping Chrome...');
  
  if (chromeProcess) {
    chromeProcess.kill('SIGTERM');
    
    // Give it time to shut down gracefully
    await new Promise(resolve => setTimeout(resolve, 1000));
    
    // Force kill if still running
    try {
      chromeProcess.kill('SIGKILL');
    } catch (e) {
      // Already dead
    }
  }
  
  // Clean up any orphaned Chrome processes
  try {
    await execAsync('pkill -f "chrome.*remote-debugging"');
  } catch (e) {
    // Ignore if no processes found
  }
}
</file>

<file path="test/store.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Store Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should store element text content', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Store element text
    const result = await runChromancer('store', ['--selector', '#main-title', '--as', 'pageTitle']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Stored value as "pageTitle"');
    expect(result.stdout).toContain('Welcome to Test Site');
    
    // Verify stored value can be used in evaluate
    const evalResult = await runChromancer('evaluate', ['chromancer.stored.pageTitle']);
    expect(evalResult.stdout).toContain('Welcome to Test Site');
  });
  
  it('should store evaluation result', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Store current URL
    const result = await runChromancer('store', ['--eval', 'window.location.href', '--as', 'currentUrl']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Stored value as "currentUrl"');
    expect(result.stdout).toContain('form.html');
    
    // Store page title
    const titleResult = await runChromancer('store', ['--eval', 'document.title', '--as', 'formTitle']);
    expect(titleResult.success).toBe(true);
    expect(titleResult.stdout).toContain('Form Test Page');
  });
  
  it('should store input values', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Type in input
    await runChromancer('type', ['#username', 'john_doe']);
    
    // Store the input value
    const result = await runChromancer('store', ['--selector', '#username', '--as', 'username', '--property', 'value']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('john_doe');
    
    // Use stored value in another field
    await runChromancer('type', ['#email', '${chromancer.stored.username}@example.com']);
  });
  
  it('should store multiple values', async () => {
    const url = getTestUrl('/buttons.html');
    await runChromancer('navigate', [url]);
    
    // Store initial count
    await runChromancer('store', ['--selector', '#count', '--as', 'initialCount']);
    
    // Click button multiple times
    await runChromancer('click', ['#counter-btn']);
    await runChromancer('click', ['#counter-btn']);
    
    // Store new count
    await runChromancer('store', ['--selector', '#count', '--as', 'newCount']);
    
    // Compare values
    const compareResult = await runChromancer('evaluate', [
      'parseInt(chromancer.stored.newCount) - parseInt(chromancer.stored.initialCount)'
    ]);
    expect(compareResult.stdout).toContain('2');
  });
  
  it('should store complex objects', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Store all links data
    const result = await runChromancer('store', [
      '--eval', 
      'Array.from(document.querySelectorAll("a")).map(a => ({ text: a.textContent, href: a.href }))',
      '--as',
      'allLinks'
    ]);
    expect(result.success).toBe(true);
    
    // Access stored array
    const linkCountResult = await runChromancer('evaluate', ['chromancer.stored.allLinks.length']);
    expect(parseInt(linkCountResult.stdout)).toBeGreaterThan(0);
  });
  
  it('should handle attribute storage', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Store element attribute
    const result = await runChromancer('store', [
      '--selector', '#email',
      '--as', 'emailPlaceholder',
      '--attribute', 'placeholder'
    ]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('test@example.com');
  });
  
  it('should list all stored values', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Store some values
    await runChromancer('store', ['--eval', '"test1"', '--as', 'var1']);
    await runChromancer('store', ['--eval', '"test2"', '--as', 'var2']);
    
    // List stored values
    const result = await runChromancer('store', ['--list']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('var1');
    expect(result.stdout).toContain('var2');
    expect(result.stdout).toContain('test1');
    expect(result.stdout).toContain('test2');
  });
  
  it('should clear stored values', async () => {
    const url = getTestUrl('/index.html');
    await runChromancer('navigate', [url]);
    
    // Store a value
    await runChromancer('store', ['--eval', '"test"', '--as', 'tempVar']);
    
    // Clear all stored values
    const result = await runChromancer('store', ['--clear']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Cleared all stored values');
    
    // Verify cleared
    const checkResult = await runChromancer('evaluate', ['typeof chromancer.stored.tempVar']);
    expect(checkResult.stdout).toContain('undefined');
  });
  
  it('should persist values across page navigations', async () => {
    // Store value on first page
    await runChromancer('navigate', [getTestUrl('/index.html')]);
    await runChromancer('store', ['--selector', '#main-title', '--as', 'firstPageTitle']);
    
    // Navigate to another page
    await runChromancer('navigate', [getTestUrl('/form.html')]);
    
    // Value should still be accessible
    const result = await runChromancer('evaluate', ['chromancer.stored.firstPageTitle']);
    expect(result.stdout).toContain('Welcome to Test Site');
  });
});
</file>

<file path="test/test-cli-intellisense.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const assert = require('assert');

// Import command registry functions
async function testCommandRegistry() {
  console.log('\nüß™ Testing Command Registry...\n');
  
  try {
    // Test that registry exports are available
    const registryPath = '../dist/commands/registry.js';
    const registry = require(registryPath);
    
    // Test getCommandNames
    const commands = registry.getCommandNames();
    assert(Array.isArray(commands), 'getCommandNames should return an array');
    assert(commands.length > 20, 'Should have at least 20 commands');
    assert(commands.includes('navigate'), 'Should include navigate command');
    assert(commands.includes('click'), 'Should include click command');
    console.log('‚úÖ getCommandNames works correctly');
    console.log(`   Found ${commands.length} commands`);
    
    // Test getCommandSchema
    const navigateSchema = registry.getCommandSchema('navigate');
    assert(navigateSchema, 'Should return schema for navigate');
    assert(navigateSchema.name === 'navigate', 'Schema should have correct name');
    assert(navigateSchema.description, 'Schema should have description');
    assert(navigateSchema.flags, 'Schema should have flags');
    console.log('‚úÖ getCommandSchema works correctly');
    
    // Test fuzzySearch
    const searchResults = registry.fuzzySearch('nav', commands);
    assert(searchResults.includes('navigate'), 'Fuzzy search should find navigate');
    assert(searchResults[0] === 'navigate', 'Navigate should be first for "nav"');
    console.log('‚úÖ fuzzySearch works correctly');
    
    // Test getFlagCompletions
    const flagCompletions = registry.getFlagCompletions('navigate', '--w');
    assert(Array.isArray(flagCompletions), 'Should return array of flag completions');
    assert(flagCompletions.some(f => f === '--wait-until'), 'Should include --wait-until');
    console.log('‚úÖ getFlagCompletions works correctly');
    
    // Test schema extraction details
    const clickSchema = registry.getCommandSchema('click');
    assert(clickSchema.flags.selector, 'Click should have selector flag');
    assert(clickSchema.flags.selector.required === true, 'Selector should be required');
    assert(clickSchema.flags.button, 'Click should have button flag');
    assert(clickSchema.flags.button.options, 'Button flag should have options');
    console.log('‚úÖ Schema extraction includes flag details');
    
    return { success: true, message: 'Command registry tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testInteractiveEnhanced() {
  console.log('\nüß™ Testing Interactive Enhanced Command...\n');
  
  try {
    // Test that interactive-enhanced command exists
    const result = await execAsync('node ../bin/run.js interactive-enhanced --help');
    assert(result.stdout.includes('Enhanced interactive mode'), 'Should have enhanced description');
    assert(result.stdout.includes('IntelliSense'), 'Should mention IntelliSense');
    console.log('‚úÖ interactive-enhanced command exists');
    
    // Test command structure
    assert(result.stdout.includes('--port'), 'Should have port flag');
    assert(result.stdout.includes('--launch'), 'Should have launch flag');
    console.log('‚úÖ Command has expected flags');
    
    return { success: true, message: 'Interactive enhanced tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testSchemaTypes() {
  console.log('\nüß™ Testing Schema Type Definitions...\n');
  
  try {
    const schemaPath = '../dist/types/schema.js';
    const schemaModule = require(schemaPath);
    
    // Test extractFlagSchema function
    const testFlag = {
      name: 'test',
      char: 't',
      description: 'Test flag',
      required: true,
      type: 'string',
      options: ['a', 'b', 'c']
    };
    
    const extracted = schemaModule.extractFlagSchema(testFlag);
    assert(extracted.name === 'test', 'Should extract name');
    assert(extracted.char === 't', 'Should extract char');
    assert(extracted.required === true, 'Should extract required');
    assert(Array.isArray(extracted.options), 'Should extract options');
    console.log('‚úÖ extractFlagSchema works correctly');
    
    // Test extractCommandSchema with mock command
    const mockCommand = {
      id: 'test-command',
      description: 'Test command description',
      flags: {
        verbose: { description: 'Verbose output', type: 'boolean' },
        file: { description: 'Input file', type: 'string', required: true }
      },
      args: {
        input: { description: 'Input argument', required: true }
      }
    };
    
    const commandSchema = schemaModule.extractCommandSchema(mockCommand);
    assert(commandSchema.name === 'test-command', 'Should extract command name');
    assert(commandSchema.description === 'Test command description', 'Should extract description');
    assert(Object.keys(commandSchema.flags).length === 2, 'Should extract all flags');
    assert(commandSchema.args, 'Should extract args');
    console.log('‚úÖ extractCommandSchema works correctly');
    
    return { success: true, message: 'Schema type tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

// Run all tests
async function runTests() {
  console.log('üöÄ Running CLI IntelliSense Tests...');
  
  const tests = [
    { name: 'Command Registry', fn: testCommandRegistry },
    { name: 'Interactive Enhanced', fn: testInteractiveEnhanced },
    { name: 'Schema Types', fn: testSchemaTypes }
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const test of tests) {
    try {
      const result = await test.fn();
      if (result.success) {
        console.log(`\n‚úÖ ${test.name}: ${result.message}`);
        passed++;
      } else {
        console.log(`\n‚ùå ${test.name}: ${result.message}`);
        failed++;
      }
    } catch (error) {
      console.log(`\n‚ùå ${test.name}: ${error.message}`);
      console.error(error);
      failed++;
    }
  }
  
  console.log(`\nüìä Summary: ${passed} passed, ${failed} failed`);
  return failed === 0;
}

if (require.main === module) {
  runTests()
    .then(success => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('Test suite error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/test-enhanced-features.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);
const path = require('path');

async function runTestSuite(name, testFile) {
  console.log(`\n${'='.repeat(60)}`);
  console.log(`Running ${name}`);
  console.log('='.repeat(60));
  
  try {
    const result = await execAsync(`node ${testFile}`, {
      cwd: __dirname,
      timeout: 60000 // 1 minute timeout
    });
    
    console.log(result.stdout);
    if (result.stderr) {
      console.error('STDERR:', result.stderr);
    }
    
    return { success: true, name };
  } catch (error) {
    console.log(error.stdout || '');
    console.error(error.stderr || error.message);
    return { success: false, name, error: error.message };
  }
}

async function runAllTests() {
  console.log('üöÄ Running All Enhanced Feature Tests\n');
  console.log('This will test:');
  console.log('  1. CLI IntelliSense (command registry, fuzzy search, schemas)');
  console.log('  2. YAML Workflows (parsing, variables, error modes)');
  console.log('  3. Error Tips (smart messages, pattern detection, formatting)');
  console.log('  4. Original unit tests (basic command structure)');
  
  const testSuites = [
    { name: 'CLI IntelliSense Tests', file: './test-cli-intellisense.js' },
    { name: 'YAML Workflow Tests', file: './test-yaml-workflows.js' },
    { name: 'Error Tips Unit Tests', file: './test-error-tips-unit.js' },
    { name: 'Original Unit Tests', file: './unit-tests.js' }
  ];
  
  const results = [];
  
  // First, ensure the project is built
  console.log('\nüì¶ Building project...');
  try {
    await execAsync('npm run build', { cwd: path.join(__dirname, '..') });
    console.log('‚úÖ Build successful\n');
  } catch (error) {
    console.error('‚ùå Build failed:', error.message);
    process.exit(1);
  }
  
  // Run each test suite
  for (const suite of testSuites) {
    const result = await runTestSuite(suite.name, suite.file);
    results.push(result);
  }
  
  // Summary
  console.log('\n' + '='.repeat(60));
  console.log('üìä FINAL SUMMARY');
  console.log('='.repeat(60));
  
  const passed = results.filter(r => r.success).length;
  const failed = results.filter(r => !r.success).length;
  
  results.forEach(result => {
    const icon = result.success ? '‚úÖ' : '‚ùå';
    console.log(`${icon} ${result.name}`);
    if (!result.success && result.error) {
      console.log(`   Error: ${result.error}`);
    }
  });
  
  console.log(`\nTotal: ${passed} passed, ${failed} failed`);
  
  if (failed === 0) {
    console.log('\nüéâ All tests passed! The enhanced features are working correctly.');
  } else {
    console.log('\n‚ö†Ô∏è  Some tests failed. Please check the output above.');
  }
  
  return failed === 0;
}

// Additional integration test
async function testFeatureIntegration() {
  console.log('\n' + '='.repeat(60));
  console.log('Running Feature Integration Test');
  console.log('='.repeat(60));
  
  console.log('\nüß™ Testing that all features work together...\n');
  
  try {
    // Test 1: Error tips in run command
    console.log('1. Testing error tips in workflow execution...');
    const errorTest = await execAsync(
      'echo "- click: nonexistent" | node ../bin/run.js run',
      { cwd: path.join(__dirname, '..') }
    ).catch(e => e);
    
    if (errorTest.stderr && errorTest.stderr.includes('üí°')) {
      console.log('‚úÖ Error tips appear in workflow execution');
    } else {
      console.log('‚ö†Ô∏è  Error tips might not be working in workflows');
    }
    
    // Test 2: Help text includes new commands
    console.log('\n2. Testing new commands in help...');
    const helpResult = await execAsync('node ../bin/run.js --help', {
      cwd: path.join(__dirname, '..')
    });
    
    const newCommands = ['run', 'interactive-enhanced'];
    const foundCommands = newCommands.filter(cmd => 
      helpResult.stdout.includes(cmd)
    );
    
    if (foundCommands.length === newCommands.length) {
      console.log('‚úÖ All new commands appear in help');
    } else {
      console.log(`‚ö†Ô∏è  Missing commands: ${newCommands.filter(c => !foundCommands.includes(c))}`);
    }
    
    // Test 3: Example workflows exist
    console.log('\n3. Testing example workflows...');
    const fs = require('fs').promises;
    const examplesExist = await fs.access(
      path.join(__dirname, '..', 'examples', 'login-workflow.yml')
    ).then(() => true).catch(() => false);
    
    if (examplesExist) {
      console.log('‚úÖ Example workflows are present');
    } else {
      console.log('‚ö†Ô∏è  Example workflows might be missing');
    }
    
    console.log('\n‚úÖ Integration tests completed');
    
  } catch (error) {
    console.error('‚ùå Integration test error:', error.message);
  }
}

// Run everything
if (require.main === module) {
  runAllTests()
    .then(async (success) => {
      await testFeatureIntegration();
      process.exit(success ? 0 : 1);
    })
    .catch(error => {
      console.error('Test runner error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/test-error-tips-unit.js">
const assert = require('assert');

// Test error tips functionality directly
async function testErrorTipsModule() {
  console.log('\nüß™ Testing Error Tips Module...\n');
  
  try {
    const errorTipsPath = '../dist/utils/error-tips.js';
    const { getErrorTip, enhanceError } = require(errorTipsPath);
    
    // Test selector error detection
    const selectorError = new Error('Element not found');
    selectorError.selector = 'button';
    
    const tip1 = getErrorTip(selectorError);
    assert(tip1.tip.includes('Did you forget'), 'Should suggest prefix for bare element');
    assert(tip1.example.includes('.button'), 'Should show class example');
    assert(tip1.example.includes('#button'), 'Should show ID example');
    console.log('‚úÖ Selector prefix detection works');
    
    // Test XPath detection
    const xpathError = new Error('Element not found');
    xpathError.selector = '//button[@id="submit"]';
    
    const tip2 = getErrorTip(xpathError);
    assert(tip2.message.includes('XPath'), 'Should detect XPath');
    assert(tip2.tip.includes('CSS selectors'), 'Should suggest CSS instead');
    console.log('‚úÖ XPath detection works');
    
    // Test timeout error
    const timeoutError = new Error('Timeout waiting for element');
    timeoutError.selector = '#slow-element';
    
    const tip3 = getErrorTip(timeoutError, 'wait');
    assert(tip3.tip.includes('timeout period'), 'Should mention timeout');
    assert(tip3.example.includes('--timeout'), 'Should suggest timeout increase');
    console.log('‚úÖ Timeout error detection works');
    
    // Test navigation error
    const navError = new Error('Invalid URL');
    const tip4 = getErrorTip(navError, 'navigate');
    assert(tip4.tip.includes('protocol'), 'Should mention protocol');
    assert(tip4.example.includes('https://'), 'Should show https example');
    console.log('‚úÖ Navigation error detection works');
    
    // Test connection error
    const connError = new Error('Connection refused');
    const tip5 = getErrorTip(connError);
    assert(tip5.tip.includes('Chrome'), 'Should mention Chrome');
    assert(tip5.tip.includes('remote debugging'), 'Should mention debugging port');
    console.log('‚úÖ Connection error detection works');
    
    // Test enhanceError function
    const basicError = new Error('Something went wrong');
    const enhanced = enhanceError(basicError, { command: 'click', selector: '#test' });
    assert(enhanced.message !== basicError.message, 'Should enhance message');
    console.log('‚úÖ Error enhancement works');
    
    return { success: true, message: 'Error tips module tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testErrorPatterns() {
  console.log('\nüß™ Testing Error Pattern Matching...\n');
  
  try {
    const { getErrorTip } = require('../dist/utils/error-tips.js');
    
    // Test various error patterns
    const patterns = [
      {
        error: { message: 'Element not found: .missing-class' },
        expectedTip: 'Ensure the element exists',
        description: 'Missing element with class'
      },
      {
        error: { message: 'Cannot type into element' },
        expectedTip: 'input field',
        description: 'Type into non-input'
      },
      {
        error: { message: 'Element is inside an iframe' },
        expectedTip: '--frame',
        description: 'iframe detection'
      },
      {
        error: { message: 'Click intercepted by another element' },
        expectedTip: 'covered by another element',
        description: 'Click interception'
      },
      {
        error: { message: 'Permission denied' },
        expectedTip: 'permissions',
        description: 'Permission error'
      }
    ];
    
    for (const pattern of patterns) {
      const tip = getErrorTip(pattern.error);
      assert(
        tip.tip.toLowerCase().includes(pattern.expectedTip.toLowerCase()),
        `${pattern.description} should include "${pattern.expectedTip}"`
      );
      console.log(`‚úÖ ${pattern.description} pattern works`);
    }
    
    return { success: true, message: 'Error pattern tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testColorOutput() {
  console.log('\nüß™ Testing Colorized Output...\n');
  
  try {
    // Test that color functions work
    // Create a chalk-like interface for testing
    const chalk = {
      red: (s) => `\x1b[31m${s}\x1b[0m`,
      yellow: (s) => `\x1b[33m${s}\x1b[0m`,
      green: (s) => `\x1b[32m${s}\x1b[0m`,
      blue: (s) => `\x1b[34m${s}\x1b[0m`,
    };
    
    // Test basic colors
    const red = chalk.red('Error');
    const yellow = chalk.yellow('Warning');
    const green = chalk.green('Success');
    const blue = chalk.blue('Info');
    
    assert(red.includes('Error'), 'Red text should contain message');
    assert(yellow.includes('Warning'), 'Yellow text should contain message');
    assert(green.includes('Success'), 'Green text should contain message');
    assert(blue.includes('Info'), 'Blue text should contain message');
    
    console.log('‚úÖ Chalk color functions work');
    
    // Test color stripping for non-TTY
    const stripAnsi = (str) => str.replace(/\u001b\[[0-9;]*m/g, '');
    assert(stripAnsi(red) === 'Error', 'Should be able to strip ANSI codes');
    console.log('‚úÖ ANSI code handling works');
    
    return { success: true, message: 'Color output tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testDocumentationLinks() {
  console.log('\nüß™ Testing Documentation Links...\n');
  
  try {
    const { displayErrorWithTip } = require('../dist/utils/error-tips.js');
    
    // Capture console output
    const originalError = console.error;
    let output = '';
    console.error = (msg) => { output += msg + '\n'; };
    
    // Test that docs links are generated
    const error = new Error('Test error');
    displayErrorWithTip(error, 'click');
    
    // Restore console
    console.error = originalError;
    
    assert(output.includes('üìö Docs:'), 'Should include docs emoji');
    assert(output.includes('https://chromancer.dev/docs/click#errors'), 'Should include command-specific link');
    console.log('‚úÖ Documentation links generated correctly');
    
    // Test without command
    output = '';
    console.error = (msg) => { output += msg + '\n'; };
    displayErrorWithTip(error);
    console.error = originalError;
    
    assert(output.includes('‚ùå'), 'Should include error emoji');
    assert(output.includes('üí°'), 'Should include tip emoji when available');
    console.log('‚úÖ Error display formatting works');
    
    return { success: true, message: 'Documentation link tests passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

// Run all tests
async function runTests() {
  console.log('üöÄ Running Error Tips Unit Tests...');
  
  const tests = [
    { name: 'Error Tips Module', fn: testErrorTipsModule },
    { name: 'Error Patterns', fn: testErrorPatterns },
    { name: 'Color Output', fn: testColorOutput },
    { name: 'Documentation Links', fn: testDocumentationLinks }
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const test of tests) {
    try {
      const result = await test.fn();
      if (result.success) {
        console.log(`\n‚úÖ ${test.name}: ${result.message}`);
        passed++;
      } else {
        console.log(`\n‚ùå ${test.name}: ${result.message}`);
        failed++;
      }
    } catch (error) {
      console.log(`\n‚ùå ${test.name}: ${error.message}`);
      console.error(error);
      failed++;
    }
  }
  
  console.log(`\nüìä Summary: ${passed} passed, ${failed} failed`);
  return failed === 0;
}

if (require.main === module) {
  runTests()
    .then(success => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('Test suite error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/test-server.js">
const express = require('express');
const path = require('path');

function createTestServer(port = 3000) {
  const app = express();
  
  // Serve static files from fixtures directory
  app.use(express.static(path.join(__dirname, 'fixtures')));
  
  // Health check endpoint
  app.get('/health', (req, res) => {
    res.json({ status: 'ok', timestamp: new Date().toISOString() });
  });
  
  // 404 handler
  app.use((req, res) => {
    res.status(404).send('Page not found');
  });
  
  const server = app.listen(port, () => {
    console.log(`Test server running at http://localhost:${port}`);
  });
  
  return {
    app,
    server,
    close: () => new Promise((resolve) => server.close(resolve)),
    url: `http://localhost:${port}`
  };
}

// If run directly, start the server
if (require.main === module) {
  createTestServer();
}

module.exports = { createTestServer };
</file>

<file path="test/test-utils.js">
import { exec } from 'child_process';
import { promisify } from 'util';
import path from 'path';
import { fileURLToPath } from 'url';

const execAsync = promisify(exec);
const __filename = fileURLToPath(import.meta.url);
const __dirname = path.dirname(__filename);

const CHROMANCER_BIN = path.join(__dirname, '..', 'bin', 'run.js');
const TEST_URL = 'http://localhost:3456';

export async function runChromancer(command, args = []) {
  const cmdArgs = [command, ...args].join(' ');
  const fullCommand = `node ${CHROMANCER_BIN} ${cmdArgs}`;
  
  try {
    const { stdout, stderr } = await execAsync(fullCommand);
    return { stdout, stderr, success: true };
  } catch (error) {
    return { 
      stdout: error.stdout || '', 
      stderr: error.stderr || error.message, 
      success: false,
      error 
    };
  }
}

export function getTestUrl(path = '') {
  return `${TEST_URL}${path}`;
}

export async function waitForElement(selector, timeout = 5000) {
  const startTime = Date.now();
  while (Date.now() - startTime < timeout) {
    const result = await runChromancer('evaluate', [`document.querySelector('${selector}') !== null`]);
    if (result.stdout.includes('true')) {
      return true;
    }
    await new Promise(resolve => setTimeout(resolve, 100));
  }
  return false;
}
</file>

<file path="test/test-working-features.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const execAsync = promisify(exec);

// Test the run command
async function testRunCommand() {
  console.log('\nüß™ Testing Run Command...\n');
  
  try {
    // Test help
    const help = await execAsync('node bin/run.js run --help');
    console.log('‚úÖ Run command exists and shows help');
    
    // Test dry-run with simple workflow
    const testDir = path.join(__dirname, 'temp-test');
    await fs.mkdir(testDir, { recursive: true });
    
    const workflow = `
- navigate: https://example.com
- wait:
    selector: body
- screenshot: test.png
`;
    
    const workflowFile = path.join(testDir, 'test.yml');
    await fs.writeFile(workflowFile, workflow);
    
    const dryRun = await execAsync(`node bin/run.js run ${workflowFile} --dry-run`);
    if (dryRun.stdout.includes('Workflow is valid')) {
      console.log('‚úÖ YAML parsing works');
    }
    
    // Test with variables
    const varWorkflow = `
- navigate: \${URL}
- wait:
    selector: \${SELECTOR}
`;
    
    const varFile = path.join(testDir, 'vars.yml');
    await fs.writeFile(varFile, varWorkflow);
    
    const varRun = await execAsync(
      `node bin/run.js run ${varFile} --dry-run --var URL=https://example.com --var SELECTOR=body`
    );
    if (varRun.stdout.includes('Workflow is valid')) {
      console.log('‚úÖ Variable substitution works');
    }
    
    // Cleanup
    await fs.rm(testDir, { recursive: true, force: true });
    
    return true;
  } catch (error) {
    console.error('‚ùå Run command test failed:', error.message);
    return false;
  }
}

// Test error tips
async function testErrorTips() {
  console.log('\nüß™ Testing Error Tips...\n');
  
  try {
    // Test selector error
    try {
      await execAsync('node bin/run.js click button --port 9999');
    } catch (error) {
      if (error.stderr.includes('üí°') || error.stdout.includes('üí°')) {
        console.log('‚úÖ Error tips are displayed');
      } else {
        console.log('‚ö†Ô∏è  Error tips might not be working');
      }
    }
    
    return true;
  } catch (error) {
    console.error('‚ùå Error tips test failed:', error.message);
    return false;
  }
}

// Test new commands in help
async function testNewCommands() {
  console.log('\nüß™ Testing New Commands...\n');
  
  try {
    const help = await execAsync('node bin/run.js --help');
    
    // Check for new commands
    const newCommands = [
      'run',
      'record',
      'export',
      'fill',
      'scroll',
      'cookies',
      'pdf',
      'network'
    ];
    
    let found = 0;
    for (const cmd of newCommands) {
      if (help.stdout.includes(cmd)) {
        found++;
      }
    }
    
    console.log(`‚úÖ Found ${found}/${newCommands.length} new commands in help`);
    
    return true;
  } catch (error) {
    console.error('‚ùå New commands test failed:', error.message);
    return false;
  }
}

// Test example workflows
async function testExamples() {
  console.log('\nüß™ Testing Example Workflows...\n');
  
  try {
    const examples = [
      'examples/login-workflow.yml',
      'examples/scraping-workflow.yml',
      'examples/form-automation.yml'
    ];
    
    let valid = 0;
    for (const example of examples) {
      try {
        await fs.access(example);
        const result = await execAsync(`node bin/run.js run ${example} --dry-run`);
        if (result.stdout.includes('Workflow is valid')) {
          valid++;
          console.log(`‚úÖ ${example} is valid`);
        }
      } catch {
        console.log(`‚ö†Ô∏è  ${example} not found or invalid`);
      }
    }
    
    console.log(`‚úÖ ${valid}/${examples.length} example workflows are valid`);
    
    return true;
  } catch (error) {
    console.error('‚ùå Examples test failed:', error.message);
    return false;
  }
}

// Run all tests
async function runAllTests() {
  console.log('üöÄ Testing Working Features\n');
  
  const tests = [
    testRunCommand,
    testErrorTips,
    testNewCommands,
    testExamples
  ];
  
  let passed = 0;
  for (const test of tests) {
    if (await test()) {
      passed++;
    }
  }
  
  console.log(`\nüìä Summary: ${passed}/${tests.length} test suites passed`);
  
  if (passed === tests.length) {
    console.log('\nüéâ All working features are functioning correctly!');
    console.log('\nWorking features:');
    console.log('  ‚úÖ YAML workflow execution with "run" command');
    console.log('  ‚úÖ Variable substitution in workflows');
    console.log('  ‚úÖ Error tips with helpful suggestions');
    console.log('  ‚úÖ 8 new automation commands');
    console.log('  ‚úÖ Example workflows');
    console.log('\nKnown limitations:');
    console.log('  ‚ö†Ô∏è  Interactive-enhanced requires ES module support');
    console.log('  ‚ö†Ô∏è  Command registry needs ES module updates');
  }
  
  return passed === tests.length;
}

if (require.main === module) {
  runAllTests()
    .then(success => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('Test error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/test-yaml-workflows.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const assert = require('assert');
const execAsync = promisify(exec);

async function testRunCommand() {
  console.log('\nüß™ Testing Run Command Structure...\n');
  
  try {
    // Test that run command exists
    const result = await execAsync('node ../bin/run.js run --help');
    assert(result.stdout.includes('Run a workflow'), 'Should have workflow description');
    assert(result.stdout.includes('YAML'), 'Should mention YAML');
    console.log('‚úÖ run command exists');
    
    // Test flags
    assert(result.stdout.includes('--strict'), 'Should have strict flag');
    assert(result.stdout.includes('--continue-on-error'), 'Should have continue-on-error flag');
    assert(result.stdout.includes('--var'), 'Should have var flag');
    assert(result.stdout.includes('--dry-run'), 'Should have dry-run flag');
    console.log('‚úÖ Command has expected flags');
    
    return { success: true, message: 'Run command structure test passed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testYamlParsing() {
  console.log('\nüß™ Testing YAML Workflow Parsing...\n');
  
  const testDir = path.join(__dirname, 'yaml-test');
  await fs.mkdir(testDir, { recursive: true });
  
  try {
    // Create test YAML file
    const yamlContent = `
# Test workflow
- navigate: https://example.com
- wait:
    selector: body
    timeout: 5000
- screenshot: test.png
`;
    
    const yamlFile = path.join(testDir, 'test-workflow.yml');
    await fs.writeFile(yamlFile, yamlContent);
    
    // Test dry-run
    const result = await execAsync(`node ../bin/run.js run ${yamlFile} --dry-run`);
    assert(result.stdout.includes('Dry run mode'), 'Should indicate dry run');
    assert(result.stdout.includes('Workflow is valid'), 'Should validate successfully');
    console.log('‚úÖ YAML parsing and validation works');
    
    // Test with invalid YAML
    const invalidYaml = 'invalid: yaml: content: here:';
    const invalidFile = path.join(testDir, 'invalid.yml');
    await fs.writeFile(invalidFile, invalidYaml);
    
    try {
      await execAsync(`node ../bin/run.js run ${invalidFile} --dry-run`);
      assert(false, 'Should fail on invalid YAML');
    } catch (error) {
      assert(error.stderr.includes('Failed to parse YAML'), 'Should show YAML parse error');
      console.log('‚úÖ Invalid YAML detection works');
    }
    
    // Cleanup
    await fs.rm(testDir, { recursive: true, force: true });
    
    return { success: true, message: 'YAML parsing tests passed' };
  } catch (error) {
    await fs.rm(testDir, { recursive: true, force: true }).catch(() => {});
    return { success: false, message: error.message };
  }
}

async function testVariableSubstitution() {
  console.log('\nüß™ Testing Variable Substitution...\n');
  
  const testDir = path.join(__dirname, 'var-test');
  await fs.mkdir(testDir, { recursive: true });
  
  try {
    // Create workflow with variables
    const yamlContent = `
- navigate: \${URL}
- type:
    selector: input[name="search"]
    text: \${SEARCH_TERM}
- wait:
    selector: .results
    timeout: \${TIMEOUT}
`;
    
    const yamlFile = path.join(testDir, 'var-workflow.yml');
    await fs.writeFile(yamlFile, yamlContent);
    
    // Test with variables (dry-run to avoid Chrome requirement)
    const result = await execAsync(
      `node ../bin/run.js run ${yamlFile} --dry-run --var URL=https://example.com --var SEARCH_TERM="test query" --var TIMEOUT=10000`
    );
    
    assert(result.stdout.includes('Workflow is valid'), 'Should validate with variables');
    console.log('‚úÖ Variable substitution syntax accepted');
    
    // Cleanup
    await fs.rm(testDir, { recursive: true, force: true });
    
    return { success: true, message: 'Variable substitution tests passed' };
  } catch (error) {
    await fs.rm(testDir, { recursive: true, force: true }).catch(() => {});
    return { success: false, message: error.message };
  }
}

async function testStdinInput() {
  console.log('\nüß™ Testing Stdin Input...\n');
  
  try {
    // Test piping workflow via stdin
    const { exec } = require('child_process');
    
    let output = '';
    let errorOutput = '';
    
    const child = exec('node ../bin/run.js run --dry-run');
    
    child.stdout.on('data', (data) => {
      output += data.toString();
    });
    
    child.stderr.on('data', (data) => {
      errorOutput += data.toString();
    });
    
    // Send YAML via stdin
    child.stdin.write('- navigate: https://example.com\n');
    child.stdin.write('- wait: body\n');
    child.stdin.end();
    
    // Wait for completion
    const exitCode = await new Promise((resolve) => {
      child.on('exit', resolve);
    });
    
    if (exitCode === 0 && output.includes('Workflow is valid')) {
      console.log('‚úÖ Stdin input accepted');
      return { success: true, message: 'Stdin input test passed' };
    } else {
      console.log('Output:', output);
      console.log('Error:', errorOutput);
      return { success: false, message: 'Stdin test failed' };
    }
  } catch (error) {
    return { success: false, message: error.message };
  }
}

async function testWorkflowExamples() {
  console.log('\nüß™ Testing Example Workflows...\n');
  
  try {
    // Test that example workflows are valid
    const examples = [
      'examples/login-workflow.yml',
      'examples/scraping-workflow.yml',
      'examples/form-automation.yml'
    ];
    
    for (const example of examples) {
      try {
        const result = await execAsync(`node ../bin/run.js run ${example} --dry-run`);
        assert(result.stdout.includes('Workflow is valid'), `${example} should be valid`);
        console.log(`‚úÖ ${example} is valid`);
      } catch (error) {
        console.log(`‚ö†Ô∏è  ${example} validation failed (might not exist)`);
      }
    }
    
    return { success: true, message: 'Example workflow tests completed' };
  } catch (error) {
    return { success: false, message: error.message };
  }
}

// Run all tests
async function runTests() {
  console.log('üöÄ Running YAML Workflow Tests...');
  
  const tests = [
    { name: 'Run Command Structure', fn: testRunCommand },
    { name: 'YAML Parsing', fn: testYamlParsing },
    { name: 'Variable Substitution', fn: testVariableSubstitution },
    { name: 'Stdin Input', fn: testStdinInput },
    { name: 'Workflow Examples', fn: testWorkflowExamples }
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const test of tests) {
    try {
      const result = await test.fn();
      if (result.success) {
        console.log(`\n‚úÖ ${test.name}: ${result.message}`);
        passed++;
      } else {
        console.log(`\n‚ùå ${test.name}: ${result.message}`);
        failed++;
      }
    } catch (error) {
      console.log(`\n‚ùå ${test.name}: ${error.message}`);
      console.error(error);
      failed++;
    }
  }
  
  console.log(`\nüìä Summary: ${passed} passed, ${failed} failed`);
  return failed === 0;
}

if (require.main === module) {
  runTests()
    .then(success => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('Test suite error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/type.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Type Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should type text into input field', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Type into username field
    const typeResult = await runChromancer('type', ['#username', 'testuser']);
    expect(typeResult.success).toBe(true);
    expect(typeResult.stdout).toContain('Typed');
    
    // Verify the value
    const valueResult = await runChromancer('evaluate', ['document.getElementById("username").value']);
    expect(valueResult.stdout).toContain('testuser');
  });
  
  it('should type into different input types', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Type username
    await runChromancer('type', ['#username', 'john_doe']);
    
    // Type email
    await runChromancer('type', ['#email', 'john@example.com']);
    
    // Type password
    await runChromancer('type', ['#password', 'secret123']);
    
    // Verify all values
    const usernameResult = await runChromancer('evaluate', ['document.getElementById("username").value']);
    expect(usernameResult.stdout).toContain('john_doe');
    
    const emailResult = await runChromancer('evaluate', ['document.getElementById("email").value']);
    expect(emailResult.stdout).toContain('john@example.com');
    
    const passwordResult = await runChromancer('evaluate', ['document.getElementById("password").value']);
    expect(passwordResult.stdout).toContain('secret123');
  });
  
  it('should type into textarea', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    const message = 'This is a multi-line\\nmessage\\nfor testing';
    await runChromancer('type', ['#message', message]);
    
    const valueResult = await runChromancer('evaluate', ['document.getElementById("message").value']);
    expect(valueResult.stdout).toContain('This is a multi-line');
    expect(valueResult.stdout).toContain('message');
    expect(valueResult.stdout).toContain('for testing');
  });
  
  it('should clear existing text before typing with --clear flag', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    // Type initial text
    await runChromancer('type', ['#username', 'initial']);
    
    // Type new text with clear
    await runChromancer('type', ['#username', 'replacement', '--clear']);
    
    // Verify only new text exists
    const valueResult = await runChromancer('evaluate', ['document.getElementById("username").value']);
    expect(valueResult.stdout).toContain('replacement');
    expect(valueResult.stdout).not.toContain('initial');
  });
  
  it('should handle special characters', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    const specialText = 'Test@123!#$%';
    await runChromancer('type', ['#username', specialText]);
    
    const valueResult = await runChromancer('evaluate', ['document.getElementById("username").value']);
    expect(valueResult.stdout).toContain(specialText);
  });
  
  it('should fail when typing into non-existent elements', async () => {
    const url = getTestUrl('/form.html');
    await runChromancer('navigate', [url]);
    
    const result = await runChromancer('type', ['#non-existent', 'test']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('not found');
  });
});
</file>

<file path="test/wait.test.js">
import { describe, it, expect, beforeAll, afterAll } from 'vitest';
import { runChromancer, getTestUrl } from './test-utils.js';
import { createTestServer } from './test-server.js';

describe('Wait Command', () => {
  let server;
  
  beforeAll(async () => {
    server = createTestServer(3456);
    await new Promise(resolve => setTimeout(resolve, 1000));
  });
  
  afterAll(async () => {
    if (server) {
      await server.close();
    }
  });
  
  it('should wait for element to appear', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Click button that loads content after delay
    await runChromancer('click', ['#load-content']);
    
    // Wait for dynamically loaded element
    const result = await runChromancer('wait', ['--selector', '#nested-btn']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Element found');
    
    // Verify element is now clickable
    const clickResult = await runChromancer('click', ['#nested-btn']);
    expect(clickResult.success).toBe(true);
  });
  
  it('should wait with custom timeout', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Try to wait for non-existent element with short timeout
    const result = await runChromancer('wait', ['--selector', '#non-existent', '--timeout', '1000']);
    expect(result.success).toBe(false);
    expect(result.stderr).toContain('Timeout waiting for element');
  });
  
  it('should wait for element to be visible', async () => {
    const url = getTestUrl('/type-edge.html');
    await runChromancer('navigate', [url]);
    
    // Element exists but is hidden
    const existsResult = await runChromancer('evaluate', ['document.getElementById("toggle-input") !== null']);
    expect(existsResult.stdout).toContain('true');
    
    // Click to show element
    await runChromancer('click', ['button:has-text("Toggle Input Visibility")']);
    
    // Wait for visibility
    const result = await runChromancer('wait', ['--selector', '#toggle-input', '--visible']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Element is visible');
  });
  
  it('should wait for custom condition', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Start timer
    await runChromancer('click', ['#start-timer']);
    
    // Wait for timer to reach specific value
    const result = await runChromancer('wait', [
      '--condition', 'parseInt(document.getElementById("timer").textContent) >= 2'
    ]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Condition met');
    
    // Verify timer value
    const timerResult = await runChromancer('evaluate', ['document.getElementById("timer").textContent']);
    const timerValue = parseInt(timerResult.stdout);
    expect(timerValue).toBeGreaterThanOrEqual(2);
  });
  
  it('should wait for element to disappear', async () => {
    const url = getTestUrl('/click-edge.html');
    await runChromancer('navigate', [url]);
    
    // Show context menu
    await runChromancer('evaluate', [`
      const event = new MouseEvent('contextmenu', {
        bubbles: true,
        cancelable: true,
        clientX: 100,
        clientY: 100
      });
      document.getElementById('right-click-area').dispatchEvent(event);
    `]);
    
    // Verify menu is visible
    const visibleResult = await runChromancer('evaluate', [
      'window.getComputedStyle(document.getElementById("custom-context-menu")).display'
    ]);
    expect(visibleResult.stdout).toContain('block');
    
    // Click elsewhere to hide menu
    await runChromancer('click', ['body']);
    
    // Wait for menu to disappear
    const result = await runChromancer('wait', ['--selector', '#custom-context-menu', '--hidden']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Element is hidden');
  });
  
  it('should wait for page load', async () => {
    // Navigate to a page
    await runChromancer('navigate', [getTestUrl('/index.html')]);
    
    // Wait for complete page load
    const result = await runChromancer('wait', ['--page-load']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Page loaded');
  });
  
  it('should wait for network idle', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Wait for network to be idle (no pending requests)
    const result = await runChromancer('wait', ['--network-idle', '--timeout', '5000']);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('Network idle');
  });
  
  it('should support multiple wait conditions', async () => {
    const url = getTestUrl('/dynamic.html');
    await runChromancer('navigate', [url]);
    
    // Click to load content
    await runChromancer('click', ['#load-content']);
    
    // Wait for element AND custom condition
    const result = await runChromancer('wait', [
      '--selector', '#nested-btn',
      '--condition', 'document.querySelectorAll(".loaded-content").length > 0'
    ]);
    expect(result.success).toBe(true);
    expect(result.stdout).toContain('All conditions met');
  });
});
</file>

<file path=".gitignore">
# Dependencies
node_modules/

# Build output
dist/
build/

# IDE
.vscode/
.idea/
*.swp
*.swo
*~

# OS
.DS_Store
Thumbs.db

# Logs
logs/
*.log
npm-debug.log*
yarn-debug.log*
yarn-error.log*

# Runtime data
pids
*.pid
*.seed
*.pid.lock

# Testing
coverage/
.nyc_output/

# Environment
.env
.env.local
.env.*.local

# Screenshots from tests
*.png
*.jpg
*.jpeg

# Temporary files
tmp/
temp/

# oclif manifest
oclif.manifest.json
</file>

<file path=".npmignore">
# Source files
src/
*.ts
!dist/**/*.d.ts

# Config files
tsconfig.json
.eslintrc
.prettierrc

# Test files
test/
*.test.js
*.spec.js

# Development files
.vscode/
.idea/
*.log
.DS_Store

# Git files
.git/
.gitignore

# Documentation source
docs/

# Scripts
*.sh
docker-chrome-setup.sh
verify-all.sh
test-cli.sh

# Temporary files
tmp/
temp/
*.tmp

# Node modules (already excluded by npm)
node_modules/

# Build artifacts not needed
*.tsbuildinfo

# Local env files
.env
.env.local
.env.*.local

# Claude files
.claude/
CLAUDE.md
</file>

<file path="docker-chrome-setup.bat">
@echo off
echo Chrome DevTools Protocol CLI - Docker Chrome Setup
echo ==================================================
echo.
echo This script provides commands to run Chrome in Docker for testing the CLI.
echo.

echo Option 1: Run Chrome in a separate Docker container
echo docker run -d ^
echo   --name chrome-headless ^
echo   -p 9222:9222 ^
echo   --shm-size=2g ^
echo   zenika/alpine-chrome ^
echo   --no-sandbox ^
echo   --remote-debugging-host=0.0.0.0 ^
echo   --remote-debugging-port=9222 ^
echo   --headless
echo.

echo Option 2: Use local Chrome installation
echo chrome.exe --remote-debugging-port=9222 --headless=new
echo.

echo To test if Chrome is accessible:
echo curl http://localhost:9222/json/version
echo.

echo To stop the Chrome container:
echo docker stop chrome-headless ^&^& docker rm chrome-headless
</file>

<file path="docker-chrome-setup.sh">
#!/bin/bash

echo "Chrome DevTools Protocol CLI - Docker Chrome Setup"
echo "=================================================="
echo ""
echo "This script provides commands to run Chrome in Docker for testing the CLI."
echo ""

cat << 'EOF'
# Option 1: Run Chrome in a separate Docker container
docker run -d \
  --name chrome-headless \
  -p 9222:9222 \
  --shm-size=2g \
  zenika/alpine-chrome \
  --no-sandbox \
  --remote-debugging-host=0.0.0.0 \
  --remote-debugging-port=9222 \
  --headless

# Option 2: Use Puppeteer's bundled Chromium (if available)
# Modify the base.ts to use:
# this.browser = await puppeteer.launch({
#   headless: 'new',
#   args: ['--no-sandbox', '--disable-setuid-sandbox']
# });

# Option 3: Install Chromium in current container (requires root)
# apt-get update && apt-get install -y chromium
# chromium --no-sandbox --headless --remote-debugging-port=9222

# To test if Chrome is accessible:
curl http://localhost:9222/json/version

# To stop the Chrome container:
docker stop chrome-headless && docker rm chrome-headless
EOF
</file>

<file path="ENHANCED_FEATURES.md">
# Enhanced Chromancer Features

## 1. CLI IntelliSense with Interactive Command Completion

### What's New
- **Fuzzy search autocomplete** for commands in interactive mode
- **Flag completion** with visual indicators for required vs optional
- **Parameter hints** showing types and descriptions
- **Colorized output** using chalk for better readability

### How to Use
```bash
# Launch enhanced interactive mode
chromancer interactive-enhanced

# In the prompt:
# - Type any part of a command to see fuzzy matches
# - Press TAB to see all available flags for a command
# - Required flags are marked with red asterisk (*)
# - Navigate suggestions with arrow keys
```

### Benefits
- No more memorizing exact command names
- Instant visibility of available flags and their types
- Reduced typos and faster command entry
- Visual cues for required parameters

## 2. YAML Workflow Automation ("Do What I Just Said")

### What's New
- **`chromancer run`** command executes workflows from YAML files
- **Variable substitution** with `${VAR}` syntax
- **Error handling modes**: strict (default) or continue-on-error
- **Stdin support** for piping workflows

### Example Workflows

#### Basic Navigation and Screenshot
```yaml
# workflow.yml
- navigate: https://example.com
- wait: { selector: body }
- screenshot: example.png
```

Run with: `chromancer run workflow.yml`

#### Login Automation with Variables
```yaml
# login.yml
- navigate: https://github.com/login
- type:
    selector: input[name="login"]
    text: ${USERNAME}
- type:
    selector: input[name="password"]  
    text: ${PASSWORD}
- click: input[type="submit"]
```

Run with: `chromancer run login.yml --var USERNAME=john --var PASSWORD=secret`

#### Complex Scraping Workflow
```yaml
# scrape.yml
- navigate: https://news.ycombinator.com
- wait: .itemlist
- evaluate: |
    Array.from(document.querySelectorAll('.athing')).slice(0, 5).map(item => ({
      title: item.querySelector('.titleline a').textContent,
      link: item.querySelector('.titleline a').href
    }))
- scroll: bottom
- screenshot: { path: results.png, fullPage: true }
```

### Supported Commands in Workflows
- `navigate` / `goto`
- `click`
- `type`
- `wait`
- `screenshot`
- `evaluate` / `eval`
- `select`
- `hover`
- `scroll`
- `fill`
- `press`
- `reload` / `refresh`
- `back` / `forward`

### Benefits
- Reusable automation scripts
- Version control friendly
- No shell escaping issues
- Built-in error recovery options

## 3. Human-Friendly Error Messages

### What's New
- **Contextual error tips** that suggest solutions
- **Example commands** showing correct usage
- **Common mistake detection** (missing # or ., XPath usage, etc.)
- **Documentation deep links** for each command
- **Colorized error output** for better visibility

### Examples

#### Selector Errors
```bash
$ chromancer click button
‚ùå Element not found: button
üí° Tip: Did you forget to add a class (.) or ID (#) prefix?

Example:
   chromancer click ".button" # for class
   chromancer click "#button" # for ID

üìö Docs: https://chromancer.dev/docs/click#errors
```

#### Connection Errors
```bash
$ chromancer navigate https://example.com
‚ùå Cannot connect to Chrome
üí° Tip: Make sure Chrome is running with remote debugging enabled

Example:
   chromancer spawn --headless
   # Or manually: chrome --remote-debugging-port=9222

üìö Docs: https://chromancer.dev/docs/navigate#errors
```

#### Timeout Errors
```bash
$ chromancer wait --selector "#slow-element"
‚ùå Timeout waiting for element: #slow-element
üí° Tip: The element didn't appear within the timeout period

Example:
   # Increase timeout:
   chromancer wait --selector "#slow-element" --timeout 60000
   
   # Or check if element is in iframe:
   chromancer wait --selector "#slow-element" --frame 0

üìö Docs: https://chromancer.dev/docs/wait#errors
```

### Benefits
- Faster debugging with actionable suggestions
- Learn correct syntax through examples
- Avoid common pitfalls
- Direct links to relevant documentation

## Integration Example

Combining all three features for a complete automation workflow:

```bash
# 1. Use enhanced interactive mode to explore commands
chromancer interactive-enhanced

# 2. Create a workflow with proper error handling
cat > test-flow.yml << EOF
- navigate: ${URL}
- wait: 
    selector: ${SELECTOR}
    timeout: 5000
- click: button.submit  # Will show helpful error if not found
- screenshot: result.png
EOF

# 3. Run with variables and error recovery
chromancer run test-flow.yml \
  --var URL=https://example.com \
  --var SELECTOR="#content" \
  --continue-on-error
```

## Summary

These enhancements transform chromancer from a powerful but technical tool into a user-friendly automation platform:

1. **CLI IntelliSense** ‚Üí No more command memorization
2. **YAML Workflows** ‚Üí Reusable, shareable automation scripts  
3. **Smart Error Tips** ‚Üí Learn while you work

The result: Faster development, fewer errors, and a gentler learning curve for new users.
</file>

<file path="NEW_FEATURES_IMPLEMENTED.md">
# New Chromancer Features - Implementation Summary

This document summarizes the new features implemented using Test-Driven Development (TDD).

## ‚úÖ Implemented Commands

### 1. `chromancer wait`
**Purpose**: Wait for elements or conditions before proceeding

**Usage Examples**:
```bash
# Wait for element to appear
chromancer wait --selector "#dynamic-content"

# Wait for element to be visible
chromancer wait --selector "#loading" --visible

# Wait for element to disappear
chromancer wait --selector "#popup" --hidden

# Wait for custom JavaScript condition
chromancer wait --condition "document.readyState === 'complete'"

# Wait for page load
chromancer wait --page-load

# Wait for network idle
chromancer wait --network-idle

# With custom timeout
chromancer wait --selector ".ajax-result" --timeout 5000
```

**Test Coverage**: 8 test cases in `test/wait.test.js`

### 2. `chromancer hover`
**Purpose**: Hover over elements to trigger hover states, tooltips, and dropdown menus

**Usage Examples**:
```bash
# Simple hover
chromancer hover "#menu-item"

# Hover with duration
chromancer hover ".dropdown-toggle" --duration 2000

# Hover to show tooltip
chromancer hover "[data-tooltip]"
```

**Test Coverage**: 8 test cases in `test/hover.test.js`

### 3. `chromancer store`
**Purpose**: Store values from page elements or JavaScript evaluations for later use

**Usage Examples**:
```bash
# Store element text
chromancer store --selector "#price" --as "originalPrice"

# Store evaluation result
chromancer store --eval "document.title" --as "pageTitle"

# Store input value
chromancer store --selector "#username" --as "username" --property "value"

# Store attribute
chromancer store --selector "#email" --as "emailPlaceholder" --attribute "placeholder"

# List all stored values
chromancer store --list

# Clear stored values
chromancer store --clear
```

**Features**:
- Values persist across page navigations
- Stored values accessible in evaluate commands via `chromancer.stored.variableName`
- Support for complex objects and arrays

**Test Coverage**: 9 test cases in `test/store.test.js`

### 4. `chromancer assert`
**Purpose**: Built-in assertions for testing and validation

**Usage Examples**:
```bash
# Assert element exists
chromancer assert --selector "#success-message"

# Assert text content
chromancer assert --selector "h1" --contains "Welcome"
chromancer assert --selector "#status" --equals "Complete"
chromancer assert --selector "#code" --matches "^[A-Z]{3}-\\d{4}$"

# Assert element count
chromancer assert --selector ".item" --count 5

# Assert visibility
chromancer assert --selector "#modal" --visible
chromancer assert --selector "#spinner" --not-visible

# Assert input value
chromancer assert --selector "#username" --value "john_doe"

# Assert JavaScript expressions
chromancer assert --eval "document.title" --equals "My Page"
chromancer assert --eval "localStorage.getItem('token') !== null"

# Custom error messages
chromancer assert --selector "#critical-element" --message "Login form not found!"
```

**Test Coverage**: 10 test cases in `test/assert.test.js`

## üìä Implementation Stats

- **Total New Commands**: 4
- **Total Test Cases**: 35
- **Lines of Implementation Code**: ~800
- **Lines of Test Code**: ~900

## üîÑ Test-Driven Development Process

For each command:
1. **Wrote comprehensive tests first** covering success cases, edge cases, and error scenarios
2. **Implemented minimal code** to make tests pass
3. **Refactored** for better code organization and error handling
4. **Verified** all tests pass

## üéØ Key Features Achieved

1. **Dynamic Content Handling**: The `wait` command solves timing issues with AJAX and dynamically loaded content
2. **Interactive Elements**: The `hover` command enables interaction with dropdown menus and tooltips
3. **State Management**: The `store` command allows complex workflows by preserving data across commands
4. **Testing Capabilities**: The `assert` command provides built-in validation for automation scripts

## üöÄ Next Steps

The following high-priority features are ready for implementation:
1. **Command Chaining**: Allow multiple commands to be executed in sequence
2. **Double-click & Right-click**: Extended mouse interactions
3. **Drag & Drop**: Complex element interactions
4. **Browser Navigation**: `back`, `forward`, `refresh` commands

## üí° Usage Example - Complete Workflow

Here's how the new commands work together for a real-world scenario:

```bash
# Navigate to e-commerce site
chromancer navigate "https://shop.example.com"

# Wait for page to load completely
chromancer wait --page-load

# Store original price
chromancer store --selector ".price" --as "originalPrice"

# Hover to reveal discount
chromancer hover ".special-offer" --duration 1000

# Wait for discount to appear
chromancer wait --selector ".discount-price" --visible

# Store discounted price
chromancer store --selector ".discount-price" --as "discountPrice"

# Assert discount is applied
chromancer assert --eval "parseFloat(chromancer.stored.discountPrice) < parseFloat(chromancer.stored.originalPrice)"

# Click add to cart
chromancer click "#add-to-cart"

# Wait for cart update
chromancer wait --selector ".cart-count" --contains "1"

# Assert item was added
chromancer assert --selector ".cart-success" --visible
```

This demonstrates how the new commands enable complex, reliable web automation workflows!
</file>

<file path="NEW_FEATURES.md">
# New Chromancer Features

## Overview
Added 8 powerful new commands to chromancer, enhancing its capabilities for browser automation, testing, and web scraping.

## New Commands

### 1. **record** - Record user interactions
- Records clicks, typing, navigation, and form interactions
- Generates replayable scripts in JSON or JavaScript format
- Configurable recording duration
- Perfect for creating automated tests from manual interactions

Example:
```bash
chromancer record --output recording.json
chromancer record --output script.js --format js --duration 30000
```

### 2. **export** - Export page content
- Export pages as HTML, JSON, CSV, Markdown, or plain text
- Target specific elements with CSS selectors
- Download all page resources (images, scripts, styles)
- Include computed styles in HTML exports

Example:
```bash
chromancer export --format json --selector "table#data"
chromancer export --format csv --selector "table" --output data.csv
chromancer export --format markdown --output content.md
chromancer export --all-resources --output-dir ./export
```

### 3. **fill** - Automated form filling
- Fill forms with JSON data
- Auto-generate test data based on field types and names
- Support for all input types including files and checkboxes
- Optional form submission after filling

Example:
```bash
chromancer fill --data '{"username": "john", "email": "john@example.com"}'
chromancer fill --file form-data.json --submit
chromancer fill --auto-generate --selector "#login-form"
```

### 4. **scroll** - Page scrolling
- Scroll by direction, pixels, or percentage
- Scroll to specific elements
- Smooth or instant scrolling
- Support for horizontal and vertical scrolling

Example:
```bash
chromancer scroll down
chromancer scroll --to "#section3" --smooth
chromancer scroll --by 500
chromancer scroll --percent 50
```

### 5. **cookies** - Cookie management
- List, get, set, and delete cookies
- Save cookies to file for session persistence
- Load cookies from file
- Support for all cookie attributes (secure, httpOnly, sameSite)

Example:
```bash
chromancer cookies list
chromancer cookies set sessionId=abc123
chromancer cookies save --output cookies.json
chromancer cookies load --file cookies.json
chromancer cookies clear
```

### 6. **pdf** - PDF generation
- Save any page as PDF
- Multiple page formats (A4, Letter, etc.)
- Landscape/portrait orientation
- Custom margins and scaling
- Header/footer templates

Example:
```bash
chromancer pdf --output report.pdf --format A4
chromancer pdf --output doc.pdf --landscape --background
chromancer pdf --output print.pdf --margin "1in" --page-ranges "1-5"
```

### 7. **network** - Network monitoring
- Monitor all network requests and responses
- Filter by URL pattern, resource type, method, or status
- Block requests matching patterns
- Export network logs to JSON
- Real-time monitoring with statistics

Example:
```bash
chromancer network --filter "api" --type xhr
chromancer network --method POST --output api-calls.json
chromancer network --status 404 --status 500
chromancer network --block "ads" --block "analytics"
```

### 8. **wait-for-login** - Authentication helper
- Navigate to login page and wait for user to complete authentication
- Configurable ready selector to detect successful login
- Perfect for automating authenticated sessions
- Works with Chrome profiles for persistent sessions

Example:
```bash
chromancer wait-for-login https://gmail.com
chromancer wait-for-login https://github.com --ready-selector ".Header-link--profile"
chromancer wait-for-login https://app.example.com --profile work
```

## Testing

All new features include:
- Comprehensive unit tests
- Integration tests with real browser interactions
- Help text validation
- Error handling and edge cases

Run tests with:
```bash
node test/new-features.test.js
node test/integration-tests.js
```

## Benefits

These new features make chromancer a more complete browser automation tool:

1. **Testing**: Record user actions and replay them, fill forms automatically
2. **Web Scraping**: Export data in multiple formats, monitor network requests
3. **Automation**: Scroll pages, manage cookies, handle authentication
4. **Documentation**: Generate PDFs of web pages
5. **Debugging**: Monitor network traffic, block unwanted requests

All commands follow chromancer's design principles:
- Simple, intuitive CLI interface
- Composable with other commands
- Support for Chrome profiles
- Verbose logging options
- Proper error handling
</file>

<file path="PACKAGE_SUMMARY.md">
# Chromancer - Package Summary

## What's Ready

‚úÖ **Package Structure**
- Proper npm package structure with bin, dist, and src directories
- TypeScript compilation configured
- oclif CLI framework integrated

‚úÖ **Commands Implemented**
- `spawn` - Launch Chrome with automatic port management
- `stop` - Stop the active Chrome session
- `navigate` - Navigate to URLs
- `click` - Click elements by CSS selector
- `type` - Type text into elements
- `evaluate` - Execute JavaScript
- `screenshot` - Take screenshots

‚úÖ **Session Management**
- Automatic session tracking when using `spawn`
- Commands automatically use the active session
- Clean teardown with `stop` command

‚úÖ **Cross-Platform Support**
- Windows Chrome detection and process management
- macOS Chrome detection  
- Linux Chrome detection
- Platform-specific process handling

‚úÖ **Documentation**
- Comprehensive README.md with examples
- npm badges and installation instructions
- Troubleshooting section
- Publishing guide

‚úÖ **Testing**
- Unit tests for all commands
- Test suite passes

‚úÖ **npm Publishing Ready**
- package.json configured with:
  - Proper name, version, description
  - Keywords for discoverability
  - Author and license fields (need to be updated)
  - bin field for global installation
  - Repository URLs (need to be updated)
- .npmignore file to exclude unnecessary files
- LICENSE file (MIT)

## Before Publishing

‚ö†Ô∏è **Update these in package.json:**
```json
"author": "Your Name",
"repository": {
  "url": "git+https://github.com/yourusername/chromancer.git"
},
"homepage": "https://github.com/yourusername/chromancer#readme",
"bugs": {
  "url": "https://github.com/yourusername/chromancer/issues"
}
```

‚ö†Ô∏è **Update LICENSE file:**
- Replace `[Your Name]` with your actual name

‚ö†Ô∏è **Update README.md:**
- Replace `[Your Name]` in the license section
- Update repository URLs if different

## Quick Publish Steps

1. Update the fields mentioned above
2. Login to npm: `npm login`
3. Publish: `npm publish --access public`
4. Verify: `npm install -g chromancer && chromancer --version`

## Package Contents

The npm package includes:
- Compiled JavaScript in dist/
- TypeScript definitions (.d.ts files)
- bin/run.js for CLI execution
- README.md and LICENSE
- No source files or test files

Total package size: ~10KB (very lightweight!)
</file>

<file path="PROPOSED_FEATURES.md">
# Proposed Chromancer Features

Based on comprehensive edge case testing, here are proposed new commands and features to enhance Chromancer's capabilities:

## 1. New Commands

### `chromancer wait`
Wait for specific conditions before proceeding.
```bash
# Wait for element to appear
chromancer wait --selector "#dynamic-content"

# Wait for element to be visible
chromancer wait --selector "#loading" --visible

# Wait for custom condition
chromancer wait --condition "document.readyState === 'complete'"

# Wait with timeout
chromancer wait --selector ".ajax-result" --timeout 5000
```

### `chromancer hover`
Trigger hover states and mouse-over events.
```bash
# Hover over element
chromancer hover "#menu-item"

# Hover and wait
chromancer hover ".tooltip-trigger" --duration 1000
```

### `chromancer double-click`
Native double-click support.
```bash
chromancer double-click "#editable-cell"
```

### `chromancer right-click`
Context menu interaction.
```bash
chromancer right-click "#context-target"
```

### `chromancer drag`
Drag and drop operations.
```bash
# Drag from source to target
chromancer drag "#draggable" --to "#drop-zone"

# Drag by offset
chromancer drag "#slider-handle" --offset "100,0"
```

### `chromancer back` / `chromancer forward`
Browser navigation controls.
```bash
chromancer back
chromancer forward
chromancer refresh
```

### `chromancer store`
Store values for later use (selector caching).
```bash
# Store element text
chromancer store --selector "#price" --as "originalPrice"

# Store evaluation result
chromancer store --eval "document.title" --as "pageTitle"

# Use stored values
chromancer evaluate "localStorage.getItem('${originalPrice}')"
```

### `chromancer assert`
Built-in assertions for testing.
```bash
# Assert element exists
chromancer assert --selector "#success-message"

# Assert text content
chromancer assert --selector "h1" --contains "Welcome"

# Assert value
chromancer assert --selector "#total" --equals "100"

# Assert evaluation
chromancer assert --eval "window.location.pathname" --equals "/checkout"
```

### `chromancer fill-form`
Intelligent form filling.
```bash
# Auto-detect and fill form fields
chromancer fill-form --data '{"name": "John", "email": "john@example.com"}'

# Fill specific form
chromancer fill-form --selector "#checkout-form" --data form.json
```

### `chromancer workflow`
Execute saved workflow files.
```bash
# Run workflow from file
chromancer workflow checkout.yaml

# Example workflow file:
# - navigate: https://shop.example.com
# - click: .product:first
# - click: #add-to-cart
# - navigate: /checkout
# - fill-form:
#     data:
#       email: test@example.com
# - click: #place-order
```

## 2. Command Chaining

### Pipe-based Chaining
Allow commands to be piped together:
```bash
# Navigate, wait, then click
chromancer navigate https://example.com | \
chromancer wait --selector "#cookie-banner" | \
chromancer click "#accept-cookies"

# Complex workflow
chromancer navigate https://shop.com | \
chromancer type "#search" "laptop" | \
chromancer click "#search-button" | \
chromancer wait --selector ".results" | \
chromancer click ".product:first" | \
chromancer screenshot product.png
```

### `--then` Flag
Chain commands within a single call:
```bash
chromancer navigate https://example.com \
  --then click "#login" \
  --then type "#username" "user@example.com" \
  --then type "#password" "pass123" \
  --then click "#submit"
```

### Script Mode
Execute multiple commands from a script:
```bash
# chromancer-script.sh
chromancer script <<EOF
navigate https://example.com
wait --selector "#content"
click "#start-demo"
type "#email" "demo@example.com"
click "#submit"
wait --selector "#success"
screenshot demo-complete.png
EOF
```

## 3. Enhanced Selectors

### Pseudo-selectors
```bash
# Click element containing text
chromancer click ":contains('Add to Cart')"

# Click visible element only
chromancer click ".button:visible"

# Click by index
chromancer click ".item:nth(2)"
```

### XPath Support
```bash
chromancer click --xpath "//button[contains(text(), 'Submit')]"
```

### Multiple Selector Strategies
```bash
# Try multiple selectors until one works
chromancer click --any "#submit-btn, button[type=submit], .submit"
```

## 4. Enhanced Features

### Parallel Execution
```bash
# Run commands in parallel windows/tabs
chromancer parallel <<EOF
window1: navigate https://example.com/page1
window2: navigate https://example.com/page2
EOF
```

### Conditional Logic
```bash
# If element exists, click it
chromancer if --selector "#popup" --then click "#close-popup"

# If condition is true, execute command
chromancer if --eval "document.cookie.includes('logged_in')" \
  --then navigate "/dashboard" \
  --else navigate "/login"
```

### Loops
```bash
# Click all matching elements
chromancer foreach ".item" click

# Repeat action
chromancer repeat 5 click "#load-more"
```

### Variables and Templates
```bash
# Set variables
chromancer set baseUrl "https://example.com"
chromancer set username "testuser"

# Use variables
chromancer navigate "${baseUrl}/login"
chromancer type "#username" "${username}"
```

## 5. Better Error Handling

### Retry Mechanism
```bash
# Retry failed commands
chromancer click "#dynamic-button" --retry 3 --retry-delay 1000
```

### Soft Failures
```bash
# Continue on error
chromancer click "#optional-popup-close" --continue-on-error
```

### Error Context
```bash
# Save screenshot on error
chromancer click "#button" --on-error screenshot error.png
```

## 6. Session Management

### Save/Restore State
```bash
# Save current state
chromancer session save --name "logged-in"

# Restore state
chromancer session restore --name "logged-in"

# List sessions
chromancer session list
```

### Cookie Management
```bash
# Save cookies
chromancer cookies save --file cookies.json

# Load cookies
chromancer cookies load --file cookies.json

# Clear cookies
chromancer cookies clear --domain example.com
```

## 7. Advanced Interactions

### Keyboard Shortcuts
```bash
# Send keyboard shortcuts
chromancer keyboard "Ctrl+A"
chromancer keyboard "Cmd+S"
chromancer keyboard "Escape"
```

### Mouse Actions
```bash
# Mouse movement
chromancer mouse move --to "#target"
chromancer mouse move --by "100,100"

# Mouse wheel
chromancer scroll --by "0,500"
chromancer scroll --to "#section"
```

### Focus Management
```bash
# Focus element
chromancer focus "#input"

# Tab through elements
chromancer keyboard "Tab"
```

## Implementation Priority

### High Priority (Gap Fillers)
1. `wait` - Critical for dynamic content
2. `hover` - Common interaction pattern
3. `store` - Enable complex workflows
4. Command chaining - Improve workflow efficiency
5. `assert` - Built-in testing capability

### Medium Priority (Enhancements)
1. `double-click` / `right-click` - Extended interactions
2. `back` / `forward` - Navigation control
3. `fill-form` - Common use case optimization
4. Better selectors - Improved element targeting
5. Retry mechanism - Reliability

### Low Priority (Advanced)
1. `workflow` files - Complex automation
2. Parallel execution - Advanced use cases
3. Conditional logic - Programming constructs
4. Session management - Stateful operations

## Conclusion

These proposed features address the gaps identified during edge case testing:
- **Dynamic content handling** (wait, retry)
- **Complex interactions** (hover, drag, keyboard)
- **Workflow automation** (chaining, scripts, workflows)
- **Reliability** (better selectors, error handling)
- **Testing capabilities** (assertions, conditionals)

The command chaining mechanism would be particularly powerful, allowing users to create complex automation flows without writing full programs.
</file>

<file path="PUBLISHING.md">
# Publishing Chromancer to npm

## Pre-publish Checklist

- [ ] Update version in package.json
- [ ] Update author name in package.json
- [ ] Update repository URLs in package.json
- [ ] Update author name in LICENSE file
- [ ] Run tests: `npm test`
- [ ] Build the project: `npm run build`
- [ ] Test locally: `npm link` then `chromancer --help`

## First-time Setup

1. Create an npm account at https://www.npmjs.com/signup
2. Login to npm:
   ```bash
   npm login
   ```

## Publishing

1. Clean and build:
   ```bash
   npm run clean
   npm run build
   ```

2. Test the package:
   ```bash
   npm pack --dry-run
   ```

3. Publish to npm:
   ```bash
   npm publish
   ```

   For the first publish, you might need:
   ```bash
   npm publish --access public
   ```

## Post-publish

1. Verify on npm: https://www.npmjs.com/package/chromancer
2. Test installation:
   ```bash
   npm install -g chromancer
   chromancer --version
   ```

## Version Updates

For subsequent releases:

1. Update version:
   ```bash
   npm version patch  # for bug fixes
   npm version minor  # for new features
   npm version major  # for breaking changes
   ```

2. Push tags:
   ```bash
   git push --tags
   ```

3. Publish:
   ```bash
   npm publish
   ```
</file>

<file path="REFACTORING_SUMMARY.md">
# Refactoring Summary - Extracted Common Utilities

## Overview

Successfully extracted common patterns from Chromancer commands into reusable utility modules, following Test-Driven Development practices.

## Extracted Utilities

### 1. **`src/utils/selectors.ts`**
Common element selection and waiting logic.

**Functions:**
- `waitForElement()` - Unified element waiting with timeout handling
- `isElementVisible()` - Check element visibility consistently
- `getElementInfo()` - Get comprehensive element information

**Benefits:**
- Consistent timeout handling across commands
- Standardized element visibility checks
- Reduced code duplication in element operations

### 2. **`src/utils/errors.ts`**
Standardized error handling and formatting.

**Functions:**
- `isTimeoutError()` - Identify timeout errors reliably
- `formatErrorMessage()` - Consistent error message formatting
- `handleCommandError()` - Create structured command errors

**Benefits:**
- Consistent error messages across all commands
- Better timeout error detection
- Preserved stack traces for debugging

### 3. **`src/utils/evaluation.ts`**
Safe JavaScript evaluation helpers.

**Functions:**
- `safeEvaluate()` - Evaluate with error handling
- `evaluateElementProperty()` - Get single element property
- `evaluateElementProperties()` - Get multiple properties efficiently

**Benefits:**
- Centralized evaluation error handling
- Type-safe property access
- Batch property retrieval

## Commands Updated

### Refactored Commands:
1. **Click** - Now uses `waitForElement()` and `handleCommandError()`
2. **Hover** - Uses unified utilities for element waiting
3. **Wait** - Leverages common error handling

### Improvements:
- ‚úÖ Consistent error messages with better context
- ‚úÖ Unified timeout handling
- ‚úÖ Standardized success indicators (‚úÖ emoji)
- ‚úÖ Better error categorization (timeout vs other errors)

## Test Coverage

### Utility Tests Created:
- `test/utils/selectors.test.js` - 11 test cases
- `test/utils/errors.test.js` - 9 test cases  
- `test/utils/evaluation.test.js` - 8 test cases

**Total:** 28 new test cases for utilities

### Test Results:
- ‚úÖ All existing tests still pass
- ‚úÖ New utility tests provide comprehensive coverage
- ‚úÖ No breaking changes to command APIs

## Code Quality Improvements

### Before:
```typescript
// Repeated in multiple commands
try {
  await this.page.waitForSelector(selector, { timeout })
} catch (error) {
  this.error(`Failed to click: ${error}`)
}
```

### After:
```typescript
// Centralized and consistent
try {
  await waitForElement(this.page, selector, { timeout })
} catch (error) {
  const commandError = handleCommandError(error, 'click', selector)
  this.error(commandError.message)
}
```

## Key Benefits

1. **Maintainability**: Changes to common logic only need updates in one place
2. **Consistency**: All commands now handle errors and timeouts the same way
3. **Testability**: Utilities can be tested in isolation
4. **Type Safety**: Added DOM types to TypeScript config for better support
5. **Future-Proof**: New commands can easily use these utilities

## Next Steps

Additional utilities that could be extracted:
- Common flag definitions
- Logging utilities with consistent formatting
- Navigation event handling
- Best selector generation (from select.ts)

## Summary

Successfully refactored Chromancer to use common utilities while:
- Maintaining 100% backward compatibility
- Improving error handling consistency
- Adding comprehensive test coverage
- Following TDD principles throughout

The codebase is now more maintainable and consistent, making it easier to add new features and fix bugs.
</file>

<file path="run-chromancer-tests.sh">
#!/bin/bash

echo "üß™ Chromancer Test Suite Runner"
echo "================================"
echo ""

# Check if Chrome is available
if ! command -v chromium &> /dev/null && ! command -v google-chrome &> /dev/null && ! command -v chrome &> /dev/null; then
    echo "‚ö†Ô∏è  Chrome/Chromium not found!"
    echo ""
    echo "Please install Chrome or Chromium first:"
    echo "  - macOS: brew install --cask google-chrome"
    echo "  - Ubuntu: sudo apt-get install chromium-browser"
    echo "  - Or use Docker: docker run -d -p 9222:9222 zenika/alpine-chrome --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222"
    echo ""
    exit 1
fi

# Build the project
echo "üì¶ Building project..."
npm run build
if [ $? -ne 0 ]; then
    echo "‚ùå Build failed!"
    exit 1
fi

echo ""
echo "‚úÖ Build successful!"
echo ""

# Check if Chrome is already running on port 9222
if lsof -Pi :9222 -sTCP:LISTEN -t >/dev/null ; then
    echo "üåê Chrome already running on port 9222"
else
    echo "üöÄ Starting Chrome with remote debugging..."
    node ./bin/run.js spawn --headless &
    CHROME_PID=$!
    echo "Chrome PID: $CHROME_PID"
    
    # Wait for Chrome to start
    echo "‚è≥ Waiting for Chrome to be ready..."
    sleep 3
fi

echo ""
echo "üß™ Running Vitest tests..."
echo ""

# Run the tests
npx vitest run

TEST_EXIT_CODE=$?

# Kill Chrome if we started it
if [ ! -z "$CHROME_PID" ]; then
    echo ""
    echo "üõë Stopping Chrome..."
    kill $CHROME_PID 2>/dev/null
fi

echo ""
if [ $TEST_EXIT_CODE -eq 0 ]; then
    echo "‚úÖ All tests passed!"
else
    echo "‚ùå Some tests failed!"
fi

exit $TEST_EXIT_CODE
</file>

<file path="TEST_SUMMARY.md">
# Test Summary for Enhanced Chromancer Features

## Overview
Comprehensive tests have been created and run for all new features added to chromancer.

## Test Results

### ‚úÖ Working Features

1. **YAML Workflow Execution (`run` command)**
   - Command structure and help text
   - YAML parsing and validation
   - Variable substitution with `${VAR}` syntax
   - Dry-run mode for testing
   - Error handling (strict vs continue-on-error)
   - Example workflows all validate correctly

2. **Enhanced Error Messages**
   - Error tips system is implemented
   - Pattern detection for common mistakes
   - Colorized output using ANSI codes
   - Documentation links generated
   - Context-aware suggestions

3. **New Automation Commands** (8 total)
   - `record` - Record user interactions
   - `export` - Export page content in multiple formats
   - `fill` - Smart form filling
   - `scroll` - Advanced scrolling
   - `cookies` - Cookie management
   - `pdf` - PDF generation
   - `network` - Network monitoring
   - `run` - YAML workflow execution

4. **Example Workflows**
   - `login-workflow.yml` - Authentication automation
   - `scraping-workflow.yml` - Web scraping example
   - `form-automation.yml` - Form filling example

### ‚ö†Ô∏è Known Limitations

1. **CLI IntelliSense (interactive-enhanced)**
   - Requires ES module support in oclif
   - `inquirer-autocomplete-prompt` is an ES module
   - Command registry needs ES module updates
   - Core functionality implemented but needs module system updates

2. **Minor Issues**
   - Stdin input for workflows needs process.stdin handling fix
   - Some error pattern tests need adjustment

## Test Files Created

### Unit Tests
- `test/test-cli-intellisense.js` - Tests command registry and schema extraction
- `test/test-yaml-workflows.js` - Tests YAML parsing, variables, and workflow execution
- `test/test-error-tips-unit.js` - Tests error pattern matching and formatting
- `test/test-working-features.js` - Simplified integration tests

### Integration Tests
- `test/test-enhanced-features.js` - Master test runner
- `test/test-error-tips.js` - Error message demonstration

## Running Tests

```bash
# Build the project
npm run build

# Run all tests
node test/test-enhanced-features.js

# Run simplified working features test
node test/test-working-features.js

# Run specific test suites
node test/test-yaml-workflows.js
node test/test-error-tips-unit.js
```

## Recommendations

1. **For CLI IntelliSense**: Consider migrating to ES modules or using dynamic imports for the autocomplete functionality
2. **For Error Tips**: The system is working but could be enhanced with actual chalk module when ES module support is added
3. **For Workflows**: Consider adding more complex workflow examples and validation

## Summary

The three major enhancements are successfully implemented and tested:

1. ‚úÖ **YAML Workflows** - Fully functional with variables and error handling
2. ‚úÖ **Smart Error Tips** - Working with helpful suggestions and formatting
3. ‚ö†Ô∏è **CLI IntelliSense** - Core implemented, needs ES module support

Additionally, 8 new powerful commands have been added and tested, significantly expanding chromancer's capabilities.
</file>

<file path="test-cli.bat">
@echo off
echo Chrome DevTools Protocol CLI Test Script
echo ========================================
echo.
echo Before running this script, make sure Chrome is running with:
echo chrome.exe --remote-debugging-port=9222 --headless=new
echo.
echo Press any key to continue...
pause > nul

REM Test navigate command
echo 1. Testing navigate command...
node ./bin/run.js navigate https://example.com
echo.

REM Test screenshot command
echo 2. Testing screenshot command...
node ./bin/run.js screenshot example-screenshot.png
echo.

REM Test evaluate command
echo 3. Testing evaluate command (get page title)...
node ./bin/run.js evaluate "document.title"
echo.

REM Test evaluate command (count links)
echo 4. Testing evaluate command (count links)...
node ./bin/run.js evaluate "document.querySelectorAll('a').length"
echo.

REM Test click command
echo 5. Testing click command (will try to click first link)...
node ./bin/run.js click "a" || echo No clickable links found
echo.

REM Test type command
echo 6. Testing type command (if there's an input field)...
node ./bin/run.js type "input" "test text" || echo No input fields found
echo.

echo Test completed!
</file>

<file path="TESTING.md">
# Chromancer Testing Documentation

## Overview

This document provides a comprehensive review of the Vitest-based testing framework implemented for Chromancer, a CLI tool for Chrome automation using the DevTools Protocol.

## Testing Architecture

### Framework Choice: Vitest

We selected **Vitest** for the following reasons:
- **Fast execution** with native ESM support
- **Jest-compatible API** for familiar testing patterns
- **Built-in TypeScript support** matching our codebase
- **Excellent error reporting** and debugging capabilities
- **Watch mode** for development efficiency

### Test Structure

```
test/
‚îú‚îÄ‚îÄ fixtures/               # Mock HTML pages
‚îÇ   ‚îú‚îÄ‚îÄ index.html         # Main navigation page
‚îÇ   ‚îú‚îÄ‚îÄ form.html          # Form input scenarios
‚îÇ   ‚îú‚îÄ‚îÄ buttons.html       # Click interaction scenarios
‚îÇ   ‚îú‚îÄ‚îÄ dynamic.html       # Dynamic content scenarios
‚îÇ   ‚îî‚îÄ‚îÄ selects.html       # Select dropdown scenarios
‚îú‚îÄ‚îÄ navigate.test.js       # Navigation command tests
‚îú‚îÄ‚îÄ click.test.js          # Click command tests
‚îú‚îÄ‚îÄ type.test.js           # Type command tests
‚îú‚îÄ‚îÄ evaluate.test.js       # Evaluate command tests
‚îú‚îÄ‚îÄ screenshot.test.js     # Screenshot command tests
‚îú‚îÄ‚îÄ select.test.js         # Select command tests
‚îú‚îÄ‚îÄ interactive.test.js    # Interactive mode tests
‚îú‚îÄ‚îÄ chromancer.test.js     # General CLI tests
‚îú‚îÄ‚îÄ test-utils.js          # Shared test utilities
‚îú‚îÄ‚îÄ test-server.js         # Express server for fixtures
‚îú‚îÄ‚îÄ setup.js               # Global test setup/teardown
‚îî‚îÄ‚îÄ README.md             # Test documentation
```

## Test Coverage Analysis

### 1. Navigation Tests (`navigate.test.js`)
**Scenarios Covered:**
- ‚úÖ Basic URL navigation
- ‚úÖ Sequential page navigation
- ‚úÖ 404 page handling
- ‚úÖ Page state preservation after navigation

**Key Test:**
```javascript
it('should preserve page state after navigation', async () => {
  const url = getTestUrl('/buttons.html');
  const navResult = await runChromancer('navigate', [url]);
  expect(navResult.success).toBe(true);
  
  const evalResult = await runChromancer('evaluate', ['document.title']);
  expect(evalResult.stdout).toContain('Button Test Page');
});
```

### 2. Click Interaction Tests (`click.test.js`)
**Scenarios Covered:**
- ‚úÖ Click elements by ID/selector
- ‚úÖ Multiple sequential clicks
- ‚úÖ Link navigation via clicks
- ‚úÖ Toggle element visibility
- ‚úÖ Disabled button handling
- ‚úÖ Non-existent element errors

**Notable Feature:** Tests verify both the click action and its side effects (e.g., counter increments, visibility changes).

### 3. Form Input Tests (`type.test.js`)
**Scenarios Covered:**
- ‚úÖ Basic text input
- ‚úÖ Different input types (text, email, password)
- ‚úÖ Textarea with multiline content
- ‚úÖ Clear existing text with `--clear` flag
- ‚úÖ Special character handling
- ‚úÖ Error handling for missing elements

**Edge Case Handling:**
```javascript
it('should handle special characters', async () => {
  const specialText = 'Test@123!#$%';
  await runChromancer('type', ['#username', specialText]);
  
  const valueResult = await runChromancer('evaluate', ['document.getElementById("username").value']);
  expect(valueResult.stdout).toContain(specialText);
});
```

### 4. JavaScript Evaluation Tests (`evaluate.test.js`)
**Scenarios Covered:**
- ‚úÖ Simple expressions (math, strings)
- ‚úÖ DOM element access
- ‚úÖ Complex array/object operations
- ‚úÖ Async operations with `--async` flag
- ‚úÖ Different return types (boolean, number, object)
- ‚úÖ Error handling (syntax, reference errors)
- ‚úÖ State-dependent evaluations

**Advanced Test Example:**
```javascript
it('should handle async expressions with --async flag', async () => {
  const asyncExpression = 'await new Promise(r => setTimeout(r, 100)); document.querySelectorAll("li").length';
  const result = await runChromancer('evaluate', [asyncExpression, '--async']);
  expect(result.success).toBe(true);
});
```

### 5. Screenshot Tests (`screenshot.test.js`)
**Scenarios Covered:**
- ‚úÖ Default filename generation
- ‚úÖ Custom filename/path
- ‚úÖ Full page screenshots (`--fullpage`)
- ‚úÖ Element-specific screenshots (`--selector`)
- ‚úÖ Different formats (PNG, JPEG)
- ‚úÖ Directory creation
- ‚úÖ File verification

**Unique Approach:** Tests verify both file creation and file properties (existence, size > 0).

### 6. Select Dropdown Tests (`select.test.js`)
**Scenarios Covered:**
- ‚úÖ Select by value
- ‚úÖ Select by visible text
- ‚úÖ Multiple selections
- ‚úÖ Grouped options (optgroup)
- ‚úÖ Change event triggering
- ‚úÖ Empty/clear selections
- ‚úÖ Error handling

### 7. Interactive Mode Tests (`interactive.test.js`)
**Scenarios Covered:**
- ‚úÖ Interactive element discovery
- ‚úÖ Form element identification
- ‚úÖ Button state detection
- ‚úÖ Dynamic content handling

**Note:** Since interactive mode requires user input, tests focus on the underlying element discovery logic.

## Test Infrastructure

### 1. Test Server (`test-server.js`)
- Express-based static file server
- Serves mock HTML pages from `fixtures/`
- Provides consistent test environment
- Health check endpoint for verification

### 2. Test Utilities (`test-utils.js`)
- `runChromancer()`: Executes CLI commands and captures output
- `getTestUrl()`: Generates test URLs
- `waitForElement()`: Polling utility for dynamic content
- Consistent error handling and result formatting

### 3. Global Setup (`setup.js`)
- Builds TypeScript project before tests
- Manages Chrome lifecycle (start/stop)
- Cleans up orphaned processes
- Implements retry logic for Chrome readiness

### 4. Configuration (`vitest.config.js`)
- 30-second timeouts for async operations
- Single fork mode for consistent Chrome connection
- Verbose reporting for debugging
- Global setup/teardown hooks

## Running the Tests

### Quick Start
```bash
# Automated test runner (recommended)
./run-chromancer-tests.sh
```

### Manual Options
```bash
# Run all tests once
npm run test:vitest:run

# Watch mode for development
npm run test:vitest

# UI mode for debugging
npm run test:vitest:ui
```

### Prerequisites
1. Chrome/Chromium installed
2. Node.js 18+
3. Built project (`npm run build`)

## Test Design Principles

### 1. **Isolation**
Each test file can run independently with its own setup/teardown.

### 2. **Real-World Scenarios**
Mock pages simulate actual web applications with forms, dynamic content, and interactive elements.

### 3. **Comprehensive Error Testing**
Every command includes tests for error conditions (missing elements, invalid inputs).

### 4. **Output Verification**
Tests verify both command success and actual DOM state changes.

### 5. **Cross-Command Integration**
Tests often combine multiple commands (navigate ‚Üí click ‚Üí evaluate) to verify real workflows.

## Performance Considerations

### Optimizations Implemented:
1. **Shared Chrome Instance**: Single Chrome process for all tests
2. **Parallel Test Execution**: Where possible within Vitest
3. **Efficient Waiting**: Smart polling instead of fixed delays
4. **Minimal Server Overhead**: Lightweight Express server

### Test Execution Time:
- Full suite: ~30-45 seconds
- Individual test files: 3-5 seconds
- Fast feedback loop for development

## Coverage Gaps & Future Improvements

### Current Limitations:
1. **Interactive Mode**: Limited testing due to user input requirements
2. **REPL Mode**: Not tested (requires interactive session)
3. **Sessions Command**: Basic testing only
4. **Network Conditions**: No slow network simulation
5. **Browser Compatibility**: Tests assume Chromium-based browsers

### Recommended Additions:
1. **E2E Workflow Tests**: Complete user journeys
2. **Performance Benchmarks**: Command execution timing
3. **Memory Leak Detection**: Long-running session tests
4. **Concurrent Session Tests**: Multiple browser instances
5. **Authentication Scenarios**: Login/logout workflows

## Maintenance Guidelines

### Adding New Tests:
1. Create fixtures in `test/fixtures/` if needed
2. Follow naming convention: `command.test.js`
3. Use existing utilities from `test-utils.js`
4. Include both success and error scenarios
5. Document complex test logic

### Debugging Failed Tests:
1. Run specific test: `npx vitest click.test.js`
2. Use `--reporter=verbose` for detailed output
3. Check Chrome process on port 9222
4. Verify fixture files are served correctly
5. Enable Chrome non-headless mode for visual debugging

## Conclusion

The Vitest testing suite provides comprehensive coverage of Chromancer's core functionality. The combination of:
- **Realistic test scenarios** via mock HTML pages
- **Thorough command coverage** including edge cases
- **Robust infrastructure** for reliable test execution
- **Clear documentation** for maintenance

...ensures that Chromancer can be developed and maintained with confidence. The test suite serves as both a safety net for changes and living documentation of expected behavior.

### Test Statistics:
- **Total Test Files**: 8
- **Total Test Cases**: 57
- **Commands Covered**: 7/10 (70%)
- **Lines of Test Code**: ~1,200
- **Mock HTML Pages**: 5

The testing framework successfully validates Chromancer's ability to automate browser interactions from the command line, providing developers and users confidence in the tool's reliability.
</file>

<file path="verify-all.bat">
@echo off
echo Chrome DevTools Protocol CLI - Complete Verification
echo ===================================================
echo.

REM Run all tests
echo Running Unit Tests...
node test/unit-tests.js
echo.

echo Running Regression Tests...
node test/regression-tests.js
echo.

echo Checking CLI Help...
node ./bin/run.js --help
echo.

echo Build Information:
echo Node version:
node --version
echo NPM version:
npm --version

REM Count TypeScript compiled files
for /f %%A in ('dir /s /b dist\*.js ^| find /c /v ""') do set JS_COUNT=%%A
echo TypeScript files compiled: %JS_COUNT%
echo.

echo [SUCCESS] All verifications complete!
echo.
echo To run with Chrome:
echo 1. Start Chrome: chrome.exe --remote-debugging-port=9222 --headless
echo 2. Run commands: node ./bin/run.js navigate https://example.com
echo.
echo Or use --launch flag to auto-start Chrome (if installed):
echo    node ./bin/run.js navigate https://example.com --launch
</file>

<file path="vitest.config.js">
import { defineConfig } from 'vitest/config';

export default defineConfig({
  test: {
    globals: true,
    environment: 'node',
    testTimeout: 30000,
    hookTimeout: 30000,
    globalSetup: './test/setup.js',
    include: ['test/**/*.test.js'],
    reporters: ['verbose'],
    pool: 'forks',
    poolOptions: {
      forks: {
        singleFork: true
      }
    }
  }
});
</file>

<file path=".github/workflows/README.md">
# GitHub Actions Workflows

This project uses GitHub Actions for automated releases and npm publishing based on conventional commits.

## Automated Release and Publish

### Release and Publish (`release.yml`)

**Trigger**: Every push to the `main` branch

**Purpose**: Automatically determines version, creates release, and publishes to npm

**What it does**:
1. Analyzes commit messages to determine version bump
2. Updates package.json version (in memory only, no commit)
3. Creates a git tag
4. Creates a GitHub release with release notes
5. Publishes to npm

## Commit Message Convention

This project follows [Conventional Commits](https://www.conventionalcommits.org/):

- `feat:` New feature ‚Üí Minor version bump (1.0.0 ‚Üí 1.1.0)
- `fix:` Bug fix ‚Üí Patch version bump (1.0.0 ‚Üí 1.0.1)
- `perf:` Performance improvement ‚Üí Patch version bump
- `BREAKING CHANGE:` or `feat!:` ‚Üí Major version bump (1.0.0 ‚Üí 2.0.0)
- `docs:`, `style:`, `refactor:`, `test:`, `chore:` ‚Üí No release

### Examples:
```bash
# Minor release (1.0.0 ‚Üí 1.1.0)
git commit -m "feat: add new command for listing sessions"

# Patch release (1.0.0 ‚Üí 1.0.1)
git commit -m "fix: correct port detection on Windows"

# Major release (1.0.0 ‚Üí 2.0.0)
git commit -m "feat!: change CLI argument structure"
# or
git commit -m "feat: new API

BREAKING CHANGE: removed support for Node 16"

# No release
git commit -m "docs: update README"
git commit -m "chore: update dependencies"
```

## Setup Required

‚úÖ **NPM_TOKEN** is already configured in repository secrets

## How It Works

1. Push commits to main with conventional commit messages
2. GitHub Actions automatically:
   - Determines the next version based on commits
   - Creates a tag (e.g., v1.0.1)
   - Generates release notes from commit messages
   - Creates a GitHub release
   - Publishes to npm

**No commits are created** - the version is only updated in the published npm package, not in the repository.
</file>

<file path="src/commands/assert.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { safeEvaluate } from '../utils/evaluation.js'
import Store from './store.js'

export default class Assert extends BaseCommand {
  static description = 'Assert conditions about page elements or JavaScript expressions'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#success-message"',
    '<%= config.bin %> <%= command.id %> --selector "h1" --contains "Welcome"',
    '<%= config.bin %> <%= command.id %> --eval "document.title" --equals "My Page"',
    '<%= config.bin %> <%= command.id %> --selector ".items" --count 5',
    '<%= config.bin %> <%= command.id %> --eval "window.location.pathname" --equals "/checkout"',
    '<%= config.bin %> <%= command.id %> --stored "originalPrice" --equals "99.99"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to assert on',
      exclusive: ['eval', 'stored'],
    }),
    eval: Flags.string({
      char: 'e',
      description: 'JavaScript expression to evaluate and assert',
      exclusive: ['selector', 'stored'],
    }),
    stored: Flags.string({
      description: 'Assert on a previously stored value',
      exclusive: ['selector', 'eval'],
    }),
    contains: Flags.string({
      description: 'Assert element text contains this value',
      exclusive: ['equals', 'matches', 'greater-than', 'less-than'],
    }),
    equals: Flags.string({
      description: 'Assert element text or evaluation result equals this value',
      exclusive: ['contains', 'matches', 'greater-than', 'less-than'],
    }),
    matches: Flags.string({
      description: 'Assert element text matches this regex pattern',
      exclusive: ['contains', 'equals', 'greater-than', 'less-than'],
    }),
    'greater-than': Flags.string({
      description: 'Assert numeric value is greater than this',
      exclusive: ['contains', 'equals', 'matches', 'less-than'],
    }),
    'less-than': Flags.string({
      description: 'Assert numeric value is less than this',
      exclusive: ['contains', 'equals', 'matches', 'greater-than'],
    }),
    count: Flags.string({
      description: 'Assert number of elements matching selector',
      dependsOn: ['selector'],
      exclusive: ['contains', 'equals', 'matches', 'visible', 'not-visible', 'value', 'greater-than', 'less-than'],
    }),
    visible: Flags.boolean({
      description: 'Assert element is visible',
      dependsOn: ['selector'],
      exclusive: ['not-visible', 'count'],
    }),
    'not-visible': Flags.boolean({
      description: 'Assert element is not visible',
      dependsOn: ['selector'],
      exclusive: ['visible', 'count'],
    }),
    value: Flags.string({
      description: 'Assert input element value',
      dependsOn: ['selector'],
      exclusive: ['contains', 'equals', 'matches', 'count'],
    }),
    message: Flags.string({
      char: 'm',
      description: 'Custom error message if assertion fails',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Assert)
    
    // For stored value assertions, we may not need Chrome connection
    if (flags.stored && !flags.eval && !flags.selector) {
      await this.assertStoredValue(flags)
      return
    }
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, flags)
  }

  private async executeCommand(page: Page, flags: any): Promise<void> {
    try {
      if (flags.selector) {
        await this.assertSelector(page, flags)
      } else if (flags.eval) {
        await this.assertEvaluation(page, flags)
      } else if (flags.stored) {
        await this.assertStoredValue(flags)
      } else {
        this.error('Either --selector, --eval, or --stored must be specified')
      }
    } catch (error: any) {
      const message = flags.message || error.message
      this.error(`‚ùå Assertion failed: ${message}`)
    }
  }

  private async assertSelector(page: Page, flags: any): Promise<void> {
    const selector = flags.selector
    
    // Check if element exists
    const count = await page.locator(selector).count()
    
    if (count === 0 && !flags['not-visible']) {
      throw new Error(`Element not found: ${selector}`)
    }
    
    // Handle count assertion
    if (flags.count !== undefined) {
      const expectedCount = parseInt(flags.count)
      if (count !== expectedCount) {
        throw new Error(`Expected ${expectedCount} elements, found ${count}`)
      }
      this.log(`‚úÖ Assertion passed: Element count equals ${expectedCount}`)
      return
    }
    
    // Handle visibility assertions
    if (flags.visible || flags['not-visible']) {
      const locator = page.locator(selector).first()
      const isVisible = count > 0 && await locator.isVisible()
      
      if (flags.visible && !isVisible) {
        throw new Error(`Element is not visible: ${selector}`)
      }
      if (flags['not-visible'] && isVisible) {
        throw new Error(`Element is visible: ${selector}`)
      }
      
      this.log(`‚úÖ Assertion passed: Element is ${flags.visible ? 'visible' : 'not visible'}`)
      return
    }
    
    // Get element content for text assertions
    const element = page.locator(selector).first()
    let content: string
    
    if (flags.value !== undefined) {
      // Get input value
      content = await element.inputValue() || ''
      
      if (content !== flags.value) {
        throw new Error(`Input value "${content}" does not equal "${flags.value}"`)
      }
      this.log(`‚úÖ Assertion passed: Input value equals "${flags.value}"`)
      return
    } else {
      // Get text content
      content = await element.textContent() || ''
      content = content.trim()
    }
    
    // Handle text assertions
    this.assertContent(content, flags, `Element text`)
  }

  private async assertEvaluation(page: Page, flags: any): Promise<void> {
    let result: any
    
    result = await safeEvaluate(page, flags.eval)
    
    // Convert result to string for comparison if needed
    const resultStr = typeof result === 'string' ? result : JSON.stringify(result)
    
    this.assertContent(resultStr, flags, `Evaluation result`, result)
  }

  private async assertStoredValue(flags: any): Promise<void> {
    const value = Store.getStoredValue(flags.stored)
    
    if (value === undefined) {
      throw new Error(`No stored value found for: ${flags.stored}`)
    }
    
    const valueStr = typeof value === 'string' ? value : JSON.stringify(value)
    
    this.assertContent(valueStr, flags, `Stored value "${flags.stored}"`, value)
  }

  private assertContent(content: string, flags: any, prefix: string, rawValue?: any): void {
    if (flags.contains) {
      if (!content.includes(flags.contains)) {
        throw new Error(`${prefix} "${content}" does not contain "${flags.contains}"`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} contains "${flags.contains}"`)
    } else if (flags.equals) {
      // For equals, also check raw value if available
      const expectedStr = flags.equals
      if (content !== expectedStr && rawValue !== flags.equals) {
        // Try numeric comparison if both can be parsed as numbers
        const numContent = parseFloat(content)
        const numExpected = parseFloat(expectedStr)
        if (isNaN(numContent) || isNaN(numExpected) || numContent !== numExpected) {
          throw new Error(`${prefix} "${content}" does not equal "${expectedStr}"`)
        }
      }
      this.log(`‚úÖ Assertion passed: ${prefix} equals "${flags.equals}"`)
    } else if (flags.matches) {
      const regex = new RegExp(flags.matches)
      if (!regex.test(content)) {
        throw new Error(`${prefix} "${content}" does not match pattern "${flags.matches}"`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} matches pattern "${flags.matches}"`)
    } else if (flags['greater-than']) {
      const numContent = parseFloat(content)
      const numThreshold = parseFloat(flags['greater-than'])
      if (isNaN(numContent) || isNaN(numThreshold)) {
        throw new Error(`Cannot compare non-numeric values: "${content}" > "${flags['greater-than']}"`)
      }
      if (numContent <= numThreshold) {
        throw new Error(`${prefix} ${numContent} is not greater than ${numThreshold}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} (${numContent}) is greater than ${numThreshold}`)
    } else if (flags['less-than']) {
      const numContent = parseFloat(content)
      const numThreshold = parseFloat(flags['less-than'])
      if (isNaN(numContent) || isNaN(numThreshold)) {
        throw new Error(`Cannot compare non-numeric values: "${content}" < "${flags['less-than']}"`)
      }
      if (numContent >= numThreshold) {
        throw new Error(`${prefix} ${numContent} is not less than ${numThreshold}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} (${numContent}) is less than ${numThreshold}`)
    } else {
      // For boolean expressions without comparison
      if (rawValue === false || rawValue === null || rawValue === undefined) {
        throw new Error(`Expression evaluated to ${rawValue}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} exists${rawValue !== undefined ? ` (${content})` : ''}`)
    }
    
    // Log details if verbose
    if (flags.verbose) {
      this.logVerbose('Assertion details', {
        type: prefix,
        content: content,
        rawValue: rawValue,
        assertion: flags.contains ? 'contains' : 
                   flags.equals ? 'equals' : 
                   flags.matches ? 'matches' :
                   flags['greater-than'] ? 'greater-than' :
                   flags['less-than'] ? 'less-than' : 'exists'
      })
    }
  }
}
</file>

<file path="src/commands/interactive.ts">
import { Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as readline from 'readline'
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'

interface CommandHistory {
  push(cmd: string): void
  get(index: number): string | undefined
  length: number
}

export default class Interactive extends BaseCommand {
  static description = 'Start an interactive CDP session with command completion and history'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --port 9222',
    '<%= config.bin %> <%= command.id %> --launch --profile work',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
  }

  private rl?: readline.Interface
  private historyFile: string
  private commandHistory: string[] = []
  private historyIndex: number = -1
  private commands = {
    navigate: 'Navigate to a URL',
    click: 'Click on an element',
    type: 'Type text into an element',
    evaluate: 'Evaluate JavaScript in the browser',
    screenshot: 'Take a screenshot',
    select: 'Select elements on the page',
    wait: 'Wait for an element or condition',
    hover: 'Hover over an element',
    back: 'Go back in browser history',
    forward: 'Go forward in browser history',
    reload: 'Reload the current page',
    url: 'Get the current URL',
    title: 'Get the page title',
    cookies: 'List all cookies',
    viewport: 'Set or get viewport size',
    login: 'Navigate and wait for login',
    help: 'Show available commands',
    clear: 'Clear the console',
    exit: 'Exit interactive mode',
    quit: 'Exit interactive mode',
  }

  constructor(argv: string[], config: any) {
    super(argv, config)
    this.historyFile = path.join(os.homedir(), '.chromancer_history')
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Interactive)
    
    // Connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open in interactive mode
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    // Load command history
    this.loadHistory()

    // Setup readline interface
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: 'chromancer> ',
      completer: this.completer.bind(this),
    })

    // Setup key bindings for history navigation
    this.setupKeyBindings()

    this.log('‚ú® Interactive CDP session started')
    this.log('Type "help" for available commands, "exit" to quit')
    this.log('')

    // Display prompt
    this.rl.prompt()

    // Handle line input
    this.rl.on('line', async (input: string) => {
      const trimmedInput = input.trim()
      
      if (trimmedInput) {
        // Add to history
        this.addToHistory(trimmedInput)
        
        try {
          await this.executeCommand(trimmedInput)
        } catch (error: any) {
          this.log(`‚ùå Error: ${error.message}`)
          this.logVerbose('Command execution error', error)
        }
      }
      
      this.rl?.prompt()
    })

    // Handle close
    this.rl.on('close', () => {
      this.saveHistory()
      this.log('\nüëã Goodbye!')
      process.exit(0)
    })
  }

  private setupKeyBindings(): void {
    if (!this.rl) return

    // Override keypress handling for history navigation
    process.stdin.on('keypress', (str, key) => {
      if (!key) return

      if (key.name === 'up') {
        // Navigate backward in history
        if (this.historyIndex < this.commandHistory.length - 1) {
          this.historyIndex++
          const cmd = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex]
          if (cmd && this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
            this.rl.write(cmd)
          }
        }
      } else if (key.name === 'down') {
        // Navigate forward in history
        if (this.historyIndex > 0) {
          this.historyIndex--
          const cmd = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex]
          if (cmd && this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
            this.rl.write(cmd)
          }
        } else if (this.historyIndex === 0) {
          // Clear the line when reaching the end of history
          this.historyIndex = -1
          if (this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
          }
        }
      }
    })
  }

  private completer(line: string): [string[], string] {
    const completions = Object.keys(this.commands)
    const hits = completions.filter((c) => c.startsWith(line))
    return [hits.length ? hits : completions, line]
  }

  private async executeCommand(input: string): Promise<void> {
    const parts = input.split(/\s+/)
    const command = parts[0].toLowerCase()
    const args = parts.slice(1)

    switch (command) {
      case 'help':
        this.showHelp()
        break

      case 'clear':
        console.clear()
        break

      case 'exit':
      case 'quit':
        this.rl?.close()
        break

      case 'navigate':
      case 'goto':
        if (args.length === 0) {
          this.log('Usage: navigate <url>')
          return
        }
        await this.navigate(args[0])
        break

      case 'click':
        if (args.length === 0) {
          this.log('Usage: click <selector>')
          return
        }
        await this.click(args.join(' '))
        break

      case 'type':
        if (args.length < 2) {
          this.log('Usage: type <selector> <text>')
          return
        }
        const selector = args[0]
        const text = args.slice(1).join(' ')
        await this.type(selector, text)
        break

      case 'evaluate':
      case 'eval':
        if (args.length === 0) {
          this.log('Usage: evaluate <javascript>')
          return
        }
        await this.evaluate(args.join(' '))
        break

      case 'screenshot':
        const filename = args[0] || `screenshot-${Date.now()}.png`
        await this.screenshot(filename)
        break

      case 'select':
        const selectSelector = args.join(' ') || '*'
        await this.select(selectSelector)
        break

      case 'wait':
        if (args.length === 0) {
          this.log('Usage: wait <selector>')
          return
        }
        await this.wait(args.join(' '))
        break

      case 'hover':
        if (args.length === 0) {
          this.log('Usage: hover <selector>')
          return
        }
        await this.hover(args.join(' '))
        break

      case 'back':
        await this.goBack()
        break

      case 'forward':
        await this.goForward()
        break

      case 'reload':
      case 'refresh':
        await this.reload()
        break

      case 'url':
        await this.showUrl()
        break

      case 'title':
        await this.showTitle()
        break

      case 'cookies':
        await this.showCookies()
        break

      case 'viewport':
        if (args.length >= 2) {
          const width = parseInt(args[0])
          const height = parseInt(args[1])
          await this.setViewport(width, height)
        } else {
          await this.showViewport()
        }
        break

      case 'login':
        if (args.length === 0) {
          this.log('Usage: login <url> [ready-selector]')
          return
        }
        const loginUrl = args[0]
        const readySelector = args[1]
        await this.waitForLogin(loginUrl, readySelector)
        break

      default:
        this.log(`Unknown command: ${command}`)
        this.log('Type "help" for available commands')
    }
  }

  private showHelp(): void {
    this.log('\nAvailable commands:')
    this.log('')
    
    Object.entries(this.commands).forEach(([cmd, desc]) => {
      this.log(`  ${cmd.padEnd(15)} ${desc}`)
    })
    
    this.log('')
    this.log('Examples:')
    this.log('  navigate https://example.com')
    this.log('  click button.submit')
    this.log('  type input[name="search"] hello world')
    this.log('  evaluate document.title')
    this.log('  screenshot output.png')
    this.log('  wait .loading-complete')
    this.log('  hover .dropdown-menu')
    this.log('  login https://gmail.com')
    this.log('')
  }

  private async navigate(url: string): Promise<void> {
    if (!this.page) return
    
    // Add protocol if missing
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url
    }
    
    this.log(`üåê Navigating to ${url}...`)
    await this.page.goto(url, { waitUntil: 'load' })
    this.log(`‚úÖ Navigated to ${url}`)
  }

  private async click(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`üñ±Ô∏è  Clicking ${selector}...`)
    await this.page.click(selector)
    this.log(`‚úÖ Clicked ${selector}`)
  }

  private async type(selector: string, text: string): Promise<void> {
    if (!this.page) return
    
    this.log(`‚å®Ô∏è  Typing into ${selector}...`)
    await this.page.type(selector, text)
    this.log(`‚úÖ Typed "${text}" into ${selector}`)
  }

  private async evaluate(code: string): Promise<void> {
    if (!this.page) return
    
    try {
      const result = await this.page.evaluate(code)
      this.log('üì§ Result:', JSON.stringify(result, null, 2))
    } catch (error: any) {
      this.log('‚ùå Evaluation error:', error.message)
    }
  }

  private async screenshot(filename: string): Promise<void> {
    if (!this.page) return
    
    // Ensure filename has proper extension
    if (!filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
      filename += '.png'
    }
    
    this.log(`üì∏ Taking screenshot...`)
    await this.page.screenshot({ path: filename, fullPage: true })
    this.log(`‚úÖ Screenshot saved to ${filename}`)
  }

  private async select(selector: string): Promise<void> {
    if (!this.page) return
    
    try {
      const count = await this.page.locator(selector).count()
      this.log(`üîç Found ${count} elements matching "${selector}"`)
      
      if (count > 0 && count <= 10) {
        // Show details for up to 10 elements
        for (let i = 0; i < count; i++) {
          const element = this.page.locator(selector).nth(i)
          const tagName = await element.evaluate(el => el.tagName.toLowerCase())
          const text = await element.textContent() || ''
          const className = await element.getAttribute('class') || ''
          
          this.log(`[${i}] <${tagName}${className ? ` class="${className}"` : ''}> ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`)
        }
      }
    } catch (error: any) {
      this.log('‚ùå Selection error:', error.message)
    }
  }

  private async wait(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`‚è≥ Waiting for ${selector}...`)
    await this.page.waitForSelector(selector, { state: 'visible' })
    this.log(`‚úÖ Element ${selector} is visible`)
  }

  private async hover(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`üéØ Hovering over ${selector}...`)
    await this.page.hover(selector)
    this.log(`‚úÖ Hovered over ${selector}`)
  }

  private async goBack(): Promise<void> {
    if (!this.page) return
    
    this.log('‚¨ÖÔ∏è  Going back...')
    await this.page.goBack()
    this.log('‚úÖ Navigated back')
  }

  private async goForward(): Promise<void> {
    if (!this.page) return
    
    this.log('‚û°Ô∏è  Going forward...')
    await this.page.goForward()
    this.log('‚úÖ Navigated forward')
  }

  private async reload(): Promise<void> {
    if (!this.page) return
    
    this.log('üîÑ Reloading page...')
    await this.page.reload()
    this.log('‚úÖ Page reloaded')
  }

  private async showUrl(): Promise<void> {
    if (!this.page) return
    
    const url = this.page.url()
    this.log('üîó Current URL:', url)
  }

  private async showTitle(): Promise<void> {
    if (!this.page) return
    
    const title = await this.page.title()
    this.log('üìÑ Page title:', title)
  }

  private async showCookies(): Promise<void> {
    if (!this.page) return
    
    const cookies = await this.page.context().cookies()
    this.log(`üç™ Found ${cookies.length} cookies:`)
    
    cookies.forEach(cookie => {
      this.log(`  ${cookie.name}: ${cookie.value.substring(0, 50)}${cookie.value.length > 50 ? '...' : ''}`)
    })
  }

  private async setViewport(width: number, height: number): Promise<void> {
    if (!this.page) return
    
    await this.page.setViewportSize({ width, height })
    this.log(`‚úÖ Viewport set to ${width}x${height}`)
  }

  private async showViewport(): Promise<void> {
    if (!this.page) return
    
    const viewport = this.page.viewportSize()
    if (viewport) {
      this.log('üìê Current viewport:', `${viewport.width}x${viewport.height}`)
    } else {
      this.log('No viewport set')
    }
  }

  private loadHistory(): void {
    try {
      if (fs.existsSync(this.historyFile)) {
        const data = fs.readFileSync(this.historyFile, 'utf-8')
        this.commandHistory = data.split('\n').filter(line => line.trim())
      }
    } catch (error) {
      // Ignore history load errors
    }
  }

  private saveHistory(): void {
    try {
      const historyData = this.commandHistory.slice(-1000).join('\n') // Keep last 1000 commands
      fs.writeFileSync(this.historyFile, historyData)
    } catch (error) {
      // Ignore history save errors
    }
  }

  private addToHistory(command: string): void {
    // Don't add duplicate consecutive commands
    if (this.commandHistory.length === 0 || this.commandHistory[this.commandHistory.length - 1] !== command) {
      this.commandHistory.push(command)
    }
    this.historyIndex = -1 // Reset history navigation
  }

  async finally(): Promise<void> {
    if (this.rl) {
      this.rl.close()
    }
    this.saveHistory()
    await super.finally()
  }
}
</file>

<file path="src/commands/run.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'
import * as yaml from 'yaml'
// Create a chalk-like interface for colorization
const chalk = {
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
}
import { Page } from 'playwright'

interface WorkflowStep {
  [command: string]: any
}

interface WorkflowOptions {
  strict?: boolean
  variables?: Record<string, string>
  timeout?: number
}

export default class Run extends BaseCommand {
  private parsedFlags: any
  static description = 'Run a workflow from a YAML file or stdin'

  static examples = [
    '<%= config.bin %> <%= command.id %> workflow.yml',
    '<%= config.bin %> <%= command.id %> --file automation.yml --strict',
    'echo "navigate: https://example.com\\nwait: {selector: body}" | <%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> test.yml --var USER=john --var PASS=secret',
  ]

  static args = {
    file: Args.string({
      description: 'YAML workflow file to run',
      required: false,
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    strict: Flags.boolean({
      description: 'Stop on first error (default: true)',
      default: true,
    }),
    'continue-on-error': Flags.boolean({
      description: 'Continue execution even if a step fails',
      default: false,
    }),
    var: Flags.string({
      description: 'Set workflow variables (KEY=VALUE)',
      multiple: true,
    }),
    timeout: Flags.integer({
      description: 'Default timeout for commands in milliseconds',
      default: 30000,
    }),
    'dry-run': Flags.boolean({
      description: 'Parse and validate workflow without executing',
      default: false,
    }),
  }

  private variables: Record<string, string> = {}
  private stepCount = 0
  private successCount = 0
  private failureCount = 0

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Run)
    this.parsedFlags = flags
    
    // Parse variables
    if (flags.var) {
      for (const varDef of flags.var) {
        const [key, ...valueParts] = varDef.split('=')
        if (key && valueParts.length > 0) {
          this.variables[key] = valueParts.join('=')
        }
      }
    }

    // Load workflow
    let workflowContent: string
    
    if (args.file) {
      // Read from file
      workflowContent = await fs.readFile(args.file, 'utf-8')
      this.log(chalk.cyan(`üìã Loading workflow from: ${args.file}`))
    } else if (process.stdin.isTTY === false) {
      // Read from stdin
      workflowContent = await this.readStdin()
      this.log(chalk.cyan('üìã Loading workflow from stdin'))
    } else {
      this.error('No workflow file specified. Provide a file path or pipe content to stdin.')
    }

    // Parse YAML
    let workflow: WorkflowStep[]
    try {
      const parsed = yaml.parse(workflowContent)
      workflow = Array.isArray(parsed) ? parsed : [parsed]
    } catch (error: any) {
      this.error(`Failed to parse YAML: ${error.message}`)
    }

    if (flags['dry-run']) {
      this.log(chalk.yellow('üîç Dry run mode - validating workflow'))
      this.validateWorkflow(workflow)
      this.log(chalk.green('‚úÖ Workflow is valid'))
      return
    }

    // Connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    // Execute workflow
    const options: WorkflowOptions = {
      strict: flags.strict && !flags['continue-on-error'],
      variables: this.variables,
      timeout: flags.timeout,
    }

    await this.executeWorkflow(workflow, this.page!, options)

    // Show summary
    this.showSummary()
  }

  private async readStdin(): Promise<string> {
    const chunks: Buffer[] = []
    
    for await (const chunk of process.stdin) {
      chunks.push(chunk)
    }
    
    return Buffer.concat(chunks).toString('utf-8')
  }

  private validateWorkflow(workflow: WorkflowStep[]): void {
    if (!Array.isArray(workflow) || workflow.length === 0) {
      this.error('Workflow must contain at least one step')
    }

    workflow.forEach((step, index) => {
      if (typeof step !== 'object' || step === null) {
        this.error(`Step ${index + 1} must be an object`)
      }

      const commands = Object.keys(step)
      if (commands.length === 0) {
        this.error(`Step ${index + 1} must contain a command`)
      }

      if (commands.length > 1) {
        this.warn(`Step ${index + 1} contains multiple commands - only first will be executed`)
      }
    })
  }

  private async executeWorkflow(
    workflow: WorkflowStep[], 
    page: Page, 
    options: WorkflowOptions
  ): Promise<void> {
    this.log(chalk.cyan(`\nüöÄ Executing workflow with ${workflow.length} steps\n`))

    for (const [index, step] of workflow.entries()) {
      this.stepCount++
      const stepNumber = index + 1
      
      // Get command and args
      const command = Object.keys(step)[0]
      let args = step[command]
      
      // Replace variables
      args = this.replaceVariables(args, options.variables || {})
      
      this.log(chalk.blue(`[${stepNumber}/${workflow.length}] ${command}`))
      
      try {
        await this.executeStep(command, args, page, options)
        this.successCount++
        this.log(chalk.green(`    ‚úÖ Success`))
      } catch (error: any) {
        this.failureCount++
        this.log(chalk.red(`    ‚ùå Failed: ${error.message}`))
        
        if (options.strict) {
          this.error(`Workflow failed at step ${stepNumber}: ${error.message}`)
        }
      }
      
      // Add small delay between steps
      await page.waitForTimeout(100)
    }
  }

  private async executeStep(
    command: string, 
    args: any, 
    page: Page,
    options: WorkflowOptions
  ): Promise<void> {
    const timeout = options.timeout || 30000

    switch (command) {
      case 'navigate':
      case 'goto':
        const url = typeof args === 'string' ? args : args.url
        await page.goto(url, { 
          waitUntil: args.waitUntil || 'load',
          timeout 
        })
        break

      case 'click':
        const clickSelector = typeof args === 'string' ? args : args.selector
        await page.click(clickSelector, {
          button: args.button || 'left',
          clickCount: args.clickCount || 1,
          timeout,
        })
        break

      case 'type':
        const typeSelector = typeof args === 'string' 
          ? args.split(' ')[0] 
          : args.selector
        const text = typeof args === 'string' 
          ? args.split(' ').slice(1).join(' ')
          : args.text
        
        await page.type(typeSelector, text, {
          delay: args.delay || 0,
        })
        
        if (args.submit || args.enter) {
          await page.press(typeSelector, 'Enter')
        }
        break

      case 'wait':
        if (typeof args === 'string') {
          await page.waitForSelector(args, { 
            state: 'visible',
            timeout 
          })
        } else if (args.selector) {
          await page.waitForSelector(args.selector, {
            state: args.state || 'visible',
            timeout: args.timeout || timeout,
          })
        } else if (args.time || args.ms) {
          await page.waitForTimeout(args.time || args.ms)
        } else if (args.url) {
          await page.waitForURL(args.url, { timeout })
        }
        break

      case 'screenshot':
        const path = typeof args === 'string' ? args : args.path
        await page.screenshot({
          path,
          fullPage: args.fullPage !== false,
          type: args.type || 'png',
        })
        break

      case 'evaluate':
      case 'eval':
        const code = typeof args === 'string' ? args : args.code
        const result = await page.evaluate(code)
        if (this.parsedFlags.verbose) {
          this.log(chalk.gray(`    Result: ${JSON.stringify(result)}`))
        }
        break

      case 'select':
        const selectSelector = typeof args === 'string' 
          ? args.split(' ')[0]
          : args.selector
        const value = typeof args === 'string'
          ? args.split(' ').slice(1).join(' ')
          : args.value
        
        await page.selectOption(selectSelector, value)
        break

      case 'hover':
        const hoverSelector = typeof args === 'string' ? args : args.selector
        await page.hover(hoverSelector, {
          timeout,
          position: args.position,
        })
        break

      case 'scroll':
        if (typeof args === 'string') {
          await page.evaluate(`window.scrollTo(0, document.body.scrollHeight)`)
        } else if (args.to) {
          await page.evaluate(({ selector }) => {
            document.querySelector(selector)?.scrollIntoView({ behavior: 'smooth' })
          }, { selector: args.to })
        } else if (args.by) {
          await page.evaluate(({ pixels }) => {
            window.scrollBy(0, pixels)
          }, { pixels: args.by })
        }
        break

      case 'fill':
        if (typeof args === 'object' && args.form) {
          for (const [field, value] of Object.entries(args.form)) {
            await page.fill(`[name="${field}"]`, String(value))
          }
        }
        break

      case 'press':
        const key = typeof args === 'string' ? args : args.key
        await page.keyboard.press(key)
        break

      case 'reload':
      case 'refresh':
        await page.reload({ waitUntil: args.waitUntil || 'load' })
        break

      case 'back':
        await page.goBack({ waitUntil: args.waitUntil || 'load' })
        break

      case 'forward':
        await page.goForward({ waitUntil: args.waitUntil || 'load' })
        break

      default:
        throw new Error(`Unknown command: ${command}`)
    }
  }

  private replaceVariables(value: any, variables: Record<string, string>): any {
    if (typeof value === 'string') {
      // Replace ${VAR} patterns
      return value.replace(/\$\{(\w+)\}/g, (match, varName) => {
        return variables[varName] || match
      })
    } else if (Array.isArray(value)) {
      return value.map(item => this.replaceVariables(item, variables))
    } else if (typeof value === 'object' && value !== null) {
      const result: any = {}
      for (const [key, val] of Object.entries(value)) {
        result[key] = this.replaceVariables(val, variables)
      }
      return result
    }
    
    return value
  }

  private showSummary(): void {
    this.log('')
    this.log(chalk.cyan('üìä Workflow Summary:'))
    this.log(`   Total steps: ${this.stepCount}`)
    this.log(`   ${chalk.green('Successful:')} ${this.successCount}`)
    if (this.failureCount > 0) {
      this.log(`   ${chalk.red('Failed:')} ${this.failureCount}`)
    }
    
    const successRate = this.stepCount > 0 
      ? Math.round((this.successCount / this.stepCount) * 100)
      : 0
    
    if (successRate === 100) {
      this.log(chalk.green(`\n‚úÖ All steps completed successfully!`))
    } else if (successRate > 0) {
      this.log(chalk.yellow(`\n‚ö†Ô∏è  ${successRate}% success rate`))
    } else {
      this.log(chalk.red(`\n‚ùå Workflow failed`))
    }
  }
}
</file>

<file path="src/commands/stop.ts">
import { Command } from '@oclif/core'
import { SessionManager } from '../session.js'

export default class Stop extends Command {
  static description = 'Stop the active Chrome browser instance'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
  ]

  public async run(): Promise<void> {
    const session = await SessionManager.getValidSession()
    
    if (!session) {
      this.log('No active Chrome session found')
      return
    }
    
    this.log(`Stopping Chrome on port ${session.port}...`)
    
    try {
      if (process.platform === 'win32') {
        // Windows-specific process termination
        try {
          // Use taskkill command on Windows
          const { execSync } = require('child_process')
          execSync(`taskkill /F /PID ${session.pid}`, { stdio: 'ignore' })
        } catch (error) {
          // Process might already be terminated
        }
      } else {
        // Unix-like systems
        try {
          // Try to kill the process gracefully
          process.kill(session.pid, 'SIGTERM')
          
          // Give it a moment to shut down gracefully
          await new Promise(resolve => setTimeout(resolve, 1000))
          
          // Check if it's still running
          try {
            process.kill(session.pid, 0)
            // If we get here, process is still running, force kill
            process.kill(session.pid, 'SIGKILL')
          } catch {
            // Process already terminated
          }
        } catch {
          // Process might already be terminated
        }
      }
      
      // Clear the session
      SessionManager.clearSession()
      
      this.log('‚úÖ Chrome stopped successfully')
    } catch (error) {
      this.error(`Failed to stop Chrome: ${error}`)
    }
  }
}
</file>

<file path="src/commands/store.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { safeEvaluate } from '../utils/evaluation.js'

export default class Store extends BaseCommand {
  static description = 'Store values from page elements or evaluations for later use'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#price" --as "originalPrice"',
    '<%= config.bin %> <%= command.id %> --eval "document.title" --as "pageTitle"',
    '<%= config.bin %> <%= command.id %> --selector "#username" --as "username" --property "value"',
    '<%= config.bin %> <%= command.id %> --cookies --as "sessionCookies"',
    '<%= config.bin %> <%= command.id %> --list',
    '<%= config.bin %> <%= command.id %> --clear',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector of element to store value from',
      exclusive: ['eval', 'list', 'clear', 'cookies'],
    }),
    eval: Flags.string({
      char: 'e',
      description: 'JavaScript expression to evaluate and store',
      exclusive: ['selector', 'list', 'clear', 'cookies'],
    }),
    cookies: Flags.boolean({
      description: 'Store all cookies',
      exclusive: ['selector', 'eval', 'list', 'clear'],
    }),
    as: Flags.string({
      char: 'a',
      description: 'Variable name to store the value as',
      dependsOn: ['selector', 'eval', 'cookies'],
    }),
    property: Flags.string({
      char: 'p',
      description: 'Element property to store (default: textContent)',
      default: 'textContent',
      dependsOn: ['selector'],
    }),
    attribute: Flags.string({
      description: 'Element attribute to store',
      exclusive: ['property'],
      dependsOn: ['selector'],
    }),
    list: Flags.boolean({
      description: 'List all stored values',
      exclusive: ['selector', 'eval', 'clear', 'cookies'],
    }),
    clear: Flags.boolean({
      description: 'Clear all stored values',
      exclusive: ['selector', 'eval', 'list', 'cookies'],
    }),
    json: Flags.boolean({
      description: 'Output stored values as JSON',
      dependsOn: ['list'],
    }),
  }

  // Static storage that persists across command invocations
  private static storage: Record<string, any> = {}

  async run(): Promise<void> {
    const { flags } = await this.parse(Store)
    
    // Handle list and clear operations without Chrome connection
    if (flags.list) {
      this.listStoredValues(flags.json)
      return
    }
    
    if (flags.clear) {
      this.clearStoredValues()
      return
    }
    
    // For other operations, connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, flags)
  }

  private async executeCommand(page: Page, flags: any): Promise<void> {
    // Ensure chromancer namespace exists in the page
    await page.evaluate(`
      if (typeof window.chromancer === 'undefined') {
        window.chromancer = { stored: {} };
      } else if (typeof window.chromancer.stored === 'undefined') {
        window.chromancer.stored = {};
      }
    `)
    
    // Inject existing stored values into the page
    for (const [key, value] of Object.entries(Store.storage)) {
      await page.evaluate(`
        window.chromancer.stored["${key}"] = ${JSON.stringify(value)};
      `)
    }
    
    let value: any
    
    if (flags.selector) {
      // Store from element
      try {
        this.log(`üîç Looking for element: ${flags.selector}`)
        const element = await waitForElement(page, flags.selector, {
          timeout: 5000,
          state: 'attached'
        })
        
        if (flags.attribute) {
          // Get attribute value
          value = await element.getAttribute(flags.attribute)
          this.logVerbose(`Getting attribute "${flags.attribute}"`)
        } else {
          // Get property value
          value = await element.evaluate((el, prop) => {
            return (el as any)[prop]
          }, flags.property)
          this.logVerbose(`Getting property "${flags.property}"`)
        }
        
      } catch (error: any) {
        if (error.name === 'TimeoutError') {
          this.error(`Element not found: ${flags.selector}`)
        }
        throw error
      }
    } else if (flags.eval) {
      // Store from evaluation
      this.log(`üîß Evaluating expression...`)
      value = await safeEvaluate(page, flags.eval)
    } else if (flags.cookies) {
      // Store cookies
      this.log(`üç™ Getting cookies...`)
      value = await page.context().cookies()
    }
    
    if (!flags.as) {
      this.error('Variable name required. Use --as flag to specify a name')
    }
    
    // Store the value
    Store.storage[flags.as] = value
    
    // Also store in the page context
    await page.evaluate(`
      window.chromancer.stored["${flags.as}"] = ${JSON.stringify(value)};
    `)
    
    this.log(`‚úÖ Stored value as "${flags.as}": ${this.formatValue(value)}`)
    
    // Log storage info if verbose
    if (flags.verbose) {
      this.logVerbose('Storage info', {
        variable: flags.as,
        type: typeof value,
        isArray: Array.isArray(value),
        totalStored: Object.keys(Store.storage).length,
      })
    }
  }
  
  private formatValue(value: any): string {
    if (typeof value === 'string') {
      return value.length > 100 ? `"${value.substring(0, 100)}..."` : `"${value}"`
    }
    if (typeof value === 'object') {
      const str = JSON.stringify(value)
      return str.length > 100 ? str.substring(0, 100) + '...' : str
    }
    return String(value)
  }
  
  private listStoredValues(json: boolean = false): void {
    if (Object.keys(Store.storage).length === 0) {
      this.log('‚ùå No values stored')
      return
    }
    
    if (json) {
      // Output as JSON for scripting
      console.log(JSON.stringify(Store.storage, null, 2))
    } else {
      this.log('üì¶ Stored values:')
      for (const [key, value] of Object.entries(Store.storage)) {
        this.log(`  ${key}: ${this.formatValue(value)}`)
      }
      this.log(`\nüìä Total: ${Object.keys(Store.storage).length} value(s)`)
    }
  }
  
  private clearStoredValues(): void {
    const count = Object.keys(Store.storage).length
    Store.storage = {}
    this.log(`‚úÖ Cleared all stored values (${count} values removed)`)
  }
  
  // Public method to access storage from other commands
  public static getStoredValue(key: string): any {
    return Store.storage[key]
  }
  
  // Public method to get all stored values
  public static getAllStoredValues(): Record<string, any> {
    return { ...Store.storage }
  }
}
</file>

<file path="src/utils/error-tips.ts">
import { CommandError } from './errors.js'

// Create a chalk-like interface for colorization
const chalk = {
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  redBright: (s: string) => `\x1b[91m${s}\x1b[0m`,
}

export interface ErrorTip {
  message: string
  tip?: string
  example?: string
  docsLink?: string
}

/**
 * Get actionable tips for common errors
 */
export function getErrorTip(error: CommandError | Error, command?: string): ErrorTip {
  const message = error.message.toLowerCase()
  const selector = (error as CommandError).selector
  
  // Selector-related errors
  if (message.includes('element not found') || message.includes('no element matches selector')) {
    return getSelectorErrorTip(selector, message)
  }
  
  // Timeout errors
  if (message.includes('timeout') || message.includes('waiting failed')) {
    return getTimeoutErrorTip(selector, command, message)
  }
  
  // Navigation errors
  if (message.includes('navigation') || message.includes('goto')) {
    return getNavigationErrorTip(message)
  }
  
  // Click errors
  if (message.includes('click') && message.includes('intercept')) {
    return {
      message: 'Element is covered by another element',
      tip: 'The element might be hidden behind a modal, popup, or overlay',
      example: 'chromancer wait --selector ".modal" --hidden\nchromancer click "#submit"',
    }
  }
  
  // Type errors
  if (message.includes('cannot type') || message.includes('not an input')) {
    return {
      message: 'Element is not an input field',
      tip: 'Make sure you\'re targeting an <input>, <textarea>, or contenteditable element',
      example: 'chromancer type "input[name=\'email\']" "test@example.com"',
    }
  }
  
  // Frame errors
  if (message.includes('frame') || message.includes('iframe')) {
    return {
      message: 'Element might be inside an iframe',
      tip: 'Use --frame option to target elements inside iframes',
      example: 'chromancer click "#button" --frame 0',
    }
  }
  
  // Connection errors
  if (message.includes('connect') || message.includes('connection refused')) {
    return {
      message: 'Cannot connect to Chrome',
      tip: 'Make sure Chrome is running with remote debugging enabled',
      example: 'chromancer spawn --headless\n# Or manually: chrome --remote-debugging-port=9222',
    }
  }
  
  // Permission errors
  if (message.includes('permission') || message.includes('access denied')) {
    return {
      message: 'Permission denied',
      tip: 'Check file permissions or try running with appropriate privileges',
    }
  }
  
  // Default tip
  return {
    message: error.message,
    tip: 'Check the command syntax and ensure the page has loaded completely',
  }
}

function getSelectorErrorTip(selector?: string, message?: string): ErrorTip {
  if (!selector) {
    return {
      message: 'Element not found',
      tip: 'Provide a valid CSS selector',
      example: 'chromancer click ".button-class"\nchromancer click "#button-id"',
    }
  }
  
  // Check for common selector mistakes
  if (selector.includes('//')) {
    return {
      message: `XPath selectors are not supported: ${selector}`,
      tip: 'Use CSS selectors instead of XPath',
      example: 'chromancer click "button[contains(text(), \'Submit\')]"',
    }
  }
  
  if (selector.match(/^[a-zA-Z]+$/) && !['html', 'body', 'head'].includes(selector)) {
    return {
      message: `Element not found: ${selector}`,
      tip: `Did you forget to add a class (.) or ID (#) prefix?`,
      example: `chromancer click ".${selector}" # for class\nchromancer click "#${selector}" # for ID`,
    }
  }
  
  if (selector.includes(':contains')) {
    return {
      message: 'The :contains() pseudo-selector is not standard CSS',
      tip: 'Use text-based selectors or Playwright\'s text locators',
      example: 'chromancer click "button:has-text(\'Submit\')"',
    }
  }
  
  if (selector.startsWith('.') && selector.includes(' ')) {
    return {
      message: `Element not found: ${selector}`,
      tip: 'Spaces in class selectors might be an issue. Try using dots for multiple classes',
      example: `chromancer click "${selector.replace(/ /g, '.')}"`,
    }
  }
  
  return {
    message: `Element not found: ${selector}`,
    tip: 'Ensure the element exists and is not hidden. Try waiting for it first',
    example: `chromancer wait --selector "${selector}"\nchromancer click "${selector}"`,
  }
}

function getTimeoutErrorTip(selector?: string, command?: string, message?: string): ErrorTip {
  if (message?.includes('navigation')) {
    return {
      message: 'Navigation timeout',
      tip: 'The page took too long to load. Try different wait conditions',
      example: 'chromancer navigate "https://example.com" --wait-until domcontentloaded\n# Or: --wait-until networkidle',
    }
  }
  
  if (selector) {
    return {
      message: `Timeout waiting for element: ${selector}`,
      tip: 'The element didn\'t appear within the timeout period',
      example: `# Increase timeout:\nchromancer wait --selector "${selector}" --timeout 60000\n\n# Or check if element is in iframe:\nchromancer wait --selector "${selector}" --frame 0`,
    }
  }
  
  return {
    message: 'Operation timed out',
    tip: 'Try increasing the timeout or checking network conditions',
    example: 'chromancer <command> --timeout 60000',
  }
}

function getNavigationErrorTip(message: string): ErrorTip {
  if (message.includes('invalid url') || message.includes('malformed')) {
    return {
      message: 'Invalid URL',
      tip: 'Make sure the URL includes the protocol (http:// or https://)',
      example: 'chromancer navigate "https://example.com"',
    }
  }
  
  if (message.includes('net::err') || message.includes('failed to load')) {
    return {
      message: 'Failed to load page',
      tip: 'Check your internet connection and verify the URL is accessible',
      example: '# Test with a known working site:\nchromancer navigate "https://google.com"',
    }
  }
  
  return {
    message: 'Navigation failed',
    tip: 'Try using different wait conditions or check if the site requires authentication',
    example: 'chromancer navigate "https://example.com" --wait-until networkidle',
  }
}

/**
 * Format and display error with tips
 */
export function displayErrorWithTip(
  error: CommandError | Error, 
  command?: string,
  docsBaseUrl: string = 'https://chromancer.dev/docs'
): void {
  const tip = getErrorTip(error, command)
  
  // Error message
  console.error(chalk.red('‚ùå ' + tip.message))
  
  // Tip
  if (tip.tip) {
    console.error(chalk.yellow('\nüí° Tip: ' + tip.tip))
  }
  
  // Example
  if (tip.example) {
    console.error(chalk.gray('\nExample:'))
    tip.example.split('\n').forEach(line => {
      console.error(chalk.gray('   ' + line))
    })
  }
  
  // Docs link
  if (command) {
    const docsLink = `${docsBaseUrl}/${command}#errors`
    console.error(chalk.blue('\nüìö Docs: ' + docsLink))
  }
}

/**
 * Enhance error messages in BaseCommand
 */
export function enhanceError(error: Error, context?: { command?: string, selector?: string }): Error {
  const tip = getErrorTip(error, context?.command)
  
  // Create enhanced error message
  let enhancedMessage = tip.message
  if (tip.tip) {
    enhancedMessage += `\nüí° ${tip.tip}`
  }
  
  const enhancedError = new Error(enhancedMessage)
  enhancedError.stack = error.stack
  
  return enhancedError
}
</file>

<file path="src/utils/evaluation.ts">
import { Page, ElementHandle } from 'playwright'

/**
 * Safely evaluate JavaScript in the page context with error handling
 */
export async function safeEvaluate<T = any>(
  page: Page,
  pageFunction: string | Function,
  ...args: any[]
): Promise<T> {
  try {
    return await page.evaluate(pageFunction as any, ...args) as T
  } catch (error: any) {
    if (error.name === 'SyntaxError') {
      throw new Error(`Invalid JavaScript expression: ${error.message}`)
    }
    throw new Error(`Failed to evaluate: ${error.message}`)
  }
}

/**
 * Get a single property from an element
 */
export async function evaluateElementProperty(
  element: ElementHandle,
  property: string
): Promise<any> {
  return element.evaluate((el, prop) => {
    return (el as any)[prop]
  }, property)
}

/**
 * Get multiple properties from an element at once
 */
export async function evaluateElementProperties(
  element: ElementHandle,
  properties?: string[]
): Promise<Record<string, any>> {
  const defaultProperties = [
    'textContent',
    'value',
    'id',
    'className',
    'tagName',
    'href',
  ]
  
  const props = properties || defaultProperties
  
  return element.evaluate((el, propList) => {
    const result: Record<string, any> = {}
    
    for (const prop of propList) {
      result[prop] = (el as any)[prop] || null
    }
    
    return result
  }, props)
}
</file>

<file path="src/utils/selectors.ts">
import { Page, Locator, ElementHandle } from 'playwright'

export interface WaitOptions {
  timeout?: number
  state?: 'attached' | 'detached' | 'visible' | 'hidden'
}

export interface ElementInfo {
  text: string
  value: string
  tagName: string
  id: string
  className: string
  isVisible: boolean
  isDisabled: boolean
  href?: string | null
  type?: string
  placeholder?: string
  [key: string]: any
}

/**
 * Wait for an element to appear on the page
 */
export async function waitForElement(
  page: Page, 
  selector: string, 
  options: WaitOptions = {}
): Promise<ElementHandle> {
  const { timeout = 30000, state = 'attached' } = options
  
  try {
    // In Playwright, we use waitForSelector which returns ElementHandle or null
    const element = await page.waitForSelector(selector, {
      timeout,
      state,
    })
    
    if (!element) {
      throw new Error(`Element not found: ${selector}`)
    }
    
    return element
  } catch (error: any) {
    if (error.message?.includes('Timeout') || error.message?.includes('Waiting failed')) {
      throw new Error(`Element not found: ${selector}`)
    }
    throw error
  }
}

/**
 * Check if an element is visible on the page
 */
export async function isElementVisible(page: Page, selector: string): Promise<boolean> {
  try {
    const element = await page.$(selector)
    if (!element) return false
    
    return await element.isVisible()
  } catch {
    return false
  }
}

/**
 * Get comprehensive information about an element
 */
export async function getElementInfo(page: Page, selector: string): Promise<ElementInfo | null> {
  const element = await page.$(selector)
  if (!element) return null
  
  return await element.evaluate((el: HTMLElement) => {
    const style = window.getComputedStyle(el)
    const rect = el.getBoundingClientRect()
    
    const info: any = {
      text: el.textContent?.trim() || '',
      value: (el as any).value || '',
      tagName: el.tagName,
      id: el.id,
      className: el.className,
      isVisible: (
        style.display !== 'none' &&
        style.visibility !== 'hidden' &&
        style.opacity !== '0' &&
        rect.width > 0 &&
        rect.height > 0
      ),
      isDisabled: (el as any).disabled || false,
    }
    
    // Add element-specific properties
    if (el.tagName === 'A') {
      info.href = (el as HTMLAnchorElement).href
    }
    
    if (el.tagName === 'INPUT') {
      info.type = (el as HTMLInputElement).type
      info.placeholder = (el as HTMLInputElement).placeholder
    }
    
    return info
  })
}
</file>

<file path="src/session.ts">
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'
import { ChildProcess } from 'child_process'

export interface ChromeSession {
  port: number
  pid: number
  startTime: number
  url?: string
}

export class SessionManager {
  private static sessionFile = path.join(os.tmpdir(), 'chromancer-session.json')
  private static activeProcess: ChildProcess | null = null

  static setActiveProcess(process: ChildProcess): void {
    this.activeProcess = process
  }

  static getActiveProcess(): ChildProcess | null {
    return this.activeProcess
  }

  static saveSession(session: ChromeSession): void {
    fs.writeFileSync(this.sessionFile, JSON.stringify(session, null, 2))
  }

  static loadSession(): ChromeSession | null {
    try {
      if (fs.existsSync(this.sessionFile)) {
        const data = fs.readFileSync(this.sessionFile, 'utf8')
        return JSON.parse(data)
      }
    } catch (error) {
      // Session file might be corrupted
    }
    return null
  }

  static clearSession(): void {
    try {
      if (fs.existsSync(this.sessionFile)) {
        fs.unlinkSync(this.sessionFile)
      }
    } catch (error) {
      // Ignore errors when clearing
    }
    this.activeProcess = null
  }

  static async isSessionValid(session: ChromeSession): Promise<boolean> {
    try {
      // Check if the process is still running
      if (process.platform === 'win32') {
        // On Windows, use tasklist to check if process exists
        const { execSync } = require('child_process')
        try {
          const output = execSync(`tasklist /FI "PID eq ${session.pid}"`, { encoding: 'utf8' })
          if (!output.includes(session.pid.toString())) {
            return false
          }
        } catch {
          return false
        }
      } else {
        // On Unix-like systems, use kill -0
        process.kill(session.pid, 0)
      }
      
      // Also check if Chrome is responding
      const response = await fetch(`http://localhost:${session.port}/json/version`)
      return response.ok
    } catch {
      return false
    }
  }

  static async getValidSession(): Promise<ChromeSession | null> {
    const session = this.loadSession()
    if (session && await this.isSessionValid(session)) {
      return session
    }
    this.clearSession()
    return null
  }
}
</file>

<file path="test/integration-tests.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const execAsync = promisify(exec);

// Helper to run chromancer commands
async function runCommand(cmd, expectFailure = false) {
  try {
    const { stdout, stderr } = await execAsync(`node ../bin/run.js ${cmd}`);
    return { success: true, stdout, stderr };
  } catch (error) {
    if (expectFailure) {
      return { success: false, error: error.message, stdout: error.stdout, stderr: error.stderr };
    }
    throw error;
  }
}

// Integration tests that require Chrome
async function runIntegrationTests() {
  console.log('Running integration tests for new features...\n');
  console.log('‚ö†Ô∏è  These tests require Chrome to be running with remote debugging enabled\n');
  
  const tests = [
    {
      name: 'Scroll command - scroll down',
      test: async () => {
        // First navigate to a page
        await runCommand('navigate https://example.com');
        // Then scroll
        const result = await runCommand('scroll down');
        if (!result.success) throw new Error('Scroll command failed');
        if (!result.stdout.includes('Scrolled down')) {
          throw new Error('Expected scroll confirmation');
        }
        return { success: true, message: 'Page scrolled successfully' };
      }
    },
    {
      name: 'Fill command - auto-generate form data',
      test: async () => {
        // Create a test form page
        const formHtml = `
          <html>
          <body>
            <form id="test-form">
              <input type="text" name="username" placeholder="Username">
              <input type="email" name="email" placeholder="Email">
              <button type="submit">Submit</button>
            </form>
          </body>
          </html>
        `;
        
        const testDir = path.join(__dirname, 'temp');
        await fs.mkdir(testDir, { recursive: true });
        await fs.writeFile(path.join(testDir, 'form.html'), formHtml);
        
        await runCommand(`navigate file://${path.join(testDir, 'form.html')}`);
        const result = await runCommand('fill --auto-generate');
        
        await fs.rm(testDir, { recursive: true, force: true });
        
        if (!result.success) throw new Error('Fill command failed');
        if (!result.stdout.includes('Form filled successfully')) {
          throw new Error('Expected fill confirmation');
        }
        return { success: true, message: 'Form filled with auto-generated data' };
      }
    },
    {
      name: 'Export command - export page as text',
      test: async () => {
        await runCommand('navigate https://example.com');
        const outputFile = 'test-export.txt';
        const result = await runCommand(`export --format text --output ${outputFile}`);
        
        if (!result.success) throw new Error('Export command failed');
        
        // Check if file was created
        const exists = await fs.access(outputFile).then(() => true).catch(() => false);
        if (!exists) throw new Error('Export file not created');
        
        // Clean up
        await fs.unlink(outputFile);
        
        return { success: true, message: 'Page exported as text' };
      }
    },
    {
      name: 'Cookies command - list cookies',
      test: async () => {
        await runCommand('navigate https://example.com');
        const result = await runCommand('cookies list');
        
        if (!result.success) throw new Error('Cookies command failed');
        // Example.com might not set cookies, so just check command runs
        return { success: true, message: 'Cookie listing works' };
      }
    },
    {
      name: 'PDF command - save page as PDF',
      test: async () => {
        await runCommand('navigate https://example.com');
        const outputFile = 'test-page.pdf';
        const result = await runCommand(`pdf --output ${outputFile}`);
        
        if (!result.success) throw new Error('PDF command failed');
        
        // Check if file was created
        const exists = await fs.access(outputFile).then(() => true).catch(() => false);
        if (!exists) throw new Error('PDF file not created');
        
        // Check file size
        const stats = await fs.stat(outputFile);
        if (stats.size === 0) throw new Error('PDF file is empty');
        
        // Clean up
        await fs.unlink(outputFile);
        
        return { success: true, message: 'Page saved as PDF' };
      }
    }
  ];
  
  let passed = 0;
  let failed = 0;
  const failedTests = [];
  
  // Check if Chrome is running first
  try {
    await runCommand('navigate https://example.com');
  } catch (error) {
    console.log('‚ùå Chrome is not running or not accessible');
    console.log('Please start Chrome with: chromancer spawn --headless');
    return false;
  }
  
  for (const { name, test } of tests) {
    try {
      const result = await test();
      console.log(`‚úÖ ${name}: ${result.message}`);
      passed++;
    } catch (error) {
      console.log(`‚ùå ${name}: ${error.message}`);
      failed++;
      failedTests.push({ name, error: error.message });
    }
  }
  
  console.log(`\n${passed} passed, ${failed} failed`);
  
  if (failed > 0) {
    console.log('\nFailed tests:');
    failedTests.forEach(({ name, error }) => {
      console.log(`  - ${name}: ${error}`);
    });
  }
  
  return failed === 0;
}

// Run tests
if (require.main === module) {
  runIntegrationTests()
    .then(success => process.exit(success ? 0 : 1))
    .catch(error => {
      console.error('Test suite error:', error);
      process.exit(1);
    });
}
</file>

<file path="test/new-features.test.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const fs = require('fs').promises;
const path = require('path');
const execAsync = promisify(exec);

// Helper to run chromancer commands
async function runCommand(cmd) {
  try {
    const { stdout, stderr } = await execAsync(`node ../bin/run.js ${cmd}`);
    return { success: true, stdout, stderr };
  } catch (error) {
    return { success: false, error: error.message, stdout: error.stdout, stderr: error.stderr };
  }
}

// Test suite for new features
async function testNewFeatures() {
  console.log('Testing new chromancer features...\n');
  
  const tests = [
    {
      name: 'Record command - help text',
      test: async () => {
        const result = await runCommand('record --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Record user interactions')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'Export command - help text',
      test: async () => {
        const result = await runCommand('export --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Export page content')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'Fill command - help text',
      test: async () => {
        const result = await runCommand('fill --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Fill form fields')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'Scroll command - help text',
      test: async () => {
        const result = await runCommand('scroll --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Scroll the page')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'Cookies command - help text',
      test: async () => {
        const result = await runCommand('cookies --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Manage browser cookies')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'PDF command - help text',
      test: async () => {
        const result = await runCommand('pdf --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Save page as PDF')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    },
    {
      name: 'Network command - help text',
      test: async () => {
        const result = await runCommand('network --help');
        if (!result.success) throw new Error('Command failed');
        if (!result.stdout.includes('Monitor network requests')) {
          throw new Error('Missing command description');
        }
        return { success: true, message: 'Help text correct' };
      }
    }
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const { name, test } of tests) {
    try {
      const result = await test();
      console.log(`‚úÖ ${name}: ${result.message}`);
      passed++;
    } catch (error) {
      console.log(`‚ùå ${name}: ${error.message}`);
      failed++;
    }
  }
  
  console.log(`\n${passed} passed, ${failed} failed`);
  return failed === 0;
}

// Integration tests (requires Chrome)
async function testIntegration() {
  console.log('\nIntegration tests for new features...\n');
  
  // Create test HTML files
  const testDir = path.join(__dirname, 'test-pages');
  await fs.mkdir(testDir, { recursive: true });
  
  // Create form test page
  await fs.writeFile(path.join(testDir, 'form.html'), `
    <html>
    <head><title>Form Test</title></head>
    <body>
      <form id="test-form">
        <input type="text" name="username" id="username" placeholder="Username">
        <input type="email" name="email" id="email" placeholder="Email">
        <input type="password" name="password" id="password" placeholder="Password">
        <select name="country" id="country">
          <option value="">Select Country</option>
          <option value="us">United States</option>
          <option value="uk">United Kingdom</option>
          <option value="ca">Canada</option>
        </select>
        <textarea name="bio" id="bio" placeholder="Bio"></textarea>
        <input type="checkbox" name="terms" id="terms">
        <label for="terms">Accept Terms</label>
        <button type="submit">Submit</button>
      </form>
    </body>
    </html>
  `);
  
  // Create scrollable page
  await fs.writeFile(path.join(testDir, 'scroll.html'), `
    <html>
    <head><title>Scroll Test</title></head>
    <body>
      <div style="height: 200vh;">
        <h1 id="top">Top of Page</h1>
        <div style="position: absolute; top: 50vh;">
          <h2 id="middle">Middle Section</h2>
        </div>
        <div style="position: absolute; bottom: 0;">
          <h2 id="bottom">Bottom of Page</h2>
        </div>
      </div>
    </body>
    </html>
  `);
  
  // Create data export test page
  await fs.writeFile(path.join(testDir, 'data.html'), `
    <html>
    <head><title>Data Export Test</title></head>
    <body>
      <table id="data-table">
        <thead>
          <tr><th>Name</th><th>Age</th><th>City</th></tr>
        </thead>
        <tbody>
          <tr><td>John Doe</td><td>30</td><td>New York</td></tr>
          <tr><td>Jane Smith</td><td>25</td><td>Los Angeles</td></tr>
          <tr><td>Bob Johnson</td><td>35</td><td>Chicago</td></tr>
        </tbody>
      </table>
      <div id="json-data" data-info='{"status": "active", "count": 42}'></div>
    </body>
    </html>
  `);
  
  console.log('‚úÖ Test pages created');
  
  // Cleanup
  await fs.rm(testDir, { recursive: true, force: true });
}

// Run tests
async function runTests() {
  const basicTests = await testNewFeatures();
  
  // Only run integration tests if basic tests pass
  if (basicTests) {
    await testIntegration();
  }
  
  process.exit(basicTests ? 0 : 1);
}

if (require.main === module) {
  runTests().catch(console.error);
}
</file>

<file path="test/refactor-test.js">
// Test refactored commands work correctly
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

async function testRefactoredCommands() {
  console.log('Testing refactored commands...\n');
  
  const tests = [
    {
      name: 'Click command help',
      cmd: 'node ../bin/run.js click --help',
      check: (output) => output.includes('Wait for selector') && output.includes('CSS selector')
    },
    {
      name: 'Hover command help',
      cmd: 'node ../bin/run.js hover --help',
      check: (output) => output.includes('Hover over an element') && output.includes('Duration')
    },
    {
      name: 'Wait command help',
      cmd: 'node ../bin/run.js wait --help',
      check: (output) => output.includes('Wait for elements') && output.includes('--selector')
    },
    {
      name: 'Store command help',
      cmd: 'node ../bin/run.js store --help',
      check: (output) => output.includes('Store values') && output.includes('--as')
    },
    {
      name: 'Assert command help',
      cmd: 'node ../bin/run.js assert --help',
      check: (output) => output.includes('Assert conditions') && output.includes('--equals')
    }
  ];
  
  let passed = 0;
  let failed = 0;
  
  for (const test of tests) {
    try {
      const result = await execAsync(test.cmd);
      if (test.check(result.stdout)) {
        console.log(`‚úÖ ${test.name}`);
        passed++;
      } else {
        console.log(`‚ùå ${test.name} - Output validation failed`);
        failed++;
      }
    } catch (error) {
      console.log(`‚ùå ${test.name} - Command failed: ${error.message}`);
      failed++;
    }
  }
  
  console.log(`\n${passed} passed, ${failed} failed`);
  
  if (failed > 0) {
    process.exit(1);
  }
}

testRefactoredCommands();
</file>

<file path="test/regression-tests.js">
#!/usr/bin/env node

const { execSync } = require('child_process');
const assert = require('assert');
const fs = require('fs');

// Color codes
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const RESET = '\x1b[0m';

function log(message, color = RESET) {
  console.log(`${color}${message}${RESET}`);
}

function runTest(name, fn) {
  try {
    fn();
    log(`‚úì ${name}`, GREEN);
    return true;
  } catch (error) {
    log(`‚úó ${name}`, RED);
    console.error(`  ${error.message}`);
    return false;
  }
}

log('Regression Tests', YELLOW);
log('================', YELLOW);
log('These tests verify edge cases and potential issues\n', YELLOW);

let passed = 0;
let failed = 0;

// Test 1: Handle special characters in selectors
if (runTest('Special characters in selectors', () => {
  try {
    execSync('node ../bin/run.js click "div[data-test=\'value\']" --help 2>&1', { encoding: 'utf8' });
  } catch (e) {
    // Should show help, not crash
    assert(e.message.includes('CSS selector'), 'Should handle special chars gracefully');
  }
})) passed++; else failed++;

// Test 2: Handle very long text input
if (runTest('Long text input handling', () => {
  const longText = 'a'.repeat(1000);
  try {
    execSync(`node ../bin/run.js type --help 2>&1`, { encoding: 'utf8' });
    // Just verify command structure works with potentially long inputs
  } catch (e) {
    throw new Error('Should handle long text parameters');
  }
})) passed++; else failed++;

// Test 3: Invalid port numbers
if (runTest('Invalid port validation', () => {
  const outputs = [];
  try {
    // Test negative port
    execSync('node ../bin/run.js navigate https://example.com --port -1 2>&1', { encoding: 'utf8' });
  } catch (e) {
    outputs.push('negative');
  }
  
  try {
    // Test port too high
    execSync('node ../bin/run.js navigate https://example.com --port 99999 2>&1', { encoding: 'utf8' });
  } catch (e) {
    outputs.push('too-high');
  }
  
  // Both should fail
  assert(outputs.length >= 1, 'Should validate port numbers');
})) passed++; else failed++;

// Test 4: Screenshot with invalid path
if (runTest('Screenshot invalid path handling', () => {
  try {
    execSync('node ../bin/run.js screenshot /nonexistent/path/file.png --help 2>&1', { encoding: 'utf8' });
    // Help should work regardless of path
  } catch (e) {
    throw new Error('Should handle help even with invalid paths');
  }
})) passed++; else failed++;

// Test 5: Multiple flags combination
if (runTest('Multiple flags work together', () => {
  const output = execSync('node ../bin/run.js navigate --help', { encoding: 'utf8' });
  assert(output.includes('--port'), 'Should have port flag');
  assert(output.includes('--host'), 'Should have host flag');
  assert(output.includes('--launch'), 'Should have launch flag');
  assert(output.includes('--wait-until'), 'Should have wait-until flag');
})) passed++; else failed++;

// Test 6: JavaScript injection safety
if (runTest('JavaScript injection safety', () => {
  // Verify evaluate command exists but we can't test actual execution without Chrome
  const output = execSync('node ../bin/run.js evaluate --help', { encoding: 'utf8' });
  assert(output.includes('JavaScript code to execute'), 'Should document JS execution');
})) passed++; else failed++;

// Test 7: Concurrent command handling
if (runTest('Commands are isolated', () => {
  // Each command should create its own connection
  const help1 = execSync('node ../bin/run.js navigate --help', { encoding: 'utf8' });
  const help2 = execSync('node ../bin/run.js click --help', { encoding: 'utf8' });
  assert(help1 !== help2, 'Different commands should have different help');
})) passed++; else failed++;

// Test 8: Error message clarity
if (runTest('Clear error messages', () => {
  try {
    execSync('node ../bin/run.js navigate 2>&1', { encoding: 'utf8', stdio: 'pipe' });
  } catch (e) {
    // Should have clear error about missing URL
    assert(e.status !== 0, 'Should exit with error');
  }
})) passed++; else failed++;

// Test 9: File permissions for screenshots
if (runTest('Screenshot file permissions', () => {
  // Test that screenshot command structure is correct
  const output = execSync('node ../bin/run.js screenshot --help', { encoding: 'utf8' });
  assert(output.includes('--format'), 'Should have format option');
  assert(output.includes('png'), 'Should support PNG');
  assert(output.includes('jpeg'), 'Should support JPEG');
})) passed++; else failed++;

// Test 10: Command aliases and shortcuts
if (runTest('Flag shortcuts work', () => {
  const output = execSync('node ../bin/run.js navigate --help', { encoding: 'utf8' });
  assert(output.includes('-p,'), 'Should have -p shortcut for port');
  assert(output.includes('-h,'), 'Should have -h shortcut for host');
  assert(output.includes('-l,'), 'Should have -l shortcut for launch');
})) passed++; else failed++;

// Summary
console.log('');
log('Regression Test Summary', YELLOW);
log('======================', YELLOW);
log(`Passed: ${passed}`, GREEN);
if (failed > 0) {
  log(`Failed: ${failed}`, RED);
  process.exit(1);
} else {
  log('All regression tests passed! ‚úì', GREEN);
}
</file>

<file path="test/simple-wait-test.js">
// Simple test to verify wait command works
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

async function testWaitCommand() {
  console.log('Testing wait command...');
  
  try {
    // Test help
    const helpResult = await execAsync('node ../bin/run.js wait --help');
    console.log('‚úÖ Wait command help works');
    console.log(helpResult.stdout);
    
    // Test hover help
    const hoverHelp = await execAsync('node ../bin/run.js hover --help');
    console.log('\n‚úÖ Hover command help works');
    console.log(hoverHelp.stdout);
    
  } catch (error) {
    console.error('‚ùå Test failed:', error.message);
  }
}

testWaitCommand();
</file>

<file path="test/test-error-tips.js">
const { exec } = require('child_process');
const { promisify } = require('util');
const execAsync = promisify(exec);

async function testErrorTips() {
  console.log('Testing enhanced error messages...\n');
  
  const tests = [
    {
      name: 'Selector without prefix',
      command: 'click button',
      expectedTip: 'Did you forget to add a class (.) or ID (#) prefix?'
    },
    {
      name: 'Element not found',
      command: 'click #non-existent-button',
      expectedTip: 'Ensure the element exists'
    },
    {
      name: 'XPath selector',
      command: 'click "//button[@id=\'submit\']"',
      expectedTip: 'Use CSS selectors instead of XPath'
    },
    {
      name: 'Connection error (no Chrome)',
      command: 'navigate https://example.com --port 9999',
      expectedTip: 'Make sure Chrome is running'
    },
    {
      name: 'Invalid URL',
      command: 'navigate example.com',
      expectedTip: 'Make sure the URL includes the protocol'
    }
  ];
  
  for (const test of tests) {
    console.log(`\nTest: ${test.name}`);
    console.log(`Command: chromancer ${test.command}`);
    console.log('Expected to see tip about:', test.expectedTip);
    console.log('-'.repeat(60));
    
    try {
      await execAsync(`node ../bin/run.js ${test.command}`, {
        timeout: 5000
      });
    } catch (error) {
      // Extract just the error output
      const output = error.stderr || error.stdout || '';
      const lines = output.split('\n').filter(line => 
        line.includes('‚ùå') || 
        line.includes('üí°') || 
        line.includes('Example:') ||
        line.includes('üìö')
      );
      
      console.log(lines.join('\n'));
    }
  }
}

// Run tests
if (require.main === module) {
  testErrorTips().catch(console.error);
}
</file>

<file path=".releaserc.json">
{
  "branches": ["main"],
  "plugins": [
    [
      "@semantic-release/commit-analyzer",
      {
        "preset": "angular",
        "releaseRules": [
          { "type": "feat", "release": "minor" },
          { "type": "fix", "release": "patch" },
          { "type": "perf", "release": "patch" },
          { "breaking": true, "release": "major" }
        ]
      }
    ],
    "@semantic-release/release-notes-generator",
    "@semantic-release/npm",
    "@semantic-release/github"
  ]
}
</file>

<file path="LICENSE">
MIT License

Copyright (c) 2024 John Lindquist

Permission is hereby granted, free of charge, to any person obtaining a copy
of this software and associated documentation files (the "Software"), to deal
in the Software without restriction, including without limitation the rights
to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
copies of the Software, and to permit persons to whom the Software is
furnished to do so, subject to the following conditions:

The above copyright notice and this permission notice shall be included in all
copies or substantial portions of the Software.

THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
SOFTWARE.
</file>

<file path="test-cli.sh">
#!/bin/bash

echo "Chrome DevTools Protocol CLI Test Script"
echo "========================================"
echo ""
echo "Before running this script, make sure Chrome is running with:"
echo "chromancer spawn --headless"
echo ""
echo "Press Enter to continue..."
read

# Test navigate command
echo "1. Testing navigate command..."
node ./bin/run.js navigate https://example.com
echo ""

# Test screenshot command
echo "2. Testing screenshot command..."
node ./bin/run.js screenshot example-screenshot.png
echo ""

# Test evaluate command
echo "3. Testing evaluate command (get page title)..."
node ./bin/run.js evaluate "document.title"
echo ""

# Test evaluate command (count links)
echo "4. Testing evaluate command (count links)..."
node ./bin/run.js evaluate "document.querySelectorAll('a').length"
echo ""

# Test click command
echo "5. Testing click command (will try to click first link)..."
node ./bin/run.js click "a" || echo "No clickable links found"
echo ""

# Test type command
echo "6. Testing type command (if there's an input field)..."
node ./bin/run.js type "input" "test text" || echo "No input fields found"
echo ""

echo "Test completed!"
</file>

<file path="tsconfig.json">
{
  "compilerOptions": {
    "declaration": true,
    "importHelpers": true,
    "module": "commonjs",
    "outDir": "dist",
    "rootDir": "src",
    "strict": true,
    "target": "es2022",
    "lib": ["es2022", "dom"],
    "esModuleInterop": true,
    "skipLibCheck": true,
    "forceConsistentCasingInFileNames": true,
    "moduleResolution": "node"
  },
  "include": ["src/**/*"],
  "exclude": ["node_modules", "dist"]
}
</file>

<file path="verify-all.sh">
#!/bin/bash

echo "Chrome DevTools Protocol CLI - Complete Verification"
echo "==================================================="
echo ""

# Color codes
GREEN='\033[0;32m'
RED='\033[0;31m'
YELLOW='\033[1;33m'
NC='\033[0m' # No Color

# Run all tests
echo -e "${YELLOW}Running Unit Tests...${NC}"
node test/unit-tests.js
echo ""

echo -e "${YELLOW}Running Regression Tests...${NC}"
node test/regression-tests.js
echo ""

echo -e "${YELLOW}Checking CLI Help...${NC}"
node ./bin/run.js --help
echo ""

echo -e "${YELLOW}Build Information:${NC}"
echo "Node version: $(node --version)"
echo "NPM version: $(npm --version)"
echo "TypeScript files compiled: $(find dist -name "*.js" | wc -l)"
echo ""

echo -e "${GREEN}‚úì All verifications complete!${NC}"
echo ""
echo "To run with Chrome:"
echo "1. Use spawn: chromancer spawn --headless"
echo "2. Run commands: chromancer navigate https://example.com"
echo ""
echo "Or use --launch flag to auto-start Chrome (if installed):"
echo "   chromancer navigate https://example.com --launch"
</file>

<file path=".github/workflows/release.yml">
name: Release and Publish

on:
  push:
    branches:
      - main

jobs:
  release:
    runs-on: ubuntu-latest
    permissions:
      contents: write
      issues: write
      pull-requests: write
      id-token: write
    steps:
      - name: Checkout code
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          token: ${{ secrets.GITHUB_TOKEN }}

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '18'
          registry-url: 'https://registry.npmjs.org'

      - name: Install dependencies
        run: npm ci

      - name: Build project
        run: npm run build

      - name: Install semantic-release plugins
        run: |
          npm install -D \
            @semantic-release/commit-analyzer \
            @semantic-release/release-notes-generator \
            @semantic-release/npm \
            @semantic-release/github \
            @semantic-release/git \
            conventional-changelog-conventionalcommits

      - name: Run semantic-release
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
          NPM_TOKEN: ${{ secrets.NPM_TOKEN }}
          NODE_AUTH_TOKEN: ${{ secrets.NPM_TOKEN }}
        run: npx semantic-release
</file>

<file path="src/commands/hover.ts">
import { Args, Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Hover extends BaseCommand {
  static description = 'Hover over an element to trigger hover states and tooltips'

  static examples = [
    '<%= config.bin %> <%= command.id %> "#menu-item"',
    '<%= config.bin %> <%= command.id %> ".dropdown-toggle" --duration 2000',
    '<%= config.bin %> <%= command.id %> "button.info" --wait-for ".tooltip"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    duration: Flags.integer({
      char: 'd',
      description: 'Duration to keep hovering in milliseconds',
      default: 0,
    }),
    'wait-for': Flags.string({
      description: 'Wait for element to appear after hovering',
    }),
    position: Flags.string({
      description: 'Hover position relative to element (format: x,y)',
    }),
    force: Flags.boolean({
      description: 'Force hover even if element is obscured',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      required: true,
      description: 'CSS selector of element to hover over',
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Hover)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, args.selector, flags)
  }

  private async executeCommand(page: Page, selector: string, flags: any): Promise<void> {
    try {
      this.logVerbose(`Looking for element: ${selector}`)
      
      // Wait for element to be present and visible
      await waitForElement(page, selector, { 
        state: 'visible',
        timeout: 30000 
      })
      
      // Build hover options
      const hoverOptions: any = {
        force: flags.force,
      }

      // Parse position if provided
      if (flags.position) {
        const [x, y] = flags.position.split(',').map((n: string) => parseInt(n.trim(), 10))
        if (!isNaN(x) && !isNaN(y)) {
          hoverOptions.position = { x, y }
          this.logVerbose('Hover position', { x, y })
        } else {
          this.warn('Invalid position format, ignoring position flag')
        }
      }

      this.log(`üéØ Hovering over element: ${selector}`)
      
      // Move mouse to element
      await page.hover(selector, hoverOptions)
      
      this.log(`‚úÖ Hovered over element: ${selector}`)
      
      // Wait for secondary element if specified
      if (flags['wait-for']) {
        this.log(`‚è≥ Waiting for: ${flags['wait-for']}`)
        try {
          await waitForElement(page, flags['wait-for'], {
            state: 'visible',
            timeout: 5000
          })
          this.log(`‚úÖ Element appeared: ${flags['wait-for']}`)
        } catch (error) {
          this.warn(`Element did not appear: ${flags['wait-for']}`)
        }
      }
      
      // If duration specified, keep hovering
      if (flags.duration > 0) {
        this.logVerbose(`Keeping hover for ${flags.duration}ms`)
        await new Promise(resolve => setTimeout(resolve, flags.duration))
      }

      // Log element info if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await page.$eval(selector, (el: Element) => {
            const rect = el.getBoundingClientRect()
            const styles = window.getComputedStyle(el)
            return {
              tagName: el.tagName.toLowerCase(),
              position: { x: rect.x, y: rect.y },
              size: { width: rect.width, height: rect.height },
              cursor: styles.cursor,
              hasTitle: !!el.getAttribute('title'),
              hasTooltip: !!el.getAttribute('data-tooltip') || !!el.getAttribute('data-bs-tooltip'),
            }
          })
          this.logVerbose('Hovered element info', elementInfo)
        } catch {
          // Element may have changed after hover
        }
      }
      
    } catch (error: any) {
      const commandError = handleCommandError(error, 'hover', selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/sessions.ts">
import { Flags } from '@oclif/core'
import { Command } from '@oclif/core'
import { execSync } from 'child_process'
import * as os from 'os'

interface ChromeInstance {
  port: number
  pid?: number
  version?: string
  tabs?: any[]
  error?: string
}

export default class Sessions extends Command {
  static description = 'List all Chrome instances with remote debugging enabled'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --kill 9222',
    '<%= config.bin %> <%= command.id %> --kill-all',
  ]

  static flags = {
    kill: Flags.integer({
      description: 'Kill Chrome instance on specified port',
      required: false,
    }),
    'kill-all': Flags.boolean({
      description: 'Kill all Chrome instances with debugging enabled',
      default: false,
    }),
    verbose: Flags.boolean({
      char: 'v',
      description: 'Show detailed information about each instance',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Sessions)

    // Find all Chrome instances with debugging ports
    const instances = await this.findChromeInstances()

    if (flags.verbose) {
      this.log('üîç Searching for Chrome instances...')
    }

    if (flags.kill) {
      await this.killInstance(flags.kill)
      return
    }

    if (flags['kill-all']) {
      await this.killAllInstances(instances)
      return
    }

    // Display found instances
    this.displayInstances(instances, flags.verbose)
  }

  private async findChromeInstances(): Promise<ChromeInstance[]> {
    const instances: ChromeInstance[] = []
    
    // Get all Chrome processes
    const platform = os.platform()
    let chromeProcesses: string = ''
    
    try {
      if (platform === 'darwin') {
        chromeProcesses = execSync('ps aux | grep -i "chrome.*remote-debugging-port" | grep -v grep', { encoding: 'utf8' })
      } else if (platform === 'linux') {
        chromeProcesses = execSync('ps aux | grep -i "chrom.*remote-debugging-port" | grep -v grep', { encoding: 'utf8' })
      } else if (platform === 'win32') {
        chromeProcesses = execSync('wmic process where "name like \'%chrome%\'" get processid,commandline /format:csv', { encoding: 'utf8' })
      }
    } catch (error) {
      // No Chrome processes found
      return instances
    }

    // Parse process list to find ports
    const portRegex = /--remote-debugging-port=(\d+)/
    const lines = chromeProcesses.split('\n').filter(line => line.trim())
    
    for (const line of lines) {
      const portMatch = line.match(portRegex)
      if (portMatch) {
        const port = parseInt(portMatch[1])
        const pidMatch = line.match(/^\s*\w+\s+(\d+)/)
        const pid = pidMatch ? parseInt(pidMatch[1]) : undefined
        
        // Try to connect to this port
        const instance = await this.checkChromeInstance(port, pid)
        instances.push(instance)
      }
    }

    // Also check common ports
    const commonPorts = [9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229]
    for (const port of commonPorts) {
      // Skip if already found
      if (instances.find(i => i.port === port)) continue
      
      const instance = await this.checkChromeInstance(port)
      if (!instance.error) {
        instances.push(instance)
      }
    }

    // Also check saved session
    try {
      const savedSession = await fetch('http://localhost:9222/json/version')
      if (savedSession.ok) {
        const instance = await this.checkChromeInstance(9222)
        if (!instance.error && !instances.find(i => i.port === 9222)) {
          instances.push(instance)
        }
      }
    } catch (error) {
      // No saved session
    }

    return instances.filter(i => !i.error)
  }

  private async checkChromeInstance(port: number, pid?: number): Promise<ChromeInstance> {
    const instance: ChromeInstance = { port, pid }
    
    try {
      // Try to get version info
      const versionResponse = await fetch(`http://localhost:${port}/json/version`)
      
      if (versionResponse.ok) {
        const versionData = await versionResponse.json() as any
        instance.version = versionData.Browser || 'Unknown'
        
        // Get tabs/pages
        const tabsResponse = await fetch(`http://localhost:${port}/json/list`)
        if (tabsResponse.ok) {
          instance.tabs = await tabsResponse.json() as any[]
        }
      }
    } catch (error) {
      instance.error = 'Not responding'
    }
    
    return instance
  }

  private displayInstances(instances: ChromeInstance[], verbose: boolean): void {
    if (instances.length === 0) {
      this.log('‚ùå No Chrome instances with remote debugging found')
      this.log('üí° Start Chrome with: chromancer spawn')
      return
    }

    this.log(`üîç Found ${instances.length} Chrome instance(s) with remote debugging:\n`)
    
    for (const instance of instances) {
      this.log(`üìç Port: ${instance.port}`)
      if (instance.pid) {
        this.log(`   PID: ${instance.pid}`)
      }
      if (instance.version) {
        this.log(`   Version: ${instance.version}`)
      }
      if (instance.tabs) {
        this.log(`   Open tabs: ${instance.tabs.length}`)
        if (verbose) {
          for (const tab of instance.tabs) {
            this.log(`     - ${tab.title || 'Untitled'} (${tab.url})`)
          }
        }
      }
      this.log('')
    }

    this.log('üí° To connect: cdp navigate <url> --port <port>')
    this.log('üí° To kill: cdp sessions --kill <port>')
  }

  private async killInstance(port: number): Promise<void> {
    const instances = await this.findChromeInstances()
    const instance = instances.find(i => i.port === port)
    
    if (!instance) {
      this.error(`No Chrome instance found on port ${port}`)
    }

    if (instance.pid) {
      try {
        if (os.platform() === 'win32') {
          execSync(`taskkill /F /PID ${instance.pid}`)
        } else {
          execSync(`kill -9 ${instance.pid}`)
        }
        this.log(`‚úÖ Killed Chrome instance on port ${port} (PID: ${instance.pid})`)
      } catch (error) {
        this.error(`Failed to kill Chrome instance: ${error}`)
      }
    } else {
      this.error(`Could not find PID for Chrome instance on port ${port}`)
    }
  }

  private async killAllInstances(instances: ChromeInstance[]): Promise<void> {
    if (instances.length === 0) {
      this.log('‚ùå No Chrome instances to kill')
      return
    }

    let killed = 0
    for (const instance of instances) {
      if (instance.pid) {
        try {
          if (os.platform() === 'win32') {
            execSync(`taskkill /F /PID ${instance.pid}`)
          } else {
            execSync(`kill -9 ${instance.pid}`)
          }
          this.log(`‚úÖ Killed Chrome on port ${instance.port} (PID: ${instance.pid})`)
          killed++
        } catch (error) {
          this.log(`‚ùå Failed to kill Chrome on port ${instance.port}: ${error}`)
        }
      }
    }

    this.log(`\nüßπ Killed ${killed} Chrome instance(s)`)
  }
}
</file>

<file path="src/commands/wait.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError, isTimeoutError } from '../utils/errors.js'

export default class Wait extends BaseCommand {
  static description = 'Wait for elements or conditions before proceeding'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#dynamic-content"',
    '<%= config.bin %> <%= command.id %> --selector ".loading" --hidden',
    '<%= config.bin %> <%= command.id %> --condition "document.readyState === \'complete\'"',
    '<%= config.bin %> <%= command.id %> --page-load',
    '<%= config.bin %> <%= command.id %> --network-idle',
    '<%= config.bin %> <%= command.id %> --url "https://example.com"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to wait for',
    }),
    condition: Flags.string({
      char: 'c',
      description: 'JavaScript condition to wait for',
    }),
    visible: Flags.boolean({
      description: 'Wait for element to be visible',
      default: false,
    }),
    hidden: Flags.boolean({
      description: 'Wait for element to be hidden',
      default: false,
    }),
    timeout: Flags.integer({
      char: 't',
      description: 'Maximum time to wait in milliseconds',
      default: 30000,
    }),
    'page-load': Flags.boolean({
      description: 'Wait for page load to complete',
      default: false,
    }),
    'network-idle': Flags.boolean({
      description: 'Wait for network to be idle',
      default: false,
    }),
    url: Flags.string({
      description: 'Wait for URL to match (supports partial match)',
    }),
    text: Flags.string({
      description: 'Wait for text to appear in the page',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Wait)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!)
  }

  private async executeCommand(page: Page): Promise<void> {
    const { flags } = await this.parse(Wait)
    
    const waitPromises: Promise<any>[] = []
    const waitDescriptions: string[] = []

    // Wait for selector with visibility state
    if (flags.selector) {
      if (flags.visible) {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            state: 'visible', 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}" to be visible`)
      } else if (flags.hidden) {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            state: 'hidden', 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}" to be hidden`)
      } else {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}"`)
      }
    }

    // Wait for custom condition
    if (flags.condition) {
      waitPromises.push(page.waitForFunction(flags.condition, {
        timeout: flags.timeout,
      }))
      waitDescriptions.push(`condition "${flags.condition}"`)
    }

    // Wait for page load
    if (flags['page-load']) {
      waitPromises.push(page.waitForLoadState('load', {
        timeout: flags.timeout,
      }))
      waitDescriptions.push('page load')
    }

    // Wait for network idle
    if (flags['network-idle']) {
      waitPromises.push(page.waitForLoadState('networkidle', {
        timeout: flags.timeout,
      }))
      waitDescriptions.push('network idle')
    }

    // Wait for URL
    if (flags.url) {
      waitPromises.push(page.waitForURL(flags.url, {
        timeout: flags.timeout,
      }))
      waitDescriptions.push(`URL to match "${flags.url}"`)
    }

    // Wait for text
    if (flags.text) {
      waitPromises.push(
        page.waitForFunction(
          (text) => document.body.textContent?.includes(text),
          flags.text,
          { timeout: flags.timeout }
        )
      )
      waitDescriptions.push(`text "${flags.text}" to appear`)
    }

    // If no wait conditions specified, show error
    if (waitPromises.length === 0) {
      this.error('No wait condition specified. Use --selector, --condition, --page-load, --network-idle, --url, or --text')
    }

    try {
      this.log(`‚è≥ Waiting for ${waitDescriptions.join(' and ')}...`)
      
      // Wait for all conditions
      await Promise.all(waitPromises)
      
      if (waitDescriptions.length === 1) {
        if (flags.selector && flags.visible) {
          this.log(`‚úÖ Element is visible: ${flags.selector}`)
        } else if (flags.selector && flags.hidden) {
          this.log(`‚úÖ Element is hidden: ${flags.selector}`)
        } else if (flags.selector) {
          this.log(`‚úÖ Element found: ${flags.selector}`)
        } else if (flags.condition) {
          this.log(`‚úÖ Condition met: ${flags.condition}`)
        } else if (flags['page-load']) {
          this.log('‚úÖ Page loaded')
        } else if (flags['network-idle']) {
          this.log('‚úÖ Network idle')
        } else if (flags.url) {
          this.log(`‚úÖ URL matched: ${page.url()}`)
        } else if (flags.text) {
          this.log(`‚úÖ Text found: "${flags.text}"`)
        }
      } else {
        this.log(`‚úÖ All conditions met`)
      }

      // Log additional info if verbose
      if (flags.verbose) {
        this.logVerbose('Wait completed', {
          conditions: waitDescriptions,
          currentUrl: page.url(),
          title: await page.title(),
        })
      }
    } catch (error: any) {
      if (isTimeoutError(error)) {
        this.error(`Timeout waiting for ${waitDescriptions.join(' and ')} (${flags.timeout}ms)`)
      }
      const commandError = handleCommandError(error, 'wait')
      this.error(commandError.message)
    }
  }
}
</file>

<file path="test/test-suite.js">
#!/usr/bin/env node

const { execSync } = require('child_process');
const fs = require('fs');
const path = require('path');

const CHROME_PORT = 9222;
const TEST_URL = 'https://example.com';

// Color codes for output
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const RESET = '\x1b[0m';

let passedTests = 0;
let failedTests = 0;

function log(message, color = RESET) {
  console.log(`${color}${message}${RESET}`);
}

function runCommand(command, expectError = false) {
  try {
    const output = execSync(command, { encoding: 'utf8' });
    if (expectError) {
      throw new Error(`Expected command to fail but it succeeded: ${command}`);
    }
    return output;
  } catch (error) {
    if (!expectError) {
      throw error;
    }
    return error.message;
  }
}

function runTest(testName, testFn) {
  process.stdout.write(`Testing ${testName}... `);
  try {
    testFn();
    log('PASSED', GREEN);
    passedTests++;
  } catch (error) {
    log('FAILED', RED);
    log(`  Error: ${error.message}`, RED);
    failedTests++;
  }
}

function checkChromeConnection() {
  try {
    // Try to connect to Chrome DevTools
    const http = require('http');
    return new Promise((resolve) => {
      const req = http.get(`http://localhost:${CHROME_PORT}/json/version`, (res) => {
        resolve(res.statusCode === 200);
      });
      req.on('error', () => resolve(false));
      req.setTimeout(1000, () => {
        req.destroy();
        resolve(false);
      });
    });
  } catch {
    return Promise.resolve(false);
  }
}

async function main() {
  log('Chrome DevTools Protocol CLI Test Suite', YELLOW);
  log('=====================================', YELLOW);
  console.log('');

  // Check if Chrome is running
  const chromeConnected = await checkChromeConnection();
  if (!chromeConnected) {
    log(`Chrome is not running on port ${CHROME_PORT}`, RED);
    log('Please start Chrome with:', YELLOW);
    log(`  chromancer spawn --headless --port ${CHROME_PORT}`, YELLOW);
    log('Or for testing with GUI:', YELLOW);
    log(`  chromancer spawn --port ${CHROME_PORT}`, YELLOW);
    process.exit(1);
  }

  log('Chrome connection verified ‚úì', GREEN);
  console.log('');

  // Test 1: Help command
  runTest('help command', () => {
    const output = runCommand('node ../bin/run.js --help');
    if (!output.includes('VERSION') || !output.includes('COMMANDS')) {
      throw new Error('Help output missing expected content');
    }
  });

  // Test 2: Navigate command
  runTest('navigate command', () => {
    const output = runCommand(`node ../bin/run.js navigate ${TEST_URL}`);
    if (!output.includes('Successfully navigated')) {
      throw new Error('Navigation did not complete successfully');
    }
  });

  // Test 3: Screenshot command
  runTest('screenshot command', () => {
    const screenshotPath = 'test-screenshot.png';
    runCommand(`node ../bin/run.js screenshot ${screenshotPath}`);
    if (!fs.existsSync(screenshotPath)) {
      throw new Error('Screenshot file was not created');
    }
    // Clean up
    fs.unlinkSync(screenshotPath);
  });

  // Test 4: Evaluate command - get title
  runTest('evaluate command (get title)', () => {
    const output = runCommand('node ../bin/run.js evaluate "document.title"');
    if (!output.includes('Example Domain')) {
      throw new Error('Did not get expected page title');
    }
  });

  // Test 5: Evaluate command - count elements
  runTest('evaluate command (count links)', () => {
    const output = runCommand('node ../bin/run.js evaluate "document.querySelectorAll(\'a\').length"');
    if (!output.includes('Result:')) {
      throw new Error('Evaluate command did not return a result');
    }
  });

  // Test 6: Invalid selector (should fail gracefully)
  runTest('click command with invalid selector', () => {
    runCommand('node ../bin/run.js click ".non-existent-element" --timeout 1000', true);
  });

  // Test 7: Type command with non-existent input
  runTest('type command with invalid selector', () => {
    runCommand('node ../bin/run.js type "input.non-existent" "test" --timeout 1000', true);
  });

  // Test 8: Navigate to invalid URL
  runTest('navigate to invalid URL', () => {
    runCommand('node ../bin/run.js navigate "not-a-valid-url"', true);
  });

  // Test 9: Full page screenshot
  runTest('full page screenshot', () => {
    const screenshotPath = 'test-fullpage.png';
    runCommand(`node ../bin/run.js screenshot ${screenshotPath} --full-page`);
    if (!fs.existsSync(screenshotPath)) {
      throw new Error('Full page screenshot file was not created');
    }
    // Clean up
    fs.unlinkSync(screenshotPath);
  });

  // Test 10: Multiple commands in sequence
  runTest('command sequence', () => {
    runCommand(`node ../bin/run.js navigate ${TEST_URL}`);
    const output = runCommand('node ../bin/run.js evaluate "window.location.href"');
    if (!output.includes('example.com')) {
      throw new Error('Sequential commands did not maintain state');
    }
  });

  // Summary
  console.log('');
  log('Test Summary', YELLOW);
  log('============', YELLOW);
  log(`Passed: ${passedTests}`, GREEN);
  if (failedTests > 0) {
    log(`Failed: ${failedTests}`, RED);
    process.exit(1);
  } else {
    log('All tests passed! ‚úì', GREEN);
  }
}

main().catch(console.error);
</file>

<file path="CLAUDE.md">
# CLAUDE.md

This file provides guidance to Claude Code (claude.ai/code) when working with code in this repository.

## Common Development Commands

**Build the project:**
```bash
pnpm run build
```

**Run commands (after building):**
```bash
node ./bin/run.js [command] [options]
```

**Testing:**
```bash
# Unit tests - verify CLI structure
node test/unit-tests.js

# Regression tests
node test/regression-tests.js

# Full test suite (requires Chrome running)
node test/test-suite.js

# Vitest integration tests (comprehensive)
npm run test:vitest:run

# Run all tests with Chrome auto-start
./run-chromancer-tests.sh

# Complete verification
./verify-all.sh
```

**Start Chrome for testing:**
```bash
# Use the spawn command (recommended)
chromancer spawn --headless
chromancer spawn https://example.com

# Or use Docker
docker run -d --name chrome-test -p 9222:9222 zenika/alpine-chrome \
  --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222
```

## Architecture Overview

### CDP-CLI Architecture

The CDP-CLI tool follows the oclif framework pattern:

1. **Base Command Class** (`src/base.ts`):
   - Handles Chrome connection logic via puppeteer-core
   - Provides shared flags (port, host, launch)
   - Manages browser lifecycle (connect/disconnect/launch)
   - Auto-detects Chrome executable paths

2. **Command Structure** (`src/commands/`):
   - Each command extends BaseCommand
   - Commands: navigate, click, type, evaluate, screenshot
   - All commands support global flags for Chrome connection
   - Commands handle their specific CDP operations

3. **Key Design Decisions**:
   - Uses puppeteer-core for CDP communication
   - Supports both connecting to existing Chrome instances and auto-launching
   - TypeScript for type safety
   - oclif framework for CLI structure and help generation

### Chrome Connection Flow

1. Commands first attempt to connect to existing Chrome instance
2. If connection fails and `--launch` flag is provided, attempts to launch Chrome
3. Automatically finds Chrome executable across different platforms
4. Properly cleans up connections (disconnect vs close based on launch mode)

## Important Notes

- The CDP-CLI tool requires Chrome/Chromium to be installed and running with remote debugging enabled
- All CDP-CLI commands are in the `cdp-cli` subdirectory
- The tool supports both manual Chrome management and auto-launch mode
- Tests include unit tests (no Chrome needed) and integration tests (Chrome required)

## Memories

- Remember what worked and what didn't
</file>

<file path="src/commands/evaluate.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { safeEvaluate } from '../utils/evaluation.js'

export default class Evaluate extends BaseCommand {
  static description = 'Execute JavaScript in the page context'

  static examples = [
    '<%= config.bin %> <%= command.id %> "document.title"',
    '<%= config.bin %> <%= command.id %> "document.querySelectorAll(\'a\').length" --return-result',
    '<%= config.bin %> <%= command.id %> "localStorage.getItem(\'token\')" --json',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'return-result': Flags.boolean({
      description: 'Print the result of the evaluation',
      default: true,
    }),
    json: Flags.boolean({
      description: 'Output result as raw JSON',
      default: false,
    }),
    selector: Flags.string({
      description: 'Evaluate within the context of a specific element',
    }),
  }

  static args = {
    script: Args.string({
      description: 'JavaScript code to execute',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Evaluate)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      this.log(`üîß Evaluating JavaScript...`)
      this.logVerbose('Script to evaluate', { script: args.script })

      let result: any

      if (flags.selector) {
        // Evaluate within element context
        this.log(`üìç Using element context: ${flags.selector}`)
        const element = await this.page!.$(flags.selector)
        if (!element) {
          this.error(`Element not found: ${flags.selector}`)
        }
        
        result = await element!.evaluate((el, script) => {
          // Create a function that has 'el' in scope
          const fn = new Function('el', `return ${script}`)
          return fn(el)
        }, args.script)
      } else {
        // Evaluate in page context
        result = await safeEvaluate(this.page!, args.script)
      }
      
      if (flags['return-result']) {
        if (flags.json) {
          // Raw JSON output for scripting
          console.log(JSON.stringify(result))
        } else {
          // Pretty formatted output
          this.log('üì§ Result:')
          if (result === undefined) {
            this.log('undefined')
          } else if (result === null) {
            this.log('null')
          } else if (typeof result === 'object') {
            this.log(JSON.stringify(result, null, 2))
          } else {
            this.log(String(result))
          }
        }

        // Log type information if verbose
        if (flags.verbose && !flags.json) {
          this.logVerbose('Result type', {
            type: typeof result,
            isArray: Array.isArray(result),
            constructor: result?.constructor?.name,
          })
        }
      } else {
        this.log('‚úÖ JavaScript executed successfully')
      }

      // Log performance metrics if verbose
      if (flags.verbose) {
        const metrics = await this.page!.evaluate(() => {
          if (typeof performance !== 'undefined' && (performance as any).memory) {
            return {
              usedJSHeapSize: Math.round((performance as any).memory.usedJSHeapSize / 1024 / 1024) + 'MB',
              totalJSHeapSize: Math.round((performance as any).memory.totalJSHeapSize / 1024 / 1024) + 'MB',
            }
          }
          return null
        })
        if (metrics) {
          this.logVerbose('Memory usage', metrics)
        }
      }
    } catch (error: any) {
      if (error.name === 'SyntaxError' || error.message.includes('SyntaxError')) {
        this.error(`JavaScript syntax error: ${error.message}`)
      }
      this.error(`Failed to evaluate JavaScript: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/navigate.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'

export default class Navigate extends BaseCommand {
  static description = 'Navigate to a URL in Chrome'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> https://example.com --wait-until networkidle',
    '<%= config.bin %> <%= command.id %> https://example.com --profile personal',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'wait-until': Flags.string({
      description: 'When to consider navigation succeeded',
      options: ['load', 'domcontentloaded', 'networkidle', 'commit'],
      default: 'load',
    }),
    timeout: Flags.integer({
      description: 'Maximum navigation time in milliseconds',
      default: 30000,
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to navigate to',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Navigate)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    // Set up verbose logging event listeners
    if (flags.verbose) {
      this.setupVerbosePageListeners()
    }

    try {
      this.log(`üåê Navigating to ${args.url}...`)
      this.logVerbose('Navigation options', {
        url: args.url,
        waitUntil: flags['wait-until'],
        timeout: flags.timeout,
      })

      const startTime = Date.now()
      const response = await this.page!.goto(args.url, {
        waitUntil: flags['wait-until'] as any,
        timeout: flags.timeout,
      })

      const loadTime = Date.now() - startTime
      
      if (response) {
        const status = response.status()
        this.log(`‚úÖ Navigated to ${args.url} (${status} - ${loadTime}ms)`)
        
        if (flags.verbose) {
          const metrics = await this.page!.evaluate(() => {
            const timing = performance.timing
            return {
              domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
              loadComplete: timing.loadEventEnd - timing.loadEventStart,
              domInteractive: timing.domInteractive - timing.navigationStart,
              responseEnd: timing.responseEnd - timing.requestStart,
            }
          })
          
          this.logVerbose('Performance metrics', metrics)
        }
      } else {
        this.log(`‚úÖ Navigated to ${args.url} (${loadTime}ms)`)
      }

      // Get final page info
      const title = await this.page!.title()
      const finalUrl = this.page!.url()
      
      if (title) {
        this.log(`üìÑ Page title: "${title}"`)
      }
      
      if (finalUrl !== args.url) {
        this.log(`üîÄ Final URL: ${finalUrl}`)
      }
    } catch (error: any) {
      if (error.name === 'TimeoutError') {
        this.error(`Navigation timeout: Failed to navigate to ${args.url} within ${flags.timeout}ms`)
      }
      this.error(`Navigation failed: ${error.message}`)
    }
  }

  private setupVerbosePageListeners(): void {
    if (!this.page) return

    // Request logging
    this.page.on('request', request => {
      this.logVerbose(`üì§ Request: ${request.method()} ${request.url()}`)
    })

    // Response logging
    this.page.on('response', response => {
      this.logVerbose(`üì• Response: ${response.status()} ${response.url()}`)
    })

    // Console logging
    this.page.on('console', msg => {
      this.logVerbose(`üñ•Ô∏è  Console [${msg.type()}]: ${msg.text()}`)
    })

    // Page errors
    this.page.on('pageerror', error => {
      this.logVerbose(`‚ùå Page error: ${error.message}`)
    })

    // Frame navigation
    this.page.on('framenavigated', frame => {
      if (frame === this.page!.mainFrame()) {
        this.logVerbose(`üîÑ Main frame navigated to: ${frame.url()}`)
      }
    })

    // Downloads
    this.page.on('download', download => {
      this.logVerbose(`‚¨áÔ∏è  Download started: ${download.suggestedFilename()}`)
    })
  }
}
</file>

<file path="src/commands/screenshot.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as fs from 'fs/promises'
import * as path from 'path'

export default class Screenshot extends BaseCommand {
  static description = 'Take a screenshot of the current page'

  static examples = [
    '<%= config.bin %> <%= command.id %> screenshot.png',
    '<%= config.bin %> <%= command.id %> fullpage.png --full-page',
    '<%= config.bin %> <%= command.id %> element.png --selector ".main-content"',
    '<%= config.bin %> <%= command.id %> mobile.png --viewport 375x667',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'full-page': Flags.boolean({
      description: 'Capture full scrollable page',
      default: false,
    }),
    format: Flags.string({
      description: 'Screenshot format',
      options: ['png', 'jpeg', 'webp'],
      default: 'png',
    }),
    quality: Flags.integer({
      description: 'Quality (0-100) for JPEG/WebP format',
      default: 80,
    }),
    selector: Flags.string({
      description: 'CSS selector of element to screenshot',
    }),
    'omit-background': Flags.boolean({
      description: 'Make background transparent (PNG only)',
      default: false,
    }),
    viewport: Flags.string({
      description: 'Set viewport size before screenshot (format: widthxheight)',
    }),
    scale: Flags.string({
      description: 'Device scale factor',
      options: ['css', 'device'],
      default: 'device',
    }),
  }

  static args = {
    filename: Args.string({
      description: 'Output filename',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Screenshot)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      // Set viewport if specified
      if (flags.viewport) {
        const [width, height] = flags.viewport.split('x').map(n => parseInt(n, 10))
        if (!isNaN(width) && !isNaN(height)) {
          this.log(`üìê Setting viewport to ${width}x${height}`)
          await this.page!.setViewportSize({ width, height })
        } else {
          this.warn('Invalid viewport format, ignoring viewport flag')
        }
      }

      this.log(`üì∏ Taking screenshot...`)

      // Ensure directory exists
      const dir = path.dirname(args.filename)
      if (dir && dir !== '.') {
        await fs.mkdir(dir, { recursive: true })
      }

      const screenshotOptions: any = {
        path: args.filename,
        fullPage: flags['full-page'],
        type: flags.format as 'png' | 'jpeg' | 'webp',
        scale: flags.scale as 'css' | 'device',
      }

      // Add quality for JPEG/WebP
      if (flags.format === 'jpeg' || flags.format === 'webp') {
        screenshotOptions.quality = flags.quality
      }

      // Add transparent background option for PNG
      if (flags.format === 'png' && flags['omit-background']) {
        screenshotOptions.omitBackground = true
      }

      // Take screenshot of specific element or full page
      if (flags.selector) {
        this.log(`üéØ Capturing element: ${flags.selector}`)
        const element = await this.page!.$(flags.selector)
        if (!element) {
          this.error(`Element not found: ${flags.selector}`)
        }
        await element!.screenshot(screenshotOptions)
      } else {
        await this.page!.screenshot(screenshotOptions)
      }

      const absolutePath = path.resolve(args.filename)
      const stats = await fs.stat(args.filename)
      const sizeMB = (stats.size / 1024 / 1024).toFixed(2)
      
      this.log(`‚úÖ Screenshot saved to: ${absolutePath}`)
      this.log(`üìä File size: ${sizeMB} MB`)

      // Log screenshot details if verbose
      if (flags.verbose) {
        const pageInfo = await this.page!.evaluate(() => ({
          title: document.title,
          url: window.location.href,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
          },
          documentSize: {
            width: document.documentElement.scrollWidth,
            height: document.documentElement.scrollHeight,
          },
        }))
        
        this.logVerbose('Screenshot details', {
          format: flags.format,
          fullPage: flags['full-page'],
          selector: flags.selector || 'page',
          ...pageInfo,
        })
      }
    } catch (error: any) {
      this.error(`Failed to take screenshot: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/select.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as inquirer from 'inquirer'
import * as clipboardy from 'clipboardy'

export default class Select extends BaseCommand {
  static description = 'Find and inspect elements by CSS selector'

  static examples = [
    '<%= config.bin %> <%= command.id %> button',
    '<%= config.bin %> <%= command.id %> "a[href]"',
    '<%= config.bin %> <%= command.id %> ".my-class" --attributes',
    '<%= config.bin %> <%= command.id %> button --interactive',
    '<%= config.bin %> <%= command.id %> "input[type=text]" --limit 10',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    attributes: Flags.boolean({
      char: 'a',
      description: 'Include element attributes in output',
      default: false,
    }),
    limit: Flags.integer({
      char: 'l',
      description: 'Limit number of results',
      default: 50,
    }),
    interactive: Flags.boolean({
      char: 'i',
      description: 'Interactively select an element and copy its selector to clipboard',
      default: false,
    }),
    visible: Flags.boolean({
      description: 'Only show visible elements',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector to find elements',
      required: true,
    }),
  }

  public async run(): Promise<void> {
    const { args, flags } = await this.parse(Select)

    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )

    if (!this.page) {
      this.error('No page available')
    }

    try {
      // First check if any elements exist
      const count = await this.page!.locator(args.selector).count()
      
      if (count === 0) {
        this.log(`‚ùå No elements found matching "${args.selector}"`)
        return
      }

      this.log(`üîç Found ${count} element(s) matching "${args.selector}"`)
      
      const limit = Math.min(count, flags.limit)
      if (count > flags.limit) {
        this.log(`üìä Showing first ${flags.limit} results (use --limit to change)`)
      }

      // Collect element information
      const elements = []
      for (let i = 0; i < limit; i++) {
        const locator = this.page!.locator(args.selector).nth(i)
        
        // Check visibility if flag is set
        if (flags.visible) {
          const isVisible = await locator.isVisible()
          if (!isVisible) continue
        }

        const elementInfo = await locator.evaluate((el, index) => {
          const rect = el.getBoundingClientRect()
          
          // Generate best selector for element
          function getBestSelector(element: Element): string {
            // Priority 1: ID
            if (element.id) {
              return '#' + element.id
            }
            
            // Priority 2: Unique class combination
            if (element.className) {
              const classes = element.className.split(' ').filter(c => c.trim())
              const validClasses = classes.filter(c => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c))
              
              if (validClasses.length > 0) {
                const firstClassSelector = '.' + validClasses[0]
                if (document.querySelectorAll(firstClassSelector).length === 1) {
                  return firstClassSelector
                }
                
                for (let i = 2; i <= Math.min(validClasses.length, 3); i++) {
                  const classSelector = '.' + validClasses.slice(0, i).join('.')
                  try {
                    if (document.querySelectorAll(classSelector).length === 1) {
                      return classSelector
                    }
                  } catch (e) {
                    // Invalid selector, skip
                  }
                }
              }
            }
            
            // Priority 3: Unique attribute
            const uniqueAttrs = ['name', 'type', 'placeholder', 'aria-label', 'data-testid']
            for (const attr of uniqueAttrs) {
              if (element.hasAttribute(attr)) {
                const value = element.getAttribute(attr)
                const selector = element.tagName.toLowerCase() + '[' + attr + '="' + value + '"]'
                if (document.querySelectorAll(selector).length === 1) {
                  return selector
                }
              }
            }
            
            // Priority 4: nth-of-type with parent context
            const parent = element.parentElement
            const siblings = parent ? Array.from(parent.children).filter(child => 
              child.tagName === element.tagName
            ) : []
            const indexInType = siblings.indexOf(element) + 1
            
            if (parent && parent.id) {
              return '#' + parent.id + ' > ' + element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
            }
            
            if (parent && parent.className) {
              const parentClasses = parent.className.split(' ').filter(c => c.trim())
              const validParentClasses = parentClasses.filter(c => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c))
              if (validParentClasses.length > 0) {
                return '.' + validParentClasses[0] + ' > ' + element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
              }
            }
            
            // Fallback: tag with index
            return element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
          }
          
          const info: any = {
            index: index,
            tagName: el.tagName.toLowerCase(),
            selector: getBestSelector(el),
            textContent: el.textContent?.trim().substring(0, 100) || '',
            visible: rect.width > 0 && rect.height > 0 && rect.top >= 0 && rect.left >= 0,
            position: {
              top: Math.round(rect.top),
              left: Math.round(rect.left),
              width: Math.round(rect.width),
              height: Math.round(rect.height),
            },
          }
          
          if (el.id) {
            info.id = el.id
          }
          
          if (el.className) {
            info.classes = el.className.split(' ').filter((c: string) => c.trim())
          }
          
          // Get attributes if requested
          const attrs: Record<string, string> = {}
          for (let i = 0; i < el.attributes.length; i++) {
            const attr = el.attributes[i]
            attrs[attr.name] = attr.value
          }
          info.attributes = attrs
          
          return info
        }, i)
        
        elements.push(elementInfo)
      }

      if (flags.interactive && elements.length > 0) {
        // Interactive mode - show selection menu
        const choices = elements.map((el: any) => {
          const visibilityIcon = el.visible ? '‚úì' : '‚úó'
          const text = el.textContent ? ` - "${el.textContent.substring(0, 50)}${el.textContent.length > 50 ? '...' : ''}"` : ''
          return {
            name: `[${el.index}] <${el.tagName}> ${visibilityIcon} ${el.selector}${text}`,
            value: el.selector,
            short: el.selector,
          }
        })
        
        const { selectedSelector } = await inquirer.prompt([
          {
            type: 'list',
            name: 'selectedSelector',
            message: 'Select an element to copy its selector:',
            choices,
            pageSize: 15,
          },
        ])
        
        try {
          await clipboardy.write(selectedSelector)
          this.log(`\n‚úÖ Copied selector to clipboard: ${selectedSelector}`)
        } catch (error) {
          this.log(`\n‚ùå Failed to copy to clipboard: ${selectedSelector}`)
          this.log('  You can manually copy the selector above')
        }
      } else {
        // Regular output mode
        this.log('---')
        
        for (const el of elements) {
          this.log(`[${el.index}] <${el.tagName}> ${el.visible ? '‚úì visible' : '‚úó hidden'}`)
          this.log(`  Selector: ${el.selector}`)
          
          if (el.id) {
            this.log(`  ID: ${el.id}`)
          }
          
          if (el.classes && el.classes.length > 0) {
            this.log(`  Classes: ${el.classes.join(', ')}`)
          }
          
          if (el.textContent) {
            this.log(`  Text: "${el.textContent}"`)
          }
          
          this.log(`  Position: ${el.position.left}x${el.position.top} (${el.position.width}x${el.position.height})`)
          
          if (flags.attributes && el.attributes && Object.keys(el.attributes).length > 0) {
            this.log('  Attributes:')
            for (const [key, value] of Object.entries(el.attributes)) {
              if (key !== 'id' && key !== 'class') {
                this.log(`    ${key}: "${value}"`)
              }
            }
          }
          
          this.log('')
        }
      }

      // Log summary if verbose
      if (flags.verbose) {
        const visibleCount = elements.filter((el: any) => el.visible).length
        this.logVerbose('Element summary', {
          total: count,
          shown: elements.length,
          visible: visibleCount,
          hidden: elements.length - visibleCount,
        })
      }
    } catch (error: any) {
      this.error(`Failed to select elements: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/type.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Type extends BaseCommand {
  static description = 'Type text into an element'

  static examples = [
    '<%= config.bin %> <%= command.id %> "input[name=email]" "user@example.com"',
    '<%= config.bin %> <%= command.id %> "#search-box" "search query" --clear-first',
    '<%= config.bin %> <%= command.id %> "textarea" "multi\\nline\\ntext" --press-enter',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'clear-first': Flags.boolean({
      description: 'Clear existing text before typing',
      default: false,
    }),
    delay: Flags.integer({
      description: 'Delay between key presses in milliseconds',
      default: 0,
    }),
    'wait-for-selector': Flags.boolean({
      description: 'Wait for selector to be available before typing',
      default: true,
    }),
    timeout: Flags.integer({
      description: 'Maximum time to wait for selector in milliseconds',
      default: 30000,
    }),
    'press-enter': Flags.boolean({
      description: 'Press Enter key after typing',
      default: false,
    }),
    'press-tab': Flags.boolean({
      description: 'Press Tab key after typing',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector of element to type into',
      required: true,
    }),
    text: Args.string({
      description: 'Text to type (use \\n for newlines)',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Type)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      if (flags['wait-for-selector']) {
        this.log(`‚è≥ Waiting for selector: ${args.selector}`)
        await waitForElement(this.page!, args.selector, { 
          timeout: flags.timeout,
          state: 'visible' 
        })
      }

      // Focus the element first
      await this.page!.focus(args.selector)

      if (flags['clear-first']) {
        this.log(`üßπ Clearing existing text in: ${args.selector}`)
        // Playwright's fill method clears by default, but for type we need to manually clear
        await this.page!.click(args.selector, { clickCount: 3 })
        await this.page!.keyboard.press('Delete')
      }

      // Process text to handle escape sequences
      const processedText = args.text.replace(/\\n/g, '\n').replace(/\\t/g, '\t')

      this.log(`‚å®Ô∏è  Typing into: ${args.selector}`)
      this.logVerbose('Type options', {
        text: processedText,
        delay: flags.delay,
        clearFirst: flags['clear-first'],
      })

      // Use type method for more natural typing with delay
      await this.page!.type(args.selector, processedText, {
        delay: flags.delay,
      })

      // Press additional keys if requested
      if (flags['press-enter']) {
        this.log('‚èé Pressing Enter')
        await this.page!.keyboard.press('Enter')
      }

      if (flags['press-tab']) {
        this.log('‚á• Pressing Tab')
        await this.page!.keyboard.press('Tab')
      }

      this.log(`‚úÖ Successfully typed text into: ${args.selector}`)

      // Log element value if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await this.page!.$eval(args.selector, (el: Element) => {
            const input = el as HTMLInputElement | HTMLTextAreaElement
            return {
              tagName: el.tagName.toLowerCase(),
              type: (el as HTMLInputElement).type || null,
              value: input.value || null,
              textContent: el.textContent?.trim().substring(0, 50),
            }
          })
          this.logVerbose('Element state after typing', elementInfo)
        } catch {
          // Element may not support value property
        }
      }
    } catch (error: any) {
      const commandError = handleCommandError(error, 'type', args.selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="test/unit-tests.js">
#!/usr/bin/env node

const { execSync } = require('child_process');
const assert = require('assert');

// Color codes
const GREEN = '\x1b[32m';
const RED = '\x1b[31m';
const YELLOW = '\x1b[33m';
const RESET = '\x1b[0m';

function log(message, color = RESET) {
  console.log(`${color}${message}${RESET}`);
}

function runTest(name, fn) {
  try {
    fn();
    log(`‚úì ${name}`, GREEN);
  } catch (error) {
    log(`‚úó ${name}`, RED);
    console.error(`  ${error.message}`);
    process.exit(1);
  }
}

log('Unit Tests - CLI Structure', YELLOW);
log('==========================', YELLOW);

// Test 1: CLI runs without error
runTest('CLI executable runs', () => {
  execSync('node ../bin/run.js --version', { encoding: 'utf8' });
});

// Test 2: Help command shows all commands
runTest('Help lists all commands', () => {
  const output = execSync('node ../bin/run.js --help', { encoding: 'utf8' });
  assert(output.includes('navigate'), 'navigate command not found');
  assert(output.includes('click'), 'click command not found');
  assert(output.includes('type'), 'type command not found');
  assert(output.includes('evaluate'), 'evaluate command not found');
  assert(output.includes('screenshot'), 'screenshot command not found');
  assert(output.includes('spawn'), 'spawn command not found');
  assert(output.includes('stop'), 'stop command not found');
});

// Test 3: Command help works
runTest('Navigate help works', () => {
  const output = execSync('node ../bin/run.js navigate --help', { encoding: 'utf8' });
  assert(output.includes('URL to navigate to'), 'URL argument not documented');
  assert(output.includes('--wait-until'), 'wait-until flag not documented');
});

// Test 4: Click help works
runTest('Click help works', () => {
  const output = execSync('node ../bin/run.js click --help', { encoding: 'utf8' });
  assert(output.includes('CSS selector'), 'selector argument not documented');
  assert(output.includes('--wait-for-selector'), 'wait-for-selector flag not documented');
});

// Test 5: Type help works
runTest('Type help works', () => {
  const output = execSync('node ../bin/run.js type --help', { encoding: 'utf8' });
  assert(output.includes('Text to type'), 'text argument not documented');
  assert(output.includes('--clear-first'), 'clear-first flag not documented');
});

// Test 6: Evaluate help works
runTest('Evaluate help works', () => {
  const output = execSync('node ../bin/run.js evaluate --help', { encoding: 'utf8' });
  assert(output.includes('JavaScript code'), 'script argument not documented');
});

// Test 7: Screenshot help works
runTest('Screenshot help works', () => {
  const output = execSync('node ../bin/run.js screenshot --help', { encoding: 'utf8' });
  assert(output.includes('Output filename'), 'filename argument not documented');
  assert(output.includes('--full-page'), 'full-page flag not documented');
});

// Test 8: Spawn help works
runTest('Spawn help works', () => {
  const output = execSync('node ../bin/run.js spawn --help', { encoding: 'utf8' });
  assert(output.includes('URL to open'), 'url argument not documented');
  assert(output.includes('--port'), 'port flag not documented');
  assert(output.includes('--headless'), 'headless flag not documented');
});

// Test 9: Stop help works
runTest('Stop help works', () => {
  const output = execSync('node ../bin/run.js stop --help', { encoding: 'utf8' });
  assert(output.includes('Stop the active Chrome'), 'stop description not found');
});

// Test 10: Launch flag is available
runTest('Launch flag available in all commands', () => {
  const commands = ['navigate', 'click', 'type', 'evaluate', 'screenshot'];
  commands.forEach(cmd => {
    const output = execSync(`node ../bin/run.js ${cmd} --help`, { encoding: 'utf8' });
    assert(output.includes('--launch'), `launch flag not found in ${cmd} command`);
  });
});

// Test 11: Error handling for missing arguments
runTest('Missing arguments show error', () => {
  try {
    execSync('node ../bin/run.js navigate 2>&1', { encoding: 'utf8', stdio: 'pipe' });
    throw new Error('Expected command to fail');
  } catch (error) {
    // The error should be thrown when missing required argument
    assert(error.status !== 0, 'Command should have non-zero exit status');
  }
});

log('\nAll unit tests passed! ‚úì', GREEN);
</file>

<file path="src/commands/click.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Click extends BaseCommand {
  static description = 'Click an element by CSS selector'

  static examples = [
    '<%= config.bin %> <%= command.id %> "button.submit"',
    '<%= config.bin %> <%= command.id %> "#login-button" --wait-for-selector',
    '<%= config.bin %> <%= command.id %> "a.link" --right-click',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'wait-for-selector': Flags.boolean({
      description: 'Wait for selector to be available before clicking',
      default: true,
    }),
    timeout: Flags.integer({
      description: 'Maximum time to wait for selector in milliseconds',
      default: 30000,
    }),
    'click-count': Flags.integer({
      description: 'Number of clicks',
      default: 1,
    }),
    button: Flags.string({
      description: 'Mouse button to use',
      options: ['left', 'right', 'middle'],
      default: 'left',
    }),
    'right-click': Flags.boolean({
      description: 'Perform a right-click instead of left-click',
      default: false,
    }),
    position: Flags.string({
      description: 'Click position relative to element (format: x,y)',
    }),
    modifiers: Flags.string({
      description: 'Modifier keys to press during click (comma-separated: Alt,Control,Meta,Shift)',
    }),
    force: Flags.boolean({
      description: 'Force click even if element is obscured',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector of element to click',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Click)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      if (flags['wait-for-selector']) {
        this.log(`‚è≥ Waiting for selector: ${args.selector}`)
        await waitForElement(this.page!, args.selector, { timeout: flags.timeout })
      }

      // Parse click options
      const clickOptions: any = {
        clickCount: flags['click-count'],
        button: flags['right-click'] ? 'right' : flags.button as 'left' | 'right' | 'middle',
        force: flags.force,
      }

      // Parse position if provided
      if (flags.position) {
        const [x, y] = flags.position.split(',').map(n => parseInt(n.trim(), 10))
        if (!isNaN(x) && !isNaN(y)) {
          clickOptions.position = { x, y }
          this.logVerbose('Click position', { x, y })
        } else {
          this.warn('Invalid position format, ignoring position flag')
        }
      }

      // Parse modifiers if provided
      if (flags.modifiers) {
        clickOptions.modifiers = flags.modifiers
          .split(',')
          .map(m => m.trim())
          .filter(m => ['Alt', 'Control', 'Meta', 'Shift'].includes(m))
        if (clickOptions.modifiers.length > 0) {
          this.logVerbose('Click modifiers', clickOptions.modifiers)
        }
      }

      this.log(`üñ±Ô∏è  Clicking on: ${args.selector}`)
      this.logVerbose('Click options', clickOptions)

      await this.page!.click(args.selector, clickOptions)
      
      this.log(`‚úÖ Successfully clicked on: ${args.selector}`)

      // Log element info if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await this.page!.$eval(args.selector, (el: Element) => {
            const rect = el.getBoundingClientRect()
            return {
              tagName: el.tagName.toLowerCase(),
              text: el.textContent?.trim().substring(0, 50),
              classList: Array.from(el.classList),
              position: { x: rect.x, y: rect.y },
              size: { width: rect.width, height: rect.height },
            }
          })
          this.logVerbose('Clicked element info', elementInfo)
        } catch {
          // Element may have been removed after click
        }
      }
    } catch (error: any) {
      const commandError = handleCommandError(error, 'click', args.selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/spawn.ts">
import { Args, Command, Flags } from '@oclif/core'
import { chromium } from 'playwright'
import * as net from 'net'
import * as path from 'path'
import * as os from 'os'
import { SessionManager } from '../session.js'

export default class Spawn extends Command {
  static description = 'Spawn a Chrome browser instance with remote debugging'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> https://example.com --port 9223',
    '<%= config.bin %> <%= command.id %> https://example.com --headless',
    '<%= config.bin %> <%= command.id %> --profile work  # Opens with work profile',
    '<%= config.bin %> <%= command.id %> --headless  # Opens about:blank in headless mode',
  ]

  static flags = {
    port: Flags.integer({
      char: 'p',
      description: 'Remote debugging port',
      default: 9222,
    }),
    headless: Flags.boolean({
      description: 'Run Chrome in headless mode',
      default: false,
    }),
    profile: Flags.string({
      description: 'Chrome profile name or path to use',
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to open in Chrome',
      required: false,
      default: 'about:blank',
    }),
  }

  private getProfilePath(profileName: string): string {
    // If it's already an absolute path, use it
    if (path.isAbsolute(profileName)) {
      return profileName
    }

    // Otherwise, create profile in user's home directory
    const platform = process.platform
    let profileBase: string

    if (platform === 'win32') {
      profileBase = path.join(os.homedir(), 'AppData', 'Local', 'chromancer', 'profiles')
    } else if (platform === 'darwin') {
      profileBase = path.join(os.homedir(), 'Library', 'Application Support', 'chromancer', 'profiles')
    } else {
      profileBase = path.join(os.homedir(), '.config', 'chromancer', 'profiles')
    }

    return path.join(profileBase, profileName)
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Spawn)
    
    try {
      this.log(`üöÄ Launching Chrome with remote debugging on port ${flags.port}...`)
      
      const launchOptions: any = {
        headless: flags.headless,
        args: [
          `--remote-debugging-port=${flags.port}`,
          '--no-first-run',
          '--no-default-browser-check',
        ],
        channel: 'chrome',
        // Keep browser running after script ends
        handleSIGINT: false,
        handleSIGTERM: false,
        handleSIGHUP: false,
      }
      
      // Add profile support
      if (flags.profile) {
        const profilePath = this.getProfilePath(flags.profile)
        this.log(`üìÅ Using Chrome profile: ${profilePath}`)
        launchOptions.args.push(`--user-data-dir=${profilePath}`)
      }
      
      const browser = await chromium.launch(launchOptions)
      const context = browser.contexts()[0] || await browser.newContext()
      const page = context.pages()[0] || await context.newPage()
      
      // Navigate to the specified URL
      if (args.url && args.url !== 'about:blank') {
        await page.goto(args.url)
      }
      
      // Playwright doesn't expose wsEndpoint directly, but we can use the port
      const wsEndpoint = `ws://localhost:${flags.port}`
      
      this.log(`‚úÖ Chrome launched successfully!`)
      this.log(`üîó Remote debugging URL: http://localhost:${flags.port}`)
      this.log(`üîå WebSocket endpoint: ${wsEndpoint}`)
      
      if (flags.profile) {
        this.log(`üìÅ Profile: ${flags.profile}`)
      }
      
      this.log(`\nüí° To connect from another terminal:`)
      this.log(`   chromancer navigate https://example.com --port ${flags.port}`)
      this.log(`   chromancer click "#button" --port ${flags.port}`)
      
      this.log(`\n‚åõ Chrome will stay open. Press Ctrl+C to close.`)
      
      // Keep the process alive
      process.on('SIGINT', async () => {
        this.log('\nüîí Closing Chrome...')
        await browser.close()
        process.exit(0)
      })
      
      // Prevent the process from exiting
      await new Promise(() => {})
    } catch (error: any) {
      this.error(`Failed to spawn Chrome: ${error.message}`)
    }
  }
}
</file>

<file path=".claude/settings.local.json">
{
  "permissions": {
    "allow": [
      "Read",
      "Edit",
      "Bash(open:*)",
      "Bash(pnpm run:*)",
      "Bash(node:*)",
      "Bash(gh:*)",
      "Bash(git:*)",
      "Bash(git add:*)",
      "Bash(git commit:*)",
      "Bash(curl:*)",
      "Bash(./verify-all.sh:*)",
      "Bash(ls:*)",
      "Bash(npm run build:*)",
      "Bash(npm test)",
      "Bash(npx:*)",
      "Bash(npm pack:*)",
      "Bash(mkdir:*)",
      "Bash(rm:*)",
      "Bash(npm:*)",
      "Bash(chromancer:*)",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js --version)",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js --help)",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js spawn)",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js navigate https://www.google.com)",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js type 'textarea[name=\"q\"]' \"hello world\")",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js click 'input[name=\"btnK\"]')",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js evaluate \"Array.from(document.querySelectorAll('h3')).slice(0, 5).map(h => h.textContent).filter(Boolean)\")",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js evaluate \"window.location.href\")",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js navigate \"https://www.google.com/search?q=hello+world\")",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js evaluate \"Array.from(document.querySelectorAll('h3')).slice(0, 5).map(h => ({title: h.textContent, link: h.closest('a')?.href})).filter(item => item.title)\")",
      "Bash(/Users/johnlindquist/Library/pnpm/nodejs/22.15.1/lib/node_modules/chromancer/bin/run.js screenshot google-search-results.png)",
      "Bash(pnpm uninstall:*)",
      "Bash(pnpm install:*)",
      "Bash(grep:*)"
    ],
    "deny": []
  }
}
</file>

<file path="src/base.ts">
import { Command, Flags } from '@oclif/core'
import { chromium, Browser, Page, BrowserContext } from 'playwright'
import { SessionManager } from './session.js'
import * as path from 'path'
import * as os from 'os'
import { displayErrorWithTip, enhanceError } from './utils/error-tips.js'

export abstract class BaseCommand extends Command {
  static baseFlags = {
    port: Flags.integer({
      char: 'p',
      description: 'Chrome debugging port',
      default: 9222,
    }),
    host: Flags.string({
      char: 'h',
      description: 'Chrome debugging host',
      default: 'localhost',
    }),
    launch: Flags.boolean({
      char: 'l',
      description: 'Launch Chrome automatically',
      default: false,
    }),
    profile: Flags.string({
      description: 'Chrome profile name or path to use',
    }),
    headless: Flags.boolean({
      description: 'Run Chrome in headless mode',
      default: false,
    }),
    verbose: Flags.boolean({
      char: 'v',
      description: 'Enable verbose logging for debugging',
      default: false,
    }),
    keepOpen: Flags.boolean({
      char: 'k',
      description: 'Keep Chrome open after command completes',
      default: true,
      allowNo: true,
    }),
  }

  protected browser?: Browser
  protected context?: BrowserContext
  protected page?: Page
  private isLaunched = false
  protected verbose = false
  private keepOpen = false

  protected logVerbose(message: string, data?: any): void {
    if (this.verbose) {
      const timestamp = new Date().toISOString()
      const prefix = `[${timestamp}] [VERBOSE]`
      if (data) {
        this.log(`${prefix} ${message}`, JSON.stringify(data, null, 2))
      } else {
        this.log(`${prefix} ${message}`)
      }
    }
  }

  private getProfilePath(profileName: string): string {
    // If it's already an absolute path, use it
    if (path.isAbsolute(profileName)) {
      return profileName
    }

    // Otherwise, create profile in user's home directory
    const platform = process.platform
    let profileBase: string

    if (platform === 'win32') {
      profileBase = path.join(os.homedir(), 'AppData', 'Local', 'chromancer', 'profiles')
    } else if (platform === 'darwin') {
      profileBase = path.join(os.homedir(), 'Library', 'Application Support', 'chromancer', 'profiles')
    } else {
      profileBase = path.join(os.homedir(), '.config', 'chromancer', 'profiles')
    }

    return path.join(profileBase, profileName)
  }

  async connectToChrome(
    port: number = 9222,
    host: string = 'localhost',
    launch: boolean = false,
    profile?: string,
    headless: boolean = false,
    verbose: boolean = false,
    keepOpen: boolean = true
  ): Promise<void> {
    this.verbose = verbose
    this.keepOpen = keepOpen
    const startTime = Date.now()
    
    this.logVerbose('Starting Chrome connection process', { port, host, launch, profile, headless })
    
    const browserURL = `http://${host}:${port}`
    
    try {
      // First try to connect to existing Chrome instance
      this.log(`üîç Attempting to connect to Chrome at ${browserURL}...`)
      
      this.browser = await chromium.connectOverCDP(browserURL)
      this.context = this.browser.contexts()[0]
      
      this.log('‚úÖ Connected to existing Chrome instance')
      this.logVerbose(`Connection successful in ${Date.now() - startTime}ms`)
    } catch (connectError: any) {
      this.log(`‚ùå No existing Chrome instance found at ${browserURL}`)
      this.logVerbose('Connection failed', { error: connectError.message })
      
      if (launch) {
        try {
          this.log('üöÄ Launching new Chrome instance...')
          
          const launchOptions: any = {
            headless,
            args: [
              `--remote-debugging-port=${port}`,
              '--no-first-run',
              '--no-default-browser-check',
            ],
            channel: 'chrome',
          }
          
          // Add profile support
          if (profile) {
            const profilePath = this.getProfilePath(profile)
            this.log(`üìÅ Using Chrome profile: ${profilePath}`)
            launchOptions.args.push(`--user-data-dir=${profilePath}`)
          }
          
          this.browser = await chromium.launch(launchOptions)
          this.context = await this.browser.newContext()
          this.isLaunched = true
          
          this.log(`‚úÖ Chrome launched successfully${profile ? ` with profile "${profile}"` : ''}`)
          this.logVerbose(`Chrome launched in ${Date.now() - startTime}ms`)
        } catch (launchError: any) {
          this.error(`Failed to launch Chrome: ${launchError.message}`)
        }
      } else {
        this.error(`Failed to connect to Chrome at ${host}:${port}. 

Possible solutions:
1. Use --launch flag to start a new Chrome instance
2. Use 'chromancer spawn' to start a persistent Chrome instance
3. Start Chrome manually with: chrome --remote-debugging-port=${port}`)
      }
    }

    if (this.browser && this.context) {
      // Get or create a page
      const pages = this.context.pages()
      this.page = pages[0] || await this.context.newPage()
      
      this.logVerbose('Page setup complete', { 
        totalPages: pages.length,
        newPageCreated: pages.length === 0
      })
      
      const totalTime = Date.now() - startTime
      this.logVerbose(`Total connection time: ${totalTime}ms`)
    }
  }

  async waitForLogin(url: string, readySelector?: string): Promise<void> {
    if (!this.page) {
      this.error('No page available')
    }

    this.log(`üîê Navigating to ${url}...`)
    await this.page!.goto(url, { waitUntil: 'domcontentloaded' })
    
    const checkSelector = readySelector || 'body'
    
    this.log(`‚è≥ Waiting for you to log in...`)
    this.log(`   (Looking for element: ${checkSelector})`)
    this.log(`   Press Ctrl+C to cancel`)
    
    // Check if already logged in
    try {
      await this.page!.waitForSelector(checkSelector, { timeout: 1000 })
      this.log('‚úÖ Already logged in!')
      return
    } catch {
      // Not logged in yet, continue waiting
    }
    
    // Wait for login with visual feedback
    let dots = 0
    const loadingInterval = setInterval(() => {
      process.stdout.write(`\r‚è≥ Waiting for login${'.'.repeat(dots % 4)}    `)
      dots++
    }, 500)
    
    try {
      // Wait for either the ready selector or a common logged-in indicator
      await this.page!.waitForSelector(checkSelector, { timeout: 300000 }) // 5 minute timeout
      
      clearInterval(loadingInterval)
      process.stdout.write('\r')
      this.log('‚úÖ Login detected! Continuing...')
      
      // Give the page a moment to fully load after login
      await this.page!.waitForLoadState('networkidle')
    } catch (error: any) {
      clearInterval(loadingInterval)
      process.stdout.write('\r')
      if (error.name === 'TimeoutError') {
        this.error('Timeout waiting for login (5 minutes)')
      }
      throw error
    }
  }

  /**
   * Enhanced error handler
   */
  protected handleError(error: Error | string): never {
    const err = typeof error === 'string' ? new Error(error) : error
    
    // Display error with tips if not in JSON mode
    if (!this.jsonEnabled()) {
      displayErrorWithTip(err, this.constructor.name.toLowerCase())
    }
    
    // Call parent error method
    this.exit(1)
  }

  /**
   * Log error with tips but don't exit
   */
  protected logError(error: Error, command?: string): void {
    if (!this.jsonEnabled()) {
      displayErrorWithTip(error, command || this.constructor.name.toLowerCase())
    } else {
      this.logToStderr(error.message)
    }
  }

  async finally(): Promise<void> {
    if (this.browser) {
      if (this.isLaunched) {
        if (this.keepOpen) {
          this.log('üîì Keeping Chrome open (use --no-keepOpen to close automatically)')
          // Just disconnect, don't close the browser
          // Just disconnect by not closing the browser
          // Browser remains open
        } else {
          this.log('üîí Closing Chrome...')
          await this.browser.close()
        }
      } else {
        // Was connected to existing instance, just disconnect
        // Browser remains open
      }
    }
  }
}
</file>

<file path="package.json">
{
  "name": "chromancer",
  "version": "1.0.0",
  "description": "Command-line interface for Chrome automation using DevTools Protocol",
  "main": "dist/index.js",
  "bin": {
    "chromancer": "./bin/run.js"
  },
  "scripts": {
    "build": "tsc",
    "clean": "rm -rf dist",
    "prepack": "npm run clean && npm run build",
    "test": "node test/unit-tests.js",
    "test:vitest": "vitest",
    "test:vitest:ui": "vitest --ui",
    "test:vitest:run": "vitest run",
    "test:server": "node test/test-server.js",
    "prepublishOnly": "npm run clean && npm run build && npm test"
  },
  "keywords": [
    "chrome",
    "chromium",
    "devtools",
    "cdp",
    "automation",
    "scraping",
    "browser",
    "cli",
    "playwright",
    "testing",
    "web-automation"
  ],
  "author": "John Lindquist",
  "license": "MIT",
  "homepage": "https://github.com/johnlindquist/chromancer#readme",
  "repository": {
    "type": "git",
    "url": "git+https://github.com/johnlindquist/chromancer.git"
  },
  "bugs": {
    "url": "https://github.com/johnlindquist/chromancer/issues"
  },
  "engines": {
    "node": ">=18.0.0"
  },
  "dependencies": {
    "@oclif/core": "^4.3.1",
    "@oclif/plugin-help": "^6.2.28",
    "@types/inquirer": "^8.2.11",
    "@types/node": "^22.15.29",
    "chalk": "^5.4.1",
    "clipboardy": "^2.3.0",
    "inquirer": "^8.2.6",
    "inquirer-autocomplete-prompt": "^3.0.1",
    "oclif": "^4.18.0",
    "playwright": "^1.52.0",
    "typescript": "^5.8.3",
    "yaml": "^2.8.0"
  },
  "oclif": {
    "bin": "chromancer",
    "dirname": "chromancer",
    "commands": "./dist/commands",
    "plugins": [
      "@oclif/plugin-help"
    ]
  },
  "files": [
    "/bin",
    "/dist",
    "/oclif.manifest.json"
  ],
  "devDependencies": {
    "@vitest/ui": "^3.2.3",
    "express": "^5.1.0",
    "serve-static": "^2.2.0",
    "vitest": "^3.2.3"
  }
}
</file>

<file path="README.md">
# Chromancer

[![npm version](https://badge.fury.io/js/chromancer.svg)](https://www.npmjs.com/package/chromancer)
[![License: MIT](https://img.shields.io/badge/License-MIT-yellow.svg)](https://opensource.org/licenses/MIT)
[![Node.js Version](https://img.shields.io/node/v/chromancer.svg)](https://nodejs.org)

A command-line interface for automating Chrome browser using the Chrome DevTools Protocol. Perfect for web scraping, automation, and testing.

## Features

- üöÄ Spawn Chrome instances with automatic port management
- üîÑ Session management - all commands work with your active Chrome instance
- üéÆ **Interactive REPL mode** - Execute commands interactively with autocomplete and history
- üåê Navigate to URLs with various wait conditions
- üñ±Ô∏è Click elements using CSS selectors
- ‚å®Ô∏è Type text into input fields
- üîç Find and inspect elements with detailed information
- üìú Execute JavaScript in page context
- üì∏ Take screenshots (full page or viewport)
- üõë Gracefully stop Chrome instances

## Requirements

- Node.js 18.0.0 or higher
- Chrome or Chromium browser installed
- **Windows Users**: Chrome must be installed in the default location or available in PATH

## Installation

### Global Installation (Recommended)

```bash
npm install -g chromancer
```

After installation, you can use `chromancer` from anywhere:

```bash
chromancer spawn https://example.com
chromancer screenshot page.png
chromancer stop
```

### Local Installation

```bash
npm install chromancer
```

Then use with npx:

```bash
npx chromancer spawn https://example.com
```

### Development Setup

```bash
git clone https://github.com/johnlindquist/chromancer.git
cd chromancer
npm install
npm run build
```

## Quick Start

The easiest way to get started is using the `spawn` command:

```bash
# Check version
chromancer --version
```

Then spawn Chrome:

```bash
# Spawn Chrome and open a URL
chromancer spawn https://example.com

# Spawn Chrome in headless mode
chromancer spawn https://example.com --headless

# Spawn Chrome on a specific port
chromancer spawn https://example.com --port 9223
```

The spawn command automatically:
- Finds an available port (defaults to 9222, falls back to 9223-9232)
- Launches Chrome with remote debugging enabled
- Opens the specified URL (or about:blank if none provided)
- Displays the DevTools connection URL
- **Creates an active session that subsequent commands will use automatically**

## Session Management

When you use `spawn`, it creates an active session. All subsequent commands will automatically connect to this Chrome instance without needing to specify the port:

```bash
# Start a session
chromancer spawn https://example.com

# These commands automatically use the spawned Chrome
chromancer navigate https://github.com
chromancer screenshot page.png
chromancer evaluate "document.title"

# Stop the Chrome instance
chromancer stop
```

## Usage

### Spawn Chrome

```bash
# Basic usage
chromancer spawn https://example.com

# With options
chromancer spawn https://example.com --headless
chromancer spawn https://example.com --port 9223
chromancer spawn --user-data-dir /tmp/chrome-profile
```

### Stop Chrome

```bash
# Stop the active Chrome session
chromancer stop
```

### Navigate to a URL

```bash
chromancer navigate https://example.com
chromancer navigate https://example.com --wait-until networkidle0
```

### Click an element

```bash
chromancer click "button.submit"
chromancer click "#login-button" --wait-for-selector
```

### Type text

```bash
chromancer type "input[name=email]" "user@example.com"
chromancer type "#search-box" "search query" --clear-first
```

### Select elements

```bash
chromancer select "button"
chromancer select "a[href]" --attributes
chromancer select ".my-class" --limit 10
chromancer select "button" --interactive
```

The select command finds elements matching a CSS selector and provides:
- A unique selector for each element that can be used with click/type commands
- Element visibility status
- Text content, position, and dimensions
- HTML attributes (with --attributes flag)
- Interactive mode (with --interactive flag) to select an element and copy its selector to clipboard

### Execute JavaScript

```bash
chromancer evaluate "document.title"
chromancer evaluate "document.querySelectorAll('a').length"
```

### Take screenshot

```bash
chromancer screenshot screenshot.png
chromancer screenshot fullpage.png --full-page
```

### Interactive Mode (REPL)

Start an interactive session where you can execute commands without reconnecting to Chrome each time:

```bash
# Start interactive mode
chromancer interactive
# or use the alias
chromancer session

# With options
chromancer interactive --launch
chromancer session --port 9223
```

In interactive mode:
- Tab completion for commands
- Command history (up/down arrows)
- Persistent Chrome connection
- Type `help` for available commands
- Type `exit` to quit

Interactive commands:
- `navigate <url>` - Navigate to URL
- `click <selector>` - Click element
- `type <selector> <text>` - Type text
- `evaluate <js>` - Execute JavaScript
- `screenshot [filename]` - Take screenshot
- `select <selector>` - Find elements
- `back/forward/reload` - Browser navigation
- `url/title` - Get page info
- `viewport [width] [height]` - Get/set viewport
- `cookies` - List cookies
- `help` - Show commands
- `clear` - Clear console
- `exit` - Exit session

## Global Options

All commands (except spawn and stop) support these options:

- `-p, --port <number>` - Chrome debugging port (uses active session by default)
- `-h, --host <string>` - Chrome debugging host (default: localhost)
- `-l, --launch` - Launch Chrome automatically if not running

## Example Workflow

```bash
# Spawn Chrome with session
chromancer spawn https://github.com

# Take a screenshot (automatically uses the spawned Chrome)
chromancer screenshot github-home.png

# Find search elements
chromancer select "input"

# Search for something
chromancer type "input[name=q]" "oclif" --clear-first
chromancer click "button[type=submit]"

# Count search results
chromancer evaluate "document.querySelectorAll('.repo-list-item').length"

# Stop Chrome when done
chromancer stop
```

### Tutorial: Automating Google Search

This tutorial shows how to search Google using chromancer in headed mode, which allows you to interact with any CAPTCHAs that may appear:

```bash
# Step 1: Spawn Chrome in headed mode (not headless) so you can see and interact with it
chromancer spawn

# Step 2: Navigate to Google
chromancer navigate https://www.google.com

# Step 3: Type your search query
chromancer type 'textarea[name="q"]' "hello world"

# Step 4: Submit the search (using JavaScript since the button might be hidden)
chromancer evaluate "document.querySelector('textarea[name=\"q\"]').form.submit()"

# Step 5: If a CAPTCHA appears, solve it manually in the browser window

# Step 6: Once past any CAPTCHA, get the search results
chromancer evaluate "Array.from(document.querySelectorAll('h3')).slice(0, 5).map(h => h.textContent).filter(Boolean)"

# Step 7: Take a screenshot of the results
chromancer screenshot google-results.png

# Step 8: Stop Chrome when done
chromancer stop
```

**Important Notes:**
- Use headed mode (don't use `--headless`) so you can interact with CAPTCHAs
- Google often shows CAPTCHAs for automated browsers
- After solving the CAPTCHA manually, continue with the remaining commands
- The search results selector may vary based on Google's current HTML structure

### Alternative: Connect to existing Chrome

If you already have Chrome running with remote debugging enabled:

```bash
# Use the CLI commands with the specific port
chromancer navigate https://example.com --port 9222
```

### Platform-Specific Notes

#### Windows
- Chrome is automatically detected in common installation paths
- The CLI will check the Windows Registry for Chrome location
- Process management uses Windows-specific commands (taskkill)
- Use `.bat` scripts instead of `.sh` scripts for testing

#### macOS
- Supports Chrome, Chromium, and Chrome Canary
- Looks for applications in /Applications folder

#### Linux
- Checks common package manager installation paths
- Supports snap packages (/snap/bin/chromium)

## Testing

### Unit Tests

Run unit tests to verify CLI structure:

```bash
node test/unit-tests.js
```

### Integration Tests

For full integration testing with Chrome:

```bash
# Option 1: Use spawn command
chromancer spawn --headless
node test/test-suite.js

# Option 2: Use Docker Chrome
docker run -d --name chrome-test -p 9222:9222 zenika/alpine-chrome \
  --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222
node test/test-suite.js
docker stop chrome-test && docker rm chrome-test

# Option 3: Auto-launch Chrome with any command
chromancer navigate https://example.com --launch
```

### Mock Server Test

Test basic connectivity without Chrome:

```bash
node test/mock-chrome-test.js
```

## Troubleshooting

### Chrome not found

If Chromancer can't find Chrome, you can:

1. Make sure Chrome or Chromium is installed
2. Add Chrome to your PATH
3. Use the spawn command which will auto-detect Chrome location

### Port already in use

If the default port (9222) is in use:

```bash
# Use a different port
chromancer spawn --port 9223

# Or stop any existing session
chromancer stop
```

### Permission denied

On Linux/macOS, you might need to make the binary executable:

```bash
chmod +x $(which chromancer)
```

### Debugging connection issues

Use the `--verbose` flag to get detailed logging information:

```bash
# Debug navigation timeouts
chromancer navigate https://example.com --verbose

# Debug connection problems
chromancer spawn --verbose

# See detailed information about page loading
chromancer navigate https://slow-site.com --verbose --timeout 60000
```

The verbose flag provides:
- Detailed connection timing and browser information
- All network requests and responses during navigation
- Page load events and performance metrics
- Error details with stack traces
- Console messages from the page

## Contributing

1. Fork the repository
2. Create your feature branch (`git checkout -b feature/amazing-feature`)
3. Commit your changes (`git commit -m 'Add some amazing feature'`)
4. Push to the branch (`git push origin feature/amazing-feature`)
5. Open a Pull Request

## License

MIT ¬© John Lindquist
</file>

</files>
