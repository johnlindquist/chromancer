This file is a merged representation of a subset of the codebase, containing specifically included files, combined into a single document by Repomix.

<file_summary>
This section contains a summary of this file.

<purpose>
This file contains a packed representation of the entire repository's contents.
It is designed to be easily consumable by AI systems for analysis, code review,
or other automated processes.
</purpose>

<file_format>
The content is organized as follows:
1. This summary section
2. Repository information
3. Directory structure
4. Repository files (if enabled)
5. Multiple file entries, each consisting of:
  - File path as an attribute
  - Full contents of the file
</file_format>

<usage_guidelines>
- This file should be treated as read-only. Any changes should be made to the
  original repository files, not this packed version.
- When processing this file, use the file path to distinguish
  between different files in the repository.
- Be aware that this file may contain sensitive information. Handle it with
  the same level of security as you would the original repository.
</usage_guidelines>

<notes>
- Some files may have been excluded based on .gitignore rules and Repomix's configuration
- Binary files are not included in this packed representation. Please refer to the Repository Structure section for a complete list of file paths, including binary files
- Only files matching these patterns are included: src
- Files matching patterns in .gitignore are excluded
- Files matching default ignore patterns are excluded
- Files are sorted by Git change count (files with more changes are at the bottom)
</notes>

</file_summary>

<directory_structure>
src/
  commands/
    assert.ts
    click.ts
    config.ts
    cookies.ts
    evaluate.ts
    examples.ts
    export.ts
    fill.ts
    go.ts
    hover.ts
    init.ts
    interactive.ts
    navigate.ts
    network.ts
    pdf.ts
    quick.ts
    record.ts
    repl.ts
    run.ts
    screenshot.ts
    scroll.ts
    select.ts
    sessions.ts
    shot.ts
    spawn.ts
    stop.ts
    store.ts
    type.ts
    wait-for-login.ts
    wait.ts
  types/
    inquirer-autocomplete-prompt.d.ts
    schema.ts
  utils/
    config.ts
    error-tips.ts
    errors.ts
    evaluation.ts
    progress.ts
    selectors.ts
  base.ts
  session.ts
</directory_structure>

<files>
This section contains the contents of the repository's files.

<file path="src/commands/config.ts">
import { Args, Flags } from '@oclif/core'
import { Command } from '@oclif/core'
import { config } from '../utils/config.js'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
}

export default class Config extends Command {
  static description = 'Manage chromancer configuration'

  static examples = [
    '<%= config.bin %> <%= command.id %> get chrome.port',
    '<%= config.bin %> <%= command.id %> set chrome.port 9223',
    '<%= config.bin %> <%= command.id %> set ui.colorOutput false',
    '<%= config.bin %> <%= command.id %> list',
    '<%= config.bin %> <%= command.id %> reset',
  ]

  static args = {
    action: Args.string({
      description: 'Config action',
      required: true,
      options: ['get', 'set', 'list', 'reset', 'path'],
    }),
    key: Args.string({
      description: 'Configuration key (e.g., chrome.port)',
    }),
    value: Args.string({
      description: 'Value to set',
    }),
  }

  static flags = {
    json: Flags.boolean({
      description: 'Output in JSON format',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Config)
    
    switch (args.action) {
      case 'get':
        await this.getConfig(args.key!, flags.json)
        break
        
      case 'set':
        await this.setConfig(args.key!, args.value!)
        break
        
      case 'list':
        await this.listConfig(flags.json)
        break
        
      case 'reset':
        await this.resetConfig()
        break
        
      case 'path':
        this.showPath()
        break
        
      default:
        this.error(`Unknown action: ${args.action}`)
    }
  }

  private async getConfig(key: string, json: boolean): Promise<void> {
    if (!key) {
      this.error('Key is required for get action')
    }
    
    const value = await config.get(key)
    
    if (value === undefined) {
      this.warn(`Configuration key not found: ${key}`)
      return
    }
    
    if (json) {
      console.log(JSON.stringify(value))
    } else {
      console.log(`${chalk.cyan(key)}: ${JSON.stringify(value, null, 2)}`)
    }
  }

  private async setConfig(key: string, value: string): Promise<void> {
    if (!key || !value) {
      this.error('Key and value are required for set action')
    }
    
    // Try to parse value as JSON
    let parsedValue: any = value
    try {
      parsedValue = JSON.parse(value)
    } catch {
      // Keep as string if not valid JSON
    }
    
    await config.set(key, parsedValue)
    console.log(chalk.green(`‚úÖ Set ${key} = ${JSON.stringify(parsedValue)}`))
  }

  private async listConfig(json: boolean): Promise<void> {
    const configData = await config.load()
    
    if (json) {
      console.log(JSON.stringify(configData, null, 2))
    } else {
      console.log(chalk.cyan('\nüìã Current Configuration:\n'))
      this.printConfig(configData)
    }
  }

  private printConfig(obj: any, prefix = ''): void {
    Object.entries(obj).forEach(([key, value]) => {
      const fullKey = prefix ? `${prefix}.${key}` : key
      
      if (typeof value === 'object' && value !== null && !Array.isArray(value)) {
        console.log(chalk.blue(`${fullKey}:`))
        this.printConfig(value, fullKey)
      } else {
        console.log(`  ${chalk.gray(fullKey)}: ${JSON.stringify(value)}`)
      }
    })
  }

  private async resetConfig(): Promise<void> {
    console.log(chalk.yellow('‚ö†Ô∏è  This will reset all configuration to defaults'))
    
    // Simple confirmation
    console.log('\nPress Enter to confirm or Ctrl+C to cancel')
    await new Promise(resolve => {
      process.stdin.once('data', resolve)
      process.stdin.resume()
    })
    
    await config.reset()
    console.log(chalk.green('‚úÖ Configuration reset to defaults'))
  }

  private showPath(): void {
    console.log(chalk.cyan('üìÅ Config file location:'))
    console.log(config.getConfigPath())
  }
}
</file>

<file path="src/commands/cookies.ts">
import { Args, Flags } from '@oclif/core'
import { Page, Cookie } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

export default class Cookies extends BaseCommand {
  static description = 'Manage browser cookies'

  static examples = [
    '<%= config.bin %> <%= command.id %> list',
    '<%= config.bin %> <%= command.id %> get sessionId',
    '<%= config.bin %> <%= command.id %> set name=value',
    '<%= config.bin %> <%= command.id %> delete sessionId',
    '<%= config.bin %> <%= command.id %> clear',
    '<%= config.bin %> <%= command.id %> save --output cookies.json',
    '<%= config.bin %> <%= command.id %> load --file cookies.json',
  ]

  static args = {
    action: Args.string({
      description: 'Cookie action',
      options: ['list', 'get', 'set', 'delete', 'clear', 'save', 'load'],
      required: true,
    }),
    value: Args.string({
      description: 'Cookie name or name=value pair',
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output file for save action',
      default: 'cookies.json',
    }),
    file: Flags.string({
      char: 'f',
      description: 'Input file for load action',
    }),
    domain: Flags.string({
      description: 'Cookie domain',
    }),
    path: Flags.string({
      description: 'Cookie path',
      default: '/',
    }),
    secure: Flags.boolean({
      description: 'Secure cookie flag',
      default: false,
    }),
    httpOnly: Flags.boolean({
      description: 'HttpOnly cookie flag',
      default: false,
    }),
    sameSite: Flags.string({
      description: 'SameSite cookie attribute',
      options: ['Strict', 'Lax', 'None'],
    }),
    expires: Flags.integer({
      description: 'Cookie expiration timestamp',
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Cookies)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page || !this.context) {
      this.error('Failed to connect to Chrome')
    }

    await this.manageCookies(this.page!, args.action, args.value)
  }

  private async manageCookies(page: Page, action: string, value?: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    
    switch (action) {
      case 'list':
        await this.listCookies(page)
        break
        
      case 'get':
        if (!value) this.error('Cookie name required for get action')
        await this.getCookie(page, value)
        break
        
      case 'set':
        if (!value) this.error('Cookie data required for set action (name=value)')
        await this.setCookie(page, value)
        break
        
      case 'delete':
        if (!value) this.error('Cookie name required for delete action')
        await this.deleteCookie(page, value)
        break
        
      case 'clear':
        await this.clearCookies(page)
        break
        
      case 'save':
        await this.saveCookies(page, flags.output)
        break
        
      case 'load':
        if (!flags.file) this.error('File path required for load action (use --file)')
        await this.loadCookies(page, flags.file)
        break
        
      default:
        this.error(`Unknown action: ${action}`)
    }
  }

  private async listCookies(page: Page): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.log('No cookies found')
      return
    }
    
    this.log(`Found ${cookies.length} cookies:\n`)
    
    for (const cookie of cookies) {
      this.log(`üç™ ${cookie.name}`)
      this.log(`   Value: ${cookie.value}`)
      this.log(`   Domain: ${cookie.domain}`)
      this.log(`   Path: ${cookie.path}`)
      if (cookie.expires && cookie.expires > 0) {
        this.log(`   Expires: ${new Date(cookie.expires * 1000).toISOString()}`)
      }
      if (cookie.secure) this.log('   Secure: ‚úì')
      if (cookie.httpOnly) this.log('   HttpOnly: ‚úì')
      if (cookie.sameSite) this.log(`   SameSite: ${cookie.sameSite}`)
      this.log('')
    }
  }

  private async getCookie(page: Page, name: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    const cookies = await this.context!.cookies()
    const cookie = cookies.find(c => c.name === name)
    
    if (!cookie) {
      this.error(`Cookie not found: ${name}`)
    }
    
    this.log(`üç™ ${cookie.name} = ${cookie.value}`)
    
    if (flags.verbose) {
      this.logVerbose('Cookie details', {
        domain: cookie.domain,
        path: cookie.path,
        secure: cookie.secure,
        httpOnly: cookie.httpOnly,
        sameSite: cookie.sameSite,
        expires: cookie.expires ? new Date(cookie.expires * 1000).toISOString() : 'Session',
      })
    }
  }

  private async setCookie(page: Page, value: string): Promise<void> {
    const { flags } = await this.parse(Cookies)
    
    // Parse name=value format
    const [name, ...valueParts] = value.split('=')
    if (!name || valueParts.length === 0) {
      this.error('Invalid cookie format. Use: name=value')
    }
    
    const cookieValue = valueParts.join('=') // Handle values with = in them
    
    // Get current URL for domain
    const url = page.url()
    const urlObj = new URL(url)
    
    const cookie: Cookie = {
      name: name.trim(),
      value: cookieValue.trim(),
      domain: flags.domain || urlObj.hostname,
      path: flags.path,
      secure: flags.secure,
      httpOnly: flags.httpOnly,
      sameSite: flags.sameSite as 'Strict' | 'Lax' | 'None',
      expires: flags.expires || -1, // -1 means session cookie
    }
    
    await this.context!.addCookies([cookie])
    this.log(`‚úÖ Cookie set: ${name}`)
    
    if (flags.verbose) {
      this.logVerbose('Cookie set', cookie)
    }
  }

  private async deleteCookie(page: Page, name: string): Promise<void> {
    const cookies = await this.context!.cookies()
    const cookie = cookies.find(c => c.name === name)
    
    if (!cookie) {
      this.warn(`Cookie not found: ${name}`)
      return
    }
    
    // Delete by setting expiration to past
    await this.context!.addCookies([{
      ...cookie,
      expires: 0,
    }])
    
    this.log(`‚úÖ Cookie deleted: ${name}`)
  }

  private async clearCookies(page: Page): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.log('No cookies to clear')
      return
    }
    
    await this.context!.clearCookies()
    this.log(`‚úÖ Cleared ${cookies.length} cookies`)
  }

  private async saveCookies(page: Page, outputPath: string): Promise<void> {
    const cookies = await this.context!.cookies()
    
    if (cookies.length === 0) {
      this.warn('No cookies to save')
      return
    }
    
    await fs.writeFile(outputPath, JSON.stringify(cookies, null, 2))
    this.log(`‚úÖ Saved ${cookies.length} cookies to: ${outputPath}`)
  }

  private async loadCookies(page: Page, filePath: string): Promise<void> {
    try {
      const content = await fs.readFile(filePath, 'utf-8')
      const cookies = JSON.parse(content) as Cookie[]
      
      if (!Array.isArray(cookies)) {
        this.error('Invalid cookie file format')
      }
      
      await this.context!.addCookies(cookies)
      this.log(`‚úÖ Loaded ${cookies.length} cookies from: ${filePath}`)
      
    } catch (error: any) {
      this.error(`Failed to load cookies: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/examples.ts">
import { Args, Flags } from '@oclif/core'
import { Command } from '@oclif/core'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
}

interface Example {
  title: string
  commands: string[]
  description?: string
}

export default class Examples extends Command {
  static description = 'Show example recipes for common tasks'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> login',
    '<%= config.bin %> <%= command.id %> scraping',
    '<%= config.bin %> <%= command.id %> testing',
  ]

  static args = {
    topic: Args.string({
      description: 'Topic to show examples for',
      options: ['login', 'scraping', 'testing', 'forms', 'automation', 'monitoring'],
    }),
  }

  static flags = {
    list: Flags.boolean({
      char: 'l',
      description: 'List all available topics',
      default: false,
    }),
  }

  private examples: Record<string, Example> = {
    login: {
      title: 'Login & Authentication',
      description: 'Handle login flows and authenticated sessions',
      commands: [
        '# Method 1: Interactive login with profile',
        'chromancer spawn --profile work',
        'chromancer wait-for-login https://github.com/login',
        'chromancer navigate https://github.com/settings',
        '',
        '# Method 2: Automated login with workflow',
        'cat > github-login.yml << EOF',
        '- navigate: https://github.com/login',
        '- type:',
        '    selector: input[name="login"]',
        '    text: ${USERNAME}',
        '- type:',
        '    selector: input[name="password"]',
        '    text: ${PASSWORD}',
        '- click: input[type="submit"]',
        '- wait:',
        '    url: https://github.com',
        'EOF',
        'chromancer run github-login.yml --var USERNAME=you --var PASSWORD=secret',
      ],
    },
    scraping: {
      title: 'Web Scraping',
      description: 'Extract data from websites',
      commands: [
        '# Quick data extraction',
        'chromancer quick extract https://news.ycombinator.com ".titleline a" --json > stories.json',
        '',
        '# Export table data as CSV',
        'chromancer navigate https://example.com/data',
        'chromancer export --format csv --selector "table#results" --output data.csv',
        '',
        '# Complex scraping workflow',
        'cat > scraper.yml << EOF',
        '- navigate: https://example.com/products',
        '- wait: .product-list',
        '- evaluate: |',
        '    Array.from(document.querySelectorAll(".product")).map(p => ({',
        '      name: p.querySelector(".name")?.textContent,',
        '      price: p.querySelector(".price")?.textContent,',
        '      link: p.querySelector("a")?.href',
        '    }))',
        '- export:',
        '    format: json',
        '    output: products.json',
        'EOF',
        'chromancer run scraper.yml',
      ],
    },
    testing: {
      title: 'Testing & Monitoring',
      description: 'Test websites and monitor performance',
      commands: [
        '# Quick site test',
        'chromancer quick test example.com',
        '',
        '# Visual regression test',
        'chromancer navigate https://example.com',
        'chromancer screenshot baseline.png',
        '# ... make changes ...',
        'chromancer screenshot current.png',
        '',
        '# Performance monitoring',
        'chromancer navigate https://example.com',
        'chromancer evaluate "performance.timing" --json > perf.json',
        '',
        '# Network monitoring',
        'chromancer network --filter "api" --type xhr --output api-calls.json',
      ],
    },
    forms: {
      title: 'Form Automation',
      description: 'Fill and submit forms automatically',
      commands: [
        '# Auto-fill with generated data',
        'chromancer navigate https://example.com/signup',
        'chromancer fill --auto-generate --submit',
        '',
        '# Fill with specific data',
        'chromancer fill --data \'{"email": "test@example.com", "name": "Test User"}\'',
        '',
        '# Complex form workflow',
        'cat > form-flow.yml << EOF',
        '- navigate: https://example.com/application',
        '- fill:',
        '    form:',
        '      firstName: John',
        '      lastName: Doe',
        '      email: john@example.com',
        '- select:',
        '    selector: select[name="country"]',
        '    value: US',
        '- click: input[type="checkbox"][name="terms"]',
        '- screenshot: form-complete.png',
        '- click: button[type="submit"]',
        'EOF',
        'chromancer run form-flow.yml',
      ],
    },
    automation: {
      title: 'General Automation',
      description: 'Automate repetitive tasks',
      commands: [
        '# Daily screenshot',
        'chromancer spawn --headless',
        'chromancer run daily-screenshots.yml',
        '',
        '# Batch PDF generation',
        'for url in site1.com site2.com site3.com; do',
        '  chromancer navigate "https://$url"',
        '  chromancer pdf --output "$url.pdf"',
        'done',
        '',
        '# Cookie management',
        'chromancer cookies save --output session.json',
        '# ... later ...',
        'chromancer cookies load --file session.json',
        'chromancer navigate https://example.com/dashboard',
        '',
        '# Record and replay',
        'chromancer record --output actions.json',
        '# ... perform actions in browser ...',
        '# Press Ctrl+C to stop',
        'chromancer record --output actions.js --format js',
      ],
    },
    monitoring: {
      title: 'Monitoring & Alerts',
      description: 'Monitor websites for changes',
      commands: [
        '# Check for content changes',
        'chromancer navigate https://example.com/status',
        'chromancer evaluate "document.querySelector(\'.status\').textContent" > status.txt',
        'diff status.txt previous-status.txt || echo "Status changed!"',
        '',
        '# Monitor for specific text',
        'cat > monitor.yml << EOF',
        '- navigate: https://example.com/products',
        '- wait:',
        '    text: "Out of Stock"',
        '    timeout: 5000',
        '- evaluate: |',
        '    console.log("Item is out of stock!")',
        'EOF',
        'chromancer run monitor.yml --continue-on-error',
        '',
        '# Network performance monitoring',
        'chromancer network --duration 60000 --output network-report.json',
        'cat network-report.json | jq \'.[] | select(.duration > 1000)\'',
      ],
    },
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Examples)
    
    if (flags.list || !args.topic) {
      this.showTopics()
      return
    }
    
    const example = this.examples[args.topic]
    if (!example) {
      this.error(`Unknown topic: ${args.topic}\nRun 'chromancer examples --list' to see available topics`)
    }
    
    this.showExample(args.topic, example)
  }

  private showTopics(): void {
    console.log(chalk.bold('\nüìö Available Example Topics\n'))
    
    Object.entries(this.examples).forEach(([key, example]) => {
      console.log(`${chalk.cyan(key.padEnd(12))} - ${example.title}`)
      if (example.description) {
        console.log(chalk.gray(`${''.padEnd(14)} ${example.description}`))
      }
    })
    
    console.log(chalk.gray('\nRun \'chromancer examples <topic>\' to see examples'))
    console.log()
  }

  private showExample(topic: string, example: Example): void {
    console.log()
    console.log(chalk.bold(chalk.cyan(`üìñ ${example.title}`)))
    if (example.description) {
      console.log(chalk.gray(example.description))
    }
    console.log()
    
    let inCodeBlock = false
    
    example.commands.forEach(line => {
      if (line.startsWith('#')) {
        // Comment
        console.log(chalk.green(line))
      } else if (line === '') {
        console.log()
      } else if (line.includes('<<') && line.includes('EOF')) {
        // Start of heredoc
        console.log(chalk.gray(line))
        inCodeBlock = true
      } else if (line === 'EOF') {
        // End of heredoc
        console.log(chalk.gray(line))
        inCodeBlock = false
      } else if (inCodeBlock) {
        // Inside heredoc
        console.log(chalk.yellow(line))
      } else {
        // Command
        console.log(line)
      }
    })
    
    console.log()
    console.log(chalk.gray(`Try more examples: chromancer examples --list`))
    console.log()
  }
}
</file>

<file path="src/commands/export.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'
import * as path from 'path'

export default class Export extends BaseCommand {
  static description = 'Export page content, data, or resources'

  static examples = [
    '<%= config.bin %> <%= command.id %> --format html --output page.html',
    '<%= config.bin %> <%= command.id %> --format json --selector "table#data"',
    '<%= config.bin %> <%= command.id %> --format csv --selector "table"',
    '<%= config.bin %> <%= command.id %> --format markdown --output content.md',
    '<%= config.bin %> <%= command.id %> --all-resources --output-dir ./export',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    format: Flags.string({
      char: 'f',
      description: 'Export format',
      options: ['html', 'json', 'csv', 'markdown', 'text'],
      default: 'html',
    }),
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to export specific element',
    }),
    output: Flags.string({
      char: 'o',
      description: 'Output file path',
    }),
    'output-dir': Flags.string({
      description: 'Output directory for resources',
      default: './export',
    }),
    'all-resources': Flags.boolean({
      description: 'Export all page resources (images, scripts, styles)',
      default: false,
    }),
    'include-styles': Flags.boolean({
      description: 'Include computed styles in HTML export',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Export)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.exportContent(this.page!)
  }

  private async exportContent(page: Page): Promise<void> {
    const { flags } = await this.parse(Export)
    
    let content: string
    
    switch (flags.format) {
      case 'html':
        content = await this.exportHTML(page, flags.selector, flags['include-styles'])
        break
      case 'json':
        content = await this.exportJSON(page, flags.selector)
        break
      case 'csv':
        content = await this.exportCSV(page, flags.selector)
        break
      case 'markdown':
        content = await this.exportMarkdown(page, flags.selector)
        break
      case 'text':
        content = await this.exportText(page, flags.selector)
        break
      default:
        this.error(`Unsupported format: ${flags.format}`)
    }
    
    // Export resources if requested
    if (flags['all-resources']) {
      await this.exportResources(page, flags['output-dir'])
    }
    
    // Save content
    const outputPath = flags.output || `export.${flags.format}`
    await fs.writeFile(outputPath, content)
    this.log(`‚úÖ Exported to: ${outputPath}`)
  }

  private async exportHTML(page: Page, selector?: string, includeStyles?: boolean): Promise<string> {
    if (selector) {
      return await page.evaluate(({ sel, styles }) => {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        
        if (styles) {
          // Clone element and inline styles
          const clone = element.cloneNode(true) as HTMLElement
          const allElements = clone.querySelectorAll('*')
          allElements.forEach((el) => {
            const computed = window.getComputedStyle(el as HTMLElement)
            ;(el as HTMLElement).setAttribute('style', computed.cssText)
          })
          return clone.outerHTML
        }
        
        return element.outerHTML
      }, { sel: selector, styles: includeStyles })
    }
    
    return await page.content()
  }

  private async exportJSON(page: Page, selector?: string): Promise<string> {
    const data = await page.evaluate((sel) => {
      if (sel) {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        
        // Special handling for tables
        if (element.tagName === 'TABLE') {
          const headers: string[] = []
          const rows: any[] = []
          
          // Get headers
          element.querySelectorAll('thead th').forEach((th) => {
            headers.push(th.textContent?.trim() || '')
          })
          
          // Get rows
          element.querySelectorAll('tbody tr').forEach((tr) => {
            const row: any = {}
            tr.querySelectorAll('td').forEach((td, i) => {
              const key = headers[i] || `col${i}`
              row[key] = td.textContent?.trim() || ''
            })
            rows.push(row)
          })
          
          return rows
        }
        
        // Try to extract data attributes
        const dataAttrs: any = {}
        Array.from(element.attributes).forEach((attr) => {
          if (attr.name.startsWith('data-')) {
            const key = attr.name.replace('data-', '')
            try {
              dataAttrs[key] = JSON.parse(attr.value)
            } catch {
              dataAttrs[key] = attr.value
            }
          }
        })
        
        return {
          text: element.textContent?.trim(),
          attributes: dataAttrs,
          html: element.innerHTML,
        }
      }
      
      // Export all data elements
      const allData: any[] = []
      document.querySelectorAll('[data-export], [data-json], table').forEach((el) => {
        if (el.tagName === 'TABLE') {
          // Handle tables as above
          const headers: string[] = []
          const rows: any[] = []
          
          el.querySelectorAll('thead th').forEach((th) => {
            headers.push(th.textContent?.trim() || '')
          })
          
          el.querySelectorAll('tbody tr').forEach((tr) => {
            const row: any = {}
            tr.querySelectorAll('td').forEach((td, i) => {
              const key = headers[i] || `col${i}`
              row[key] = td.textContent?.trim() || ''
            })
            rows.push(row)
          })
          
          allData.push({ type: 'table', data: rows })
        } else {
          // Handle data elements
          const data = el.getAttribute('data-json') || el.getAttribute('data-export')
          if (data) {
            try {
              allData.push(JSON.parse(data))
            } catch {
              allData.push(data)
            }
          }
        }
      })
      
      return allData
    }, selector)
    
    return JSON.stringify(data, null, 2)
  }

  private async exportCSV(page: Page, selector?: string): Promise<string> {
    const tableSelector = selector || 'table'
    
    return await page.evaluate((sel) => {
      const table = document.querySelector(sel)
      if (!table || table.tagName !== 'TABLE') {
        throw new Error('No table found with selector: ' + sel)
      }
      
      const rows: string[] = []
      
      // Get headers
      const headers: string[] = []
      table.querySelectorAll('thead th').forEach((th) => {
        headers.push(`"${th.textContent?.trim().replace(/"/g, '""') || ''}"`)
      })
      if (headers.length > 0) {
        rows.push(headers.join(','))
      }
      
      // Get data rows
      table.querySelectorAll('tbody tr').forEach((tr) => {
        const cells: string[] = []
        tr.querySelectorAll('td').forEach((td) => {
          cells.push(`"${td.textContent?.trim().replace(/"/g, '""') || ''}"`)
        })
        rows.push(cells.join(','))
      })
      
      return rows.join('\n')
    }, tableSelector)
  }

  private async exportMarkdown(page: Page, selector?: string): Promise<string> {
    return await page.evaluate((sel) => {
      const element = sel ? document.querySelector(sel) : document.body
      if (!element) throw new Error(`Element not found: ${sel}`)
      
      // Simple HTML to Markdown conversion
      function htmlToMarkdown(el: Element): string {
        let md = ''
        
        for (const node of Array.from(el.childNodes)) {
          if (node.nodeType === Node.TEXT_NODE) {
            md += node.textContent
          } else if (node.nodeType === Node.ELEMENT_NODE) {
            const elem = node as Element
            const tag = elem.tagName.toLowerCase()
            
            switch (tag) {
              case 'h1':
                md += `# ${elem.textContent?.trim()}\n\n`
                break
              case 'h2':
                md += `## ${elem.textContent?.trim()}\n\n`
                break
              case 'h3':
                md += `### ${elem.textContent?.trim()}\n\n`
                break
              case 'h4':
                md += `#### ${elem.textContent?.trim()}\n\n`
                break
              case 'h5':
                md += `##### ${elem.textContent?.trim()}\n\n`
                break
              case 'h6':
                md += `###### ${elem.textContent?.trim()}\n\n`
                break
              case 'p':
                md += `${elem.textContent?.trim()}\n\n`
                break
              case 'a':
                md += `[${elem.textContent?.trim()}](${elem.getAttribute('href')})`
                break
              case 'img':
                md += `![${elem.getAttribute('alt') || ''}](${elem.getAttribute('src')})`
                break
              case 'strong':
              case 'b':
                md += `**${elem.textContent?.trim()}**`
                break
              case 'em':
              case 'i':
                md += `*${elem.textContent?.trim()}*`
                break
              case 'code':
                md += `\`${elem.textContent?.trim()}\``
                break
              case 'pre':
                md += `\`\`\`\n${elem.textContent?.trim()}\n\`\`\`\n\n`
                break
              case 'ul':
              case 'ol':
                const items = Array.from(elem.querySelectorAll('li'))
                items.forEach((li, i) => {
                  const prefix = tag === 'ol' ? `${i + 1}. ` : '- '
                  md += `${prefix}${li.textContent?.trim()}\n`
                })
                md += '\n'
                break
              case 'blockquote':
                md += `> ${elem.textContent?.trim()}\n\n`
                break
              case 'hr':
                md += '---\n\n'
                break
              case 'br':
                md += '\n'
                break
              case 'table':
                // Convert table to markdown
                const headers = Array.from(elem.querySelectorAll('thead th'))
                if (headers.length > 0) {
                  md += '| ' + headers.map(th => th.textContent?.trim()).join(' | ') + ' |\n'
                  md += '| ' + headers.map(() => '---').join(' | ') + ' |\n'
                }
                elem.querySelectorAll('tbody tr').forEach((tr) => {
                  const cells = Array.from(tr.querySelectorAll('td'))
                  md += '| ' + cells.map(td => td.textContent?.trim()).join(' | ') + ' |\n'
                })
                md += '\n'
                break
              default:
                md += htmlToMarkdown(elem)
            }
          }
        }
        
        return md
      }
      
      return htmlToMarkdown(element)
    }, selector)
  }

  private async exportText(page: Page, selector?: string): Promise<string> {
    if (selector) {
      return await page.evaluate((sel) => {
        const element = document.querySelector(sel)
        if (!element) throw new Error(`Element not found: ${sel}`)
        return element.textContent?.trim() || ''
      }, selector)
    }
    
    return await page.evaluate(() => document.body.textContent?.trim() || '')
  }

  private async exportResources(page: Page, outputDir: string): Promise<void> {
    const { flags } = await this.parse(Export)
    await fs.mkdir(outputDir, { recursive: true })
    
    // Get all resource URLs
    const resources = await page.evaluate(() => {
      const urls = new Set<string>()
      
      // Images
      document.querySelectorAll('img').forEach((img) => {
        if (img.src) urls.add(img.src)
      })
      
      // Stylesheets
      document.querySelectorAll('link[rel="stylesheet"]').forEach((link) => {
        if ((link as HTMLLinkElement).href) urls.add((link as HTMLLinkElement).href)
      })
      
      // Scripts
      document.querySelectorAll('script[src]').forEach((script) => {
        if ((script as HTMLScriptElement).src) urls.add((script as HTMLScriptElement).src)
      })
      
      return Array.from(urls)
    })
    
    this.log(`üì¶ Exporting ${resources.length} resources...`)
    
    // Download each resource
    for (const url of resources) {
      try {
        const response = await page.request.get(url)
        if (response.ok()) {
          const urlObj = new URL(url)
          const filename = path.basename(urlObj.pathname) || 'index.html'
          const filepath = path.join(outputDir, filename)
          
          const buffer = await response.body()
          await fs.writeFile(filepath, buffer)
          
          if (flags.verbose) {
            this.logVerbose(`Downloaded: ${filename}`)
          }
        }
      } catch (error) {
        this.warn(`Failed to download: ${url}`)
      }
    }
    
    this.log(`‚úÖ Resources exported to: ${outputDir}`)
  }
}
</file>

<file path="src/commands/fill.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface FormData {
  [key: string]: string | boolean | string[]
}

export default class Fill extends BaseCommand {
  static description = 'Fill form fields automatically'

  static examples = [
    '<%= config.bin %> <%= command.id %> --data \'{"username": "john", "email": "john@example.com"}\'',
    '<%= config.bin %> <%= command.id %> --file form-data.json',
    '<%= config.bin %> <%= command.id %> --selector "#login-form" --data \'{"username": "admin", "password": "secret"}\'',
    '<%= config.bin %> <%= command.id %> --auto-generate --submit',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    data: Flags.string({
      char: 'd',
      description: 'JSON data to fill forms with',
      exclusive: ['file', 'auto-generate'],
    }),
    file: Flags.string({
      char: 'f',
      description: 'JSON file containing form data',
      exclusive: ['data', 'auto-generate'],
    }),
    selector: Flags.string({
      char: 's',
      description: 'CSS selector for specific form',
    }),
    'auto-generate': Flags.boolean({
      description: 'Generate random test data for all fields',
      exclusive: ['data', 'file'],
    }),
    submit: Flags.boolean({
      description: 'Submit the form after filling',
      default: false,
    }),
    'wait-after': Flags.integer({
      description: 'Wait time in ms after filling each field',
      default: 100,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Fill)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.fillForms(this.page!)
  }

  private async fillForms(page: Page): Promise<void> {
    const { flags } = await this.parse(Fill)
    
    // Get form data
    let formData: FormData = {}
    
    if (flags.data) {
      try {
        formData = JSON.parse(flags.data)
      } catch (error) {
        this.error('Invalid JSON data')
      }
    } else if (flags.file) {
      try {
        const content = await fs.readFile(flags.file, 'utf-8')
        formData = JSON.parse(content)
      } catch (error) {
        this.error(`Failed to read file: ${flags.file}`)
      }
    } else if (flags['auto-generate']) {
      formData = await this.generateTestData(page, flags.selector)
    } else {
      this.error('No form data provided. Use --data, --file, or --auto-generate')
    }
    
    // Fill the form
    const formSelector = flags.selector || 'form'
    
    try {
      // Wait for form to be present
      await page.waitForSelector(formSelector, { timeout: 5000 })
      
      // Fill each field
      for (const [key, value] of Object.entries(formData)) {
        const filled = await this.fillField(page, formSelector, key, value)
        
        if (filled && flags['wait-after'] > 0) {
          await page.waitForTimeout(flags['wait-after'])
        }
      }
      
      this.log('‚úÖ Form filled successfully')
      
      // Submit if requested
      if (flags.submit) {
        await this.submitForm(page, formSelector)
      }
      
    } catch (error: any) {
      this.error(`Failed to fill form: ${error.message}`)
    }
  }

  private async fillField(page: Page, formSelector: string, key: string, value: any): Promise<boolean> {
    const { flags } = await this.parse(Fill)
    
    // Try different strategies to find the field
    const selectors = [
      `${formSelector} [name="${key}"]`,
      `${formSelector} #${key}`,
      `${formSelector} [id="${key}"]`,
      `${formSelector} [data-field="${key}"]`,
      `${formSelector} input[placeholder*="${key}" i]`,
      `${formSelector} label:has-text("${key}") input`,
    ]
    
    for (const selector of selectors) {
      try {
        const element = await page.$(selector)
        if (!element) continue
        
        const tagName = await element.evaluate(el => el.tagName)
        const type = await element.evaluate(el => (el as any).type)
        
        if (tagName === 'INPUT') {
          if (type === 'checkbox' || type === 'radio') {
            if (value === true || value === 'true' || value === '1') {
              await element.check()
              if (flags.verbose) {
                this.logVerbose(`Checked: ${key}`)
              }
            }
          } else if (type === 'file') {
            if (typeof value === 'string') {
              await element.setInputFiles(value)
              if (flags.verbose) {
                this.logVerbose(`Set file: ${key} = ${value}`)
              }
            }
          } else {
            await element.fill(String(value))
            if (flags.verbose) {
              this.logVerbose(`Filled: ${key} = ${value}`)
            }
          }
          return true
        } else if (tagName === 'SELECT') {
          if (Array.isArray(value)) {
            await element.selectOption(value)
          } else {
            await element.selectOption(String(value))
          }
          if (flags.verbose) {
            this.logVerbose(`Selected: ${key} = ${value}`)
          }
          return true
        } else if (tagName === 'TEXTAREA') {
          await element.fill(String(value))
          if (flags.verbose) {
            this.logVerbose(`Filled textarea: ${key}`)
          }
          return true
        }
      } catch (error) {
        // Try next selector
        continue
      }
    }
    
    this.warn(`Could not find field: ${key}`)
    return false
  }

  private async generateTestData(page: Page, formSelector?: string): Promise<FormData> {
    const selector = formSelector || 'form'
    
    return await page.evaluate((sel) => {
      const form = document.querySelector(sel)
      if (!form) throw new Error(`Form not found: ${sel}`)
      
      const data: any = {}
      
      // Generate data based on field types and names
      const generateValue = (element: HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement): any => {
        const name = element.name || element.id
        const type = (element as HTMLInputElement).type || element.tagName.toLowerCase()
        
        // Generate based on common field names
        if (/email/i.test(name)) return 'test@example.com'
        if (/phone|tel/i.test(name)) return '+1234567890'
        if (/name/i.test(name)) {
          if (/first/i.test(name)) return 'John'
          if (/last/i.test(name)) return 'Doe'
          return 'John Doe'
        }
        if (/user/i.test(name)) return 'testuser'
        if (/pass/i.test(name)) return 'TestPass123!'
        if (/age/i.test(name)) return '25'
        if (/date/i.test(name)) return new Date().toISOString().split('T')[0]
        if (/time/i.test(name)) return '12:00'
        if (/url|website/i.test(name)) return 'https://example.com'
        if (/zip|postal/i.test(name)) return '12345'
        if (/address/i.test(name)) return '123 Test Street'
        if (/city/i.test(name)) return 'Test City'
        if (/state/i.test(name)) return 'CA'
        if (/country/i.test(name)) return 'United States'
        if (/message|comment|description|bio/i.test(name)) return 'This is a test message.'
        
        // Generate based on input type
        switch (type) {
          case 'email': return 'test@example.com'
          case 'tel': return '+1234567890'
          case 'url': return 'https://example.com'
          case 'number': return '42'
          case 'date': return new Date().toISOString().split('T')[0]
          case 'time': return '12:00'
          case 'datetime-local': return new Date().toISOString().slice(0, 16)
          case 'month': return new Date().toISOString().slice(0, 7)
          case 'week': return new Date().toISOString().split('T')[0]
          case 'color': return '#3498db'
          case 'range': return '50'
          case 'checkbox': return true
          case 'radio': return true
          case 'select':
          case 'select-one':
            const options = (element as HTMLSelectElement).options
            if (options.length > 1) {
              return options[1].value // Skip first option (often empty)
            }
            return options[0]?.value
          case 'select-multiple':
            const opts = Array.from((element as HTMLSelectElement).options)
            return opts.slice(1, 3).map(o => o.value) // Select first two non-empty options
          case 'textarea': return 'This is test content for the textarea field.'
          default: return 'Test Value'
        }
      }
      
      // Find all form fields
      form.querySelectorAll('input, select, textarea').forEach((field) => {
        const element = field as HTMLInputElement | HTMLSelectElement | HTMLTextAreaElement
        const name = element.name || element.id
        
        if (!name) return
        
        // Skip hidden, submit, button, reset fields
        if ((element as HTMLInputElement).type === 'hidden' ||
            (element as HTMLInputElement).type === 'submit' ||
            (element as HTMLInputElement).type === 'button' ||
            (element as HTMLInputElement).type === 'reset') {
          return
        }
        
        // Skip if already has data for radio buttons
        if ((element as HTMLInputElement).type === 'radio' && data[name]) {
          return
        }
        
        data[name] = generateValue(element)
      })
      
      return data
    }, selector)
  }

  private async submitForm(page: Page, formSelector: string): Promise<void> {
    this.log('üì§ Submitting form...')
    
    // Try to find and click submit button
    const submitSelectors = [
      `${formSelector} button[type="submit"]`,
      `${formSelector} input[type="submit"]`,
      `${formSelector} button:has-text("Submit")`,
      `${formSelector} button:has-text("Send")`,
      `${formSelector} button:has-text("Save")`,
      `${formSelector} button:has-text("Continue")`,
    ]
    
    for (const selector of submitSelectors) {
      try {
        const button = await page.$(selector)
        if (button) {
          await button.click()
          this.log('‚úÖ Form submitted')
          return
        }
      } catch (error) {
        // Try next selector
      }
    }
    
    // Fallback: submit via Enter key
    try {
      await page.evaluate((sel) => {
        const form = document.querySelector(sel) as HTMLFormElement
        if (form) {
          form.submit()
        }
      }, formSelector)
      this.log('‚úÖ Form submitted')
    } catch (error: any) {
      this.warn('Could not find submit button')
    }
  }
}
</file>

<file path="src/commands/go.ts">
import { Args } from '@oclif/core'
import Navigate from './navigate.js'

export default class Go extends Navigate {
  static description = 'Alias for navigate - go to a URL'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> example.com',
  ]

  static args = {
    url: Args.string({
      description: 'URL to navigate to',
      required: true,
    }),
  }

  static flags = Navigate.flags

  async run(): Promise<void> {
    // Simply run the parent navigate command
    await super.run()
  }
}
</file>

<file path="src/commands/init.ts">
import { Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  bold: (s: string) => `\x1b[1m${s}\x1b[0m`,
}

export default class Init extends BaseCommand {
  static description = 'Initialize chromancer and set up your environment'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --skip-chrome-check',
    '<%= config.bin %> <%= command.id %> --example-workflows',
  ]

  static flags = {
    'skip-chrome-check': Flags.boolean({
      description: 'Skip Chrome connectivity check',
      default: false,
    }),
    'example-workflows': Flags.boolean({
      description: 'Create example workflow files',
      default: false,
    }),
    'config-only': Flags.boolean({
      description: 'Only create config file',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Init)
    
    this.showWelcome()
    
    // Step 1: Check Chrome
    if (!flags['skip-chrome-check'] && !flags['config-only']) {
      await this.checkChrome()
    }
    
    // Step 2: Create config
    await this.createConfig()
    
    // Step 3: Create examples if requested
    if (flags['example-workflows']) {
      await this.createExamples()
    }
    
    // Step 4: Show next steps
    this.showNextSteps()
  }

  private showWelcome(): void {
    console.log()
    console.log(chalk.bold(chalk.cyan('üßô Welcome to Chromancer!')))
    console.log(chalk.gray('The magical Chrome automation tool'))
    console.log()
    console.log('This wizard will help you:')
    console.log('  ‚Ä¢ Check Chrome connectivity')
    console.log('  ‚Ä¢ Create a configuration file')
    console.log('  ‚Ä¢ Set up example workflows')
    console.log()
  }

  private async checkChrome(): Promise<void> {
    this.log(chalk.blue('üì° Checking Chrome connectivity...'))
    
    try {
      // Try default port
      await this.connectToChrome(9222, 'localhost', false)
      this.log(chalk.green('‚úÖ Chrome is running and accessible on port 9222'))
    } catch (error) {
      this.log(chalk.yellow('‚ö†Ô∏è  Chrome is not running or not accessible'))
      this.log()
      this.log('To start Chrome with remote debugging:')
      this.log()
      this.log(chalk.gray('  # Option 1: Use chromancer'))
      this.log('  chromancer spawn --headless')
      this.log()
      this.log(chalk.gray('  # Option 2: Start Chrome manually'))
      this.log('  chrome --remote-debugging-port=9222')
      this.log()
      this.log(chalk.gray('  # Option 3: Use Docker'))
      this.log('  docker run -d -p 9222:9222 zenika/alpine-chrome \\')
      this.log('    --no-sandbox --remote-debugging-host=0.0.0.0 --remote-debugging-port=9222')
      this.log()
    }
  }

  private async createConfig(): Promise<void> {
    const configPath = path.join(os.homedir(), '.chromancer.json')
    
    // Check if config exists
    try {
      await fs.access(configPath)
      this.log(chalk.yellow(`‚ö†Ô∏è  Config file already exists: ${configPath}`))
      return
    } catch {
      // File doesn't exist, create it
    }
    
    const defaultConfig = {
      chrome: {
        port: 9222,
        host: 'localhost',
        defaultTimeout: 30000,
      },
      commands: {
        screenshot: {
          path: './screenshots',
          fullPage: true,
        },
        pdf: {
          path: './pdfs',
          format: 'A4',
        },
        export: {
          path: './exports',
        },
      },
      workflows: {
        continueOnError: false,
        variablePrefix: '${',
        variableSuffix: '}',
      },
      ui: {
        colorOutput: true,
        verboseErrors: true,
        showTips: true,
      },
    }
    
    await fs.writeFile(
      configPath,
      JSON.stringify(defaultConfig, null, 2)
    )
    
    this.log(chalk.green(`‚úÖ Created config file: ${configPath}`))
    this.log(chalk.gray('   You can edit this file to customize chromancer behavior'))
  }

  private async createExamples(): Promise<void> {
    const examplesDir = path.join(process.cwd(), 'chromancer-examples')
    
    try {
      await fs.mkdir(examplesDir, { recursive: true })
    } catch (error) {
      this.warn('Could not create examples directory')
      return
    }
    
    // Create a simple example
    const simpleExample = `# Simple workflow example
# Run with: chromancer run simple.yml

- navigate: https://example.com
- wait:
    selector: h1
    timeout: 5000
- screenshot: example-home.png
- click: a[href*="more"]
- wait: 
    time: 2000
- screenshot: example-more.png
`
    
    await fs.writeFile(
      path.join(examplesDir, 'simple.yml'),
      simpleExample
    )
    
    // Create a form example
    const formExample = `# Form automation example
# Run with: chromancer run form.yml --var EMAIL=test@example.com

- navigate: https://example.com/contact
- wait:
    selector: form
- fill:
    form:
      name: "Test User"
      email: \${EMAIL}
      message: "This is an automated test"
- screenshot: form-filled.png
# Uncomment to submit:
# - click: button[type="submit"]
`
    
    await fs.writeFile(
      path.join(examplesDir, 'form.yml'),
      formExample
    )
    
    // Create a scraping example
    const scrapingExample = `# Web scraping example
# Run with: chromancer run scraping.yml

- navigate: https://news.ycombinator.com
- wait:
    selector: .itemlist
- evaluate: |
    // Extract top stories
    Array.from(document.querySelectorAll('.athing')).slice(0, 10).map(item => ({
      title: item.querySelector('.titleline a')?.textContent,
      link: item.querySelector('.titleline a')?.href,
      rank: item.querySelector('.rank')?.textContent
    }))
- export:
    format: json
    output: hn-stories.json
`
    
    await fs.writeFile(
      path.join(examplesDir, 'scraping.yml'),
      scrapingExample
    )
    
    this.log(chalk.green(`‚úÖ Created example workflows in: ${examplesDir}`))
    this.log(chalk.gray('   ‚Ä¢ simple.yml    - Basic navigation'))
    this.log(chalk.gray('   ‚Ä¢ form.yml      - Form automation'))
    this.log(chalk.gray('   ‚Ä¢ scraping.yml  - Data extraction'))
  }

  private showNextSteps(): void {
    console.log()
    console.log(chalk.bold(chalk.green('üéâ Setup complete!')))
    console.log()
    console.log('Next steps:')
    console.log()
    console.log('1. Start Chrome (if not running):')
    console.log(chalk.cyan('   chromancer spawn'))
    console.log()
    console.log('2. Try a simple command:')
    console.log(chalk.cyan('   chromancer navigate https://example.com'))
    console.log(chalk.cyan('   chromancer screenshot example.png'))
    console.log()
    console.log('3. Run a workflow:')
    console.log(chalk.cyan('   chromancer run chromancer-examples/simple.yml'))
    console.log()
    console.log('4. Explore more commands:')
    console.log(chalk.cyan('   chromancer --help'))
    console.log()
    console.log(chalk.gray('üìö Full documentation: https://chromancer.dev'))
    console.log()
  }
}
</file>

<file path="src/commands/network.ts">
import { Flags } from '@oclif/core'
import { Page, Request, Response } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface NetworkLog {
  timestamp: string
  method: string
  url: string
  status?: number
  type?: string
  size?: number
  duration?: number
  headers?: Record<string, string>
  postData?: string
  response?: any
}

export default class Network extends BaseCommand {
  static description = 'Monitor network requests and responses'

  static examples = [
    '<%= config.bin %> <%= command.id %> --filter "api"',
    '<%= config.bin %> <%= command.id %> --type xhr --output api-calls.json',
    '<%= config.bin %> <%= command.id %> --method POST --verbose',
    '<%= config.bin %> <%= command.id %> --status 404 --status 500',
    '<%= config.bin %> <%= command.id %> --block "ads" --block "analytics"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    filter: Flags.string({
      char: 'f',
      description: 'URL filter pattern',
      multiple: true,
    }),
    type: Flags.string({
      char: 't',
      description: 'Resource type filter',
      options: ['document', 'stylesheet', 'image', 'media', 'font', 'script', 'xhr', 'fetch', 'websocket'],
      multiple: true,
    }),
    method: Flags.string({
      char: 'm',
      description: 'HTTP method filter',
      options: ['GET', 'POST', 'PUT', 'DELETE', 'PATCH', 'HEAD', 'OPTIONS'],
      multiple: true,
    }),
    status: Flags.integer({
      description: 'HTTP status code filter',
      multiple: true,
    }),
    block: Flags.string({
      char: 'b',
      description: 'Block requests matching pattern',
      multiple: true,
    }),
    output: Flags.string({
      char: 'o',
      description: 'Output file for network log',
    }),
    'capture-response': Flags.boolean({
      description: 'Capture response bodies',
      default: false,
    }),
    'live-mode': Flags.boolean({
      description: 'Show requests in real-time',
      default: true,
    }),
    duration: Flags.integer({
      char: 'd',
      description: 'Monitor duration in milliseconds',
      default: 60000, // 1 minute
    }),
  }

  private networkLogs: NetworkLog[] = []
  private requestTimings = new Map<string, number>()

  async run(): Promise<void> {
    const { flags } = await this.parse(Network)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open for monitoring
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.monitorNetwork(this.page!)
  }

  private async monitorNetwork(page: Page): Promise<void> {
    const { flags } = await this.parse(Network)
    
    this.log('üåê Network monitoring started...')
    this.log(`Press Ctrl+C to stop (max duration: ${flags.duration}ms)\n`)
    
    // Set up request interception if blocking
    if (flags.block && flags.block.length > 0) {
      await page.route('**/*', async (route) => {
        const url = route.request().url()
        const shouldBlock = flags.block!.some(pattern => url.includes(pattern))
        
        if (shouldBlock) {
          await route.abort()
          if (flags['live-mode']) {
            this.log(`üö´ Blocked: ${url}`)
          }
        } else {
          await route.continue()
        }
      })
    }
    
    // Monitor requests
    page.on('request', (request) => {
      this.requestTimings.set(request.url(), Date.now())
      
      if (this.shouldLogRequest(request)) {
        const log: NetworkLog = {
          timestamp: new Date().toISOString(),
          method: request.method(),
          url: request.url(),
          type: request.resourceType(),
        }
        
        if (flags.verbose || flags['capture-response']) {
          log.headers = request.headers()
          log.postData = request.postData() || undefined
        }
        
        if (flags['live-mode']) {
          this.log(`‚Üí ${request.method()} ${request.url()}`)
        }
        
        this.networkLogs.push(log)
      }
    })
    
    // Monitor responses
    page.on('response', async (response) => {
      const request = response.request()
      
      if (this.shouldLogRequest(request) && this.shouldLogResponse(response)) {
        const startTime = this.requestTimings.get(request.url())
        const duration = startTime ? Date.now() - startTime : undefined
        
        // Find and update the request log
        const logIndex = this.networkLogs.findIndex(
          log => log.url === request.url() && log.method === request.method() && !log.status
        )
        
        if (logIndex !== -1) {
          this.networkLogs[logIndex].status = response.status()
          this.networkLogs[logIndex].duration = duration
          
          try {
            const headers = await response.allHeaders()
            const size = headers['content-length'] ? parseInt(headers['content-length']) : undefined
            this.networkLogs[logIndex].size = size
            
            if (flags['capture-response']) {
              try {
                const contentType = headers['content-type'] || ''
                if (contentType.includes('json') || contentType.includes('text')) {
                  this.networkLogs[logIndex].response = await response.text()
                }
              } catch {
                // Ignore response body errors
              }
            }
          } catch {
            // Ignore header errors
          }
        }
        
        if (flags['live-mode']) {
          const status = response.status()
          const statusIcon = status >= 200 && status < 300 ? '‚úì' : status >= 400 ? '‚úó' : '‚Ä¢'
          const sizeStr = this.networkLogs[logIndex]?.size 
            ? ` (${this.formatBytes(this.networkLogs[logIndex].size!)})`
            : ''
          const durationStr = duration ? ` ${duration}ms` : ''
          
          this.log(`‚Üê ${statusIcon} ${status} ${request.url()}${sizeStr}${durationStr}`)
        }
      }
    })
    
    // Monitor failed requests
    page.on('requestfailed', (request) => {
      if (this.shouldLogRequest(request)) {
        if (flags['live-mode']) {
          this.log(`‚úó Failed: ${request.method()} ${request.url()}`)
        }
        
        const logIndex = this.networkLogs.findIndex(
          log => log.url === request.url() && log.method === request.method() && !log.status
        )
        
        if (logIndex !== -1) {
          this.networkLogs[logIndex].status = 0 // Failed request
        }
      }
    })
    
    // Set up monitoring duration
    const timeout = setTimeout(() => {
      this.stopMonitoring()
    }, flags.duration)
    
    // Handle Ctrl+C
    process.on('SIGINT', () => {
      clearTimeout(timeout)
      this.stopMonitoring()
    })
  }

  private shouldLogRequest(request: Request): boolean {
    const { flags } = this.parsedFlags as any
    
    // Filter by URL pattern
    if (flags.filter && flags.filter.length > 0) {
      const url = request.url()
      if (!flags.filter.some((pattern: string) => url.includes(pattern))) {
        return false
      }
    }
    
    // Filter by resource type
    if (flags.type && flags.type.length > 0) {
      if (!flags.type.includes(request.resourceType())) {
        return false
      }
    }
    
    // Filter by method
    if (flags.method && flags.method.length > 0) {
      if (!flags.method.includes(request.method())) {
        return false
      }
    }
    
    return true
  }

  private shouldLogResponse(response: Response): boolean {
    const { flags } = this.parsedFlags as any
    
    // Filter by status code
    if (flags.status && flags.status.length > 0) {
      if (!flags.status.includes(response.status())) {
        return false
      }
    }
    
    return true
  }

  private async stopMonitoring(): Promise<void> {
    const { flags } = this.parsedFlags as any
    
    this.log('\n‚èπÔ∏è  Network monitoring stopped')
    this.log(`Captured ${this.networkLogs.length} requests`)
    
    // Summary statistics
    const stats = this.calculateStats()
    this.log('\nüìä Summary:')
    this.log(`   Total requests: ${stats.total}`)
    this.log(`   Successful: ${stats.successful} (2xx)`)
    this.log(`   Redirects: ${stats.redirects} (3xx)`)
    this.log(`   Client errors: ${stats.clientErrors} (4xx)`)
    this.log(`   Server errors: ${stats.serverErrors} (5xx)`)
    this.log(`   Failed: ${stats.failed}`)
    if (stats.totalSize > 0) {
      this.log(`   Total size: ${this.formatBytes(stats.totalSize)}`)
    }
    if (stats.avgDuration > 0) {
      this.log(`   Average duration: ${stats.avgDuration.toFixed(0)}ms`)
    }
    
    // Save to file if requested
    if (flags.output) {
      await fs.writeFile(flags.output, JSON.stringify(this.networkLogs, null, 2))
      this.log(`\n‚úÖ Network log saved to: ${flags.output}`)
    }
    
    process.exit(0)
  }

  private calculateStats(): any {
    const stats = {
      total: this.networkLogs.length,
      successful: 0,
      redirects: 0,
      clientErrors: 0,
      serverErrors: 0,
      failed: 0,
      totalSize: 0,
      totalDuration: 0,
      avgDuration: 0,
    }
    
    for (const log of this.networkLogs) {
      if (log.status === 0) {
        stats.failed++
      } else if (log.status && log.status >= 200 && log.status < 300) {
        stats.successful++
      } else if (log.status && log.status >= 300 && log.status < 400) {
        stats.redirects++
      } else if (log.status && log.status >= 400 && log.status < 500) {
        stats.clientErrors++
      } else if (log.status && log.status >= 500) {
        stats.serverErrors++
      }
      
      if (log.size) {
        stats.totalSize += log.size
      }
      
      if (log.duration) {
        stats.totalDuration += log.duration
      }
    }
    
    const completedRequests = this.networkLogs.filter(log => log.duration).length
    if (completedRequests > 0) {
      stats.avgDuration = stats.totalDuration / completedRequests
    }
    
    return stats
  }

  private formatBytes(bytes: number): string {
    if (bytes === 0) return '0 B'
    
    const k = 1024
    const sizes = ['B', 'KB', 'MB', 'GB']
    const i = Math.floor(Math.log(bytes) / Math.log(k))
    
    return `${(bytes / Math.pow(k, i)).toFixed(2)} ${sizes[i]}`
  }

  private get parsedFlags() {
    return this.parse(Network).then(result => result.flags)
  }
}
</file>

<file path="src/commands/pdf.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'

export default class Pdf extends BaseCommand {
  static description = 'Save page as PDF'

  static examples = [
    '<%= config.bin %> <%= command.id %> --output page.pdf',
    '<%= config.bin %> <%= command.id %> --output report.pdf --format A4',
    '<%= config.bin %> <%= command.id %> --output doc.pdf --landscape --background',
    '<%= config.bin %> <%= command.id %> --output print.pdf --css "@media print"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output PDF file path',
      default: 'page.pdf',
    }),
    format: Flags.string({
      char: 'f',
      description: 'Page format',
      options: ['Letter', 'Legal', 'Tabloid', 'Ledger', 'A0', 'A1', 'A2', 'A3', 'A4', 'A5', 'A6'],
      default: 'Letter',
    }),
    landscape: Flags.boolean({
      description: 'Use landscape orientation',
      default: false,
    }),
    scale: Flags.integer({
      description: 'Scale of the webpage rendering (percentage)',
      default: 100,
    }),
    background: Flags.boolean({
      description: 'Print background graphics',
      default: false,
    }),
    'display-header-footer': Flags.boolean({
      description: 'Display header and footer',
      default: false,
    }),
    'header-template': Flags.string({
      description: 'HTML template for header',
    }),
    'footer-template': Flags.string({
      description: 'HTML template for footer',
    }),
    margin: Flags.string({
      description: 'Page margins (e.g., "20px" or "1in 2in 1in 2in")',
    }),
    'page-ranges': Flags.string({
      description: 'Page ranges to print (e.g., "1-5, 8, 11-13")',
    }),
    css: Flags.string({
      description: 'CSS media type to emulate',
    }),
    'wait-for': Flags.string({
      description: 'Wait for selector before generating PDF',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Pdf)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.generatePDF(this.page!)
  }

  private async generatePDF(page: Page): Promise<void> {
    const { flags } = await this.parse(Pdf)
    
    try {
      // Wait for specific element if requested
      if (flags['wait-for']) {
        this.log(`‚è≥ Waiting for: ${flags['wait-for']}`)
        await page.waitForSelector(flags['wait-for'], { timeout: 30000 })
      }
      
      // Emulate CSS media type if specified
      if (flags.css) {
        await page.emulateMedia({ media: flags.css as 'screen' | 'print' })
      }
      
      // Prepare PDF options
      const pdfOptions: any = {
        path: flags.output,
        format: flags.format,
        landscape: flags.landscape,
        printBackground: flags.background,
        displayHeaderFooter: flags['display-header-footer'],
      }
      
      // Scale
      if (flags.scale !== 100) {
        pdfOptions.scale = flags.scale / 100
      }
      
      // Header and footer templates
      if (flags['header-template']) {
        pdfOptions.headerTemplate = flags['header-template']
      }
      if (flags['footer-template']) {
        pdfOptions.footerTemplate = flags['footer-template']
      }
      
      // Margins
      if (flags.margin) {
        const margins = this.parseMargins(flags.margin)
        pdfOptions.margin = margins
      }
      
      // Page ranges
      if (flags['page-ranges']) {
        pdfOptions.pageRanges = flags['page-ranges']
      }
      
      this.log('üìÑ Generating PDF...')
      
      // Generate PDF
      await page.pdf(pdfOptions)
      
      this.log(`‚úÖ PDF saved to: ${flags.output}`)
      
      // Log details if verbose
      if (flags.verbose) {
        const stats = await this.getFileStats(flags.output)
        this.logVerbose('PDF generated', {
          format: flags.format,
          orientation: flags.landscape ? 'landscape' : 'portrait',
          scale: `${flags.scale}%`,
          fileSize: stats ? `${(stats.size / 1024).toFixed(2)} KB` : 'unknown',
          url: page.url(),
        })
      }
      
    } catch (error: any) {
      this.error(`Failed to generate PDF: ${error.message}`)
    }
  }

  private parseMargins(margin: string): any {
    const parts = margin.trim().split(/\s+/)
    
    if (parts.length === 1) {
      // Single value for all margins
      return {
        top: parts[0],
        right: parts[0],
        bottom: parts[0],
        left: parts[0],
      }
    } else if (parts.length === 2) {
      // Vertical and horizontal
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[0],
        left: parts[1],
      }
    } else if (parts.length === 4) {
      // Top, right, bottom, left
      return {
        top: parts[0],
        right: parts[1],
        bottom: parts[2],
        left: parts[3],
      }
    } else {
      this.error('Invalid margin format. Use "20px" or "1in 2in 1in 2in"')
    }
  }

  private async getFileStats(path: string): Promise<{ size: number } | null> {
    try {
      const { promises: fs } = await import('fs')
      const stats = await fs.stat(path)
      return { size: stats.size }
    } catch {
      return null
    }
  }
}
</file>

<file path="src/commands/quick.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { ProgressIndicator } from '../utils/progress.js'

const chalk = {
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
}

export default class Quick extends BaseCommand {
  static description = 'Quick commands for common tasks'

  static examples = [
    '<%= config.bin %> <%= command.id %> check example.com',
    '<%= config.bin %> <%= command.id %> capture https://example.com output.png',
    '<%= config.bin %> <%= command.id %> extract https://news.site "article h2"',
  ]

  static args = {
    action: Args.string({
      description: 'Quick action to perform',
      required: true,
      options: ['check', 'capture', 'extract', 'test'],
    }),
    target: Args.string({
      description: 'URL or target for the action',
      required: true,
    }),
    extra: Args.string({
      description: 'Extra parameter (output file, selector, etc)',
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    json: Flags.boolean({
      description: 'Output in JSON format',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Quick)
    
    // Connect to Chrome
    const progress = new ProgressIndicator('Connecting to Chrome...')
    progress.start()
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    progress.stop()
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    switch (args.action) {
      case 'check':
        await this.checkSite(args.target)
        break
        
      case 'capture':
        await this.captureSite(args.target, args.extra || 'quick-capture.png')
        break
        
      case 'extract':
        await this.extractData(args.target, args.extra || 'body')
        break
        
      case 'test':
        await this.testSite(args.target)
        break
        
      default:
        this.error(`Unknown action: ${args.action}`)
    }
  }

  private async checkSite(url: string): Promise<void> {
    const progress = new ProgressIndicator('Checking site...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      const startTime = Date.now()
      await this.page!.goto(url, { waitUntil: 'load' })
      const loadTime = Date.now() - startTime
      
      // Get page info
      const title = await this.page!.title()
      const metrics = await this.page!.evaluate(() => ({
        links: document.querySelectorAll('a').length,
        images: document.querySelectorAll('img').length,
        scripts: document.querySelectorAll('script').length,
        styles: document.querySelectorAll('link[rel="stylesheet"], style').length,
      }))
      
      progress.stop()
      
      console.log(chalk.green('\n‚úÖ Site is accessible!\n'))
      console.log(`üìç URL: ${chalk.blue(this.page!.url())}`)
      console.log(`üìÑ Title: ${title}`)
      console.log(`‚è±Ô∏è  Load time: ${loadTime}ms`)
      console.log(`\nüìä Page stats:`)
      console.log(`   ‚Ä¢ Links: ${metrics.links}`)
      console.log(`   ‚Ä¢ Images: ${metrics.images}`)
      console.log(`   ‚Ä¢ Scripts: ${metrics.scripts}`)
      console.log(`   ‚Ä¢ Styles: ${metrics.styles}`)
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to check site: ${error.message}`)
    }
  }

  private async captureSite(url: string, output: string): Promise<void> {
    const progress = new ProgressIndicator('Capturing page...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      await this.page!.goto(url, { waitUntil: 'networkidle' })
      progress.update('Taking screenshot...')
      
      // Take screenshot
      await this.page!.screenshot({
        path: output,
        fullPage: true,
      })
      
      progress.stop()
      console.log(chalk.green(`‚úÖ Captured to: ${output}`))
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to capture: ${error.message}`)
    }
  }

  private async extractData(url: string, selector: string): Promise<void> {
    const progress = new ProgressIndicator('Extracting data...')
    progress.start()
    
    try {
      // Navigate
      if (!url.startsWith('http')) {
        url = 'https://' + url
      }
      
      await this.page!.goto(url, { waitUntil: 'load' })
      progress.update('Finding elements...')
      
      // Extract data
      const data = await this.page!.evaluate((sel) => {
        const elements = document.querySelectorAll(sel)
        return Array.from(elements).map(el => ({
          text: el.textContent?.trim(),
          tag: el.tagName.toLowerCase(),
          href: (el as any).href,
          src: (el as any).src,
        }))
      }, selector)
      
      progress.stop()
      
      if (data.length === 0) {
        this.warn(`No elements found matching: ${selector}`)
        return
      }
      
      const { flags } = await this.parse(Quick)
      
      if (flags.json) {
        console.log(JSON.stringify(data, null, 2))
      } else {
        console.log(chalk.green(`\n‚úÖ Found ${data.length} elements:\n`))
        data.slice(0, 10).forEach((item, i) => {
          console.log(`${i + 1}. [${chalk.blue(item.tag)}] ${item.text}`)
          if (item.href) console.log(`   ${chalk.gray('‚Üí')} ${item.href}`)
        })
        if (data.length > 10) {
          console.log(chalk.gray(`\n... and ${data.length - 10} more`))
        }
      }
      
    } catch (error: any) {
      progress.stop()
      this.error(`Failed to extract: ${error.message}`)
    }
  }

  private async testSite(url: string): Promise<void> {
    console.log(chalk.cyan('\nüß™ Running site tests...\n'))
    
    const tests = [
      { name: 'Accessibility', fn: () => this.testAccessibility(url) },
      { name: 'Performance', fn: () => this.testPerformance(url) },
      { name: 'Mobile View', fn: () => this.testMobile(url) },
      { name: 'Console Errors', fn: () => this.testConsole(url) },
    ]
    
    let passed = 0
    
    for (const test of tests) {
      try {
        const progress = new ProgressIndicator(`Testing ${test.name}...`)
        progress.start()
        const result = await test.fn()
        progress.stop()
        
        if (result.passed) {
          console.log(chalk.green(`‚úÖ ${test.name}: ${result.message}`))
          passed++
        } else {
          console.log(chalk.yellow(`‚ö†Ô∏è  ${test.name}: ${result.message}`))
        }
      } catch (error: any) {
        console.log(chalk.red(`‚ùå ${test.name}: ${error.message}`))
      }
    }
    
    console.log(chalk.cyan(`\nüìä Test Summary: ${passed}/${tests.length} passed\n`))
  }

  private async testAccessibility(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    await this.page!.goto(url, { waitUntil: 'load' })
    
    const results = await this.page!.evaluate(() => {
      const issues = []
      
      // Check images for alt text
      const imagesWithoutAlt = document.querySelectorAll('img:not([alt])')
      if (imagesWithoutAlt.length > 0) {
        issues.push(`${imagesWithoutAlt.length} images without alt text`)
      }
      
      // Check headings hierarchy
      const h1Count = document.querySelectorAll('h1').length
      if (h1Count !== 1) {
        issues.push(`${h1Count} H1 tags (should be 1)`)
      }
      
      // Check form labels
      const inputsWithoutLabels = document.querySelectorAll('input:not([aria-label]):not([id])')
      if (inputsWithoutLabels.length > 0) {
        issues.push(`${inputsWithoutLabels.length} inputs without labels`)
      }
      
      return issues
    })
    
    return {
      passed: results.length === 0,
      message: results.length === 0 ? 'No major issues found' : results.join(', ')
    }
  }

  private async testPerformance(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    
    const startTime = Date.now()
    await this.page!.goto(url, { waitUntil: 'networkidle' })
    const loadTime = Date.now() - startTime
    
    const metrics = await this.page!.evaluate(() => {
      const perf = (performance as any)
      return {
        resources: performance.getEntriesByType('resource').length,
        jsHeap: perf.memory ? Math.round(perf.memory.usedJSHeapSize / 1048576) : 0,
      }
    })
    
    return {
      passed: loadTime < 3000,
      message: `Load time: ${loadTime}ms, Resources: ${metrics.resources}, JS Heap: ${metrics.jsHeap}MB`
    }
  }

  private async testMobile(url: string): Promise<any> {
    if (!url.startsWith('http')) url = 'https://' + url
    
    // Set mobile viewport
    await this.page!.setViewportSize({ width: 375, height: 667 })
    await this.page!.goto(url, { waitUntil: 'load' })
    
    const results = await this.page!.evaluate(() => {
      const issues = []
      
      // Check viewport meta tag
      const viewport = document.querySelector('meta[name="viewport"]')
      if (!viewport) {
        issues.push('No viewport meta tag')
      }
      
      // Check for horizontal scroll
      if (document.documentElement.scrollWidth > window.innerWidth) {
        issues.push('Horizontal scroll detected')
      }
      
      return issues
    })
    
    // Reset viewport
    await this.page!.setViewportSize({ width: 1280, height: 720 })
    
    return {
      passed: results.length === 0,
      message: results.length === 0 ? 'Mobile-friendly' : results.join(', ')
    }
  }

  private async testConsole(url: string): Promise<any> {
    const errors: string[] = []
    
    this.page!.on('console', (msg) => {
      if (msg.type() === 'error') {
        errors.push(msg.text())
      }
    })
    
    if (!url.startsWith('http')) url = 'https://' + url
    await this.page!.goto(url, { waitUntil: 'load' })
    
    return {
      passed: errors.length === 0,
      message: errors.length === 0 ? 'No console errors' : `${errors.length} console errors`
    }
  }
}
</file>

<file path="src/commands/record.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'

interface RecordedAction {
  type: 'click' | 'type' | 'navigate' | 'select' | 'check' | 'scroll'
  selector?: string
  value?: string
  url?: string
  timestamp: number
}

export default class Record extends BaseCommand {
  static description = 'Record user interactions and generate a script'

  static examples = [
    '<%= config.bin %> <%= command.id %> --output recording.json',
    '<%= config.bin %> <%= command.id %> --output script.js --format js',
    '<%= config.bin %> <%= command.id %> --duration 30000',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    output: Flags.string({
      char: 'o',
      description: 'Output file for the recording',
      default: 'recording.json',
    }),
    format: Flags.string({
      char: 'f',
      description: 'Output format (json or js)',
      options: ['json', 'js'],
      default: 'json',
    }),
    duration: Flags.integer({
      char: 'd',
      description: 'Maximum recording duration in milliseconds',
      default: 60000, // 1 minute
    }),
  }

  private actions: RecordedAction[] = []
  private startTime: number = Date.now()

  async run(): Promise<void> {
    const { flags } = await this.parse(Record)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open for recording
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.startRecording(this.page!)
  }

  private async startRecording(page: Page): Promise<void> {
    const { flags } = await this.parse(Record)
    
    this.log('üî¥ Recording started. Interact with the page...')
    this.log(`Press Ctrl+C to stop recording (max duration: ${flags.duration}ms)`)
    
    // Track navigation
    page.on('framenavigated', (frame) => {
      if (frame === page.mainFrame()) {
        this.actions.push({
          type: 'navigate',
          url: frame.url(),
          timestamp: Date.now() - this.startTime,
        })
      }
    })

    // Inject recording script into every frame
    await page.addInitScript(() => {
      // Store actions in window object
      (window as any).__recordedActions = [];
      
      // Override addEventListener to capture all events
      const originalAddEventListener = EventTarget.prototype.addEventListener;
      EventTarget.prototype.addEventListener = function(type: string, listener: any, options: any) {
        if (type === 'click' || type === 'change' || type === 'input') {
          const wrappedListener = function(this: any, event: Event) {
            const target = event.target as HTMLElement;
            
            // Generate selector
            let selector = '';
            if (target.id) {
              selector = `#${target.id}`;
            } else if (target.className) {
              selector = `.${target.className.split(' ')[0]}`;
            } else {
              selector = target.tagName.toLowerCase();
            }
            
            const action: any = {
              type: type,
              selector: selector,
              timestamp: Date.now(),
            };
            
            // Add value for input events
            if (type === 'input' && (target as any).value) {
              action.value = (target as any).value;
            }
            
            // Add selected value for select elements
            if (type === 'change' && target.tagName === 'SELECT') {
              action.value = (target as HTMLSelectElement).value;
            }
            
            (window as any).__recordedActions.push(action);
            
            // Call original listener
            return listener.call(this, event);
          };
          
          return originalAddEventListener.call(this, type, wrappedListener, options);
        }
        
        return originalAddEventListener.call(this, type, listener, options);
      };
    })

    // Set up polling to collect recorded actions
    const pollInterval = setInterval(async () => {
      try {
        const actions = await page.evaluate(() => {
          const recorded = (window as any).__recordedActions || [];
          (window as any).__recordedActions = [];
          return recorded;
        })
        
        // Process and add actions
        for (const action of actions) {
          if (action.type === 'click') {
            this.actions.push({
              type: 'click',
              selector: action.selector,
              timestamp: action.timestamp - this.startTime,
            })
          } else if (action.type === 'input') {
            this.actions.push({
              type: 'type',
              selector: action.selector,
              value: action.value,
              timestamp: action.timestamp - this.startTime,
            })
          } else if (action.type === 'change') {
            this.actions.push({
              type: 'select',
              selector: action.selector,
              value: action.value,
              timestamp: action.timestamp - this.startTime,
            })
          }
        }
      } catch (error) {
        // Page might have navigated, ignore errors
      }
    }, 100)

    // Set up timeout
    const timeout = setTimeout(() => {
      this.stopRecording(pollInterval)
    }, flags.duration)

    // Handle Ctrl+C
    process.on('SIGINT', () => {
      clearTimeout(timeout)
      this.stopRecording(pollInterval)
    })
  }

  private async stopRecording(pollInterval: NodeJS.Timeout): Promise<void> {
    const { flags } = await this.parse(Record)
    
    clearInterval(pollInterval)
    
    this.log('‚èπÔ∏è  Recording stopped')
    this.log(`Captured ${this.actions.length} actions`)
    
    // Generate output
    let output: string
    
    if (flags.format === 'js') {
      output = this.generateJavaScript()
    } else {
      output = JSON.stringify(this.actions, null, 2)
    }
    
    // Write to file
    await fs.writeFile(flags.output, output)
    this.log(`‚úÖ Recording saved to: ${flags.output}`)
    
    process.exit(0)
  }

  private generateJavaScript(): string {
    const lines = [
      '// Generated by chromancer record',
      '// Run with: node script.js',
      '',
      'const { chromium } = require("playwright");',
      '',
      '(async () => {',
      '  const browser = await chromium.launch({ headless: false });',
      '  const page = await browser.newPage();',
      '',
    ]
    
    let lastTimestamp = 0
    
    for (const action of this.actions) {
      // Add delay if needed
      const delay = action.timestamp - lastTimestamp
      if (delay > 100) {
        lines.push(`  await page.waitForTimeout(${delay});`)
      }
      lastTimestamp = action.timestamp
      
      // Generate action code
      switch (action.type) {
        case 'navigate':
          lines.push(`  await page.goto('${action.url}');`)
          break
        case 'click':
          lines.push(`  await page.click('${action.selector}');`)
          break
        case 'type':
          lines.push(`  await page.fill('${action.selector}', '${action.value}');`)
          break
        case 'select':
          lines.push(`  await page.selectOption('${action.selector}', '${action.value}');`)
          break
      }
    }
    
    lines.push('', '  // await browser.close();', '})();')
    
    return lines.join('\n')
  }
}
</file>

<file path="src/commands/repl.ts">
import Interactive from './interactive.js'

export default class Repl extends Interactive {
  static description = 'Alias for interactive command - start an interactive CDP session'
  
  static aliases = ['session']
}
</file>

<file path="src/commands/scroll.ts">
import { Args, Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'

export default class Scroll extends BaseCommand {
  static description = 'Scroll the page or to specific elements'

  static examples = [
    '<%= config.bin %> <%= command.id %> down',
    '<%= config.bin %> <%= command.id %> top',
    '<%= config.bin %> <%= command.id %> bottom',
    '<%= config.bin %> <%= command.id %> --to "#section3"',
    '<%= config.bin %> <%= command.id %> --by 500',
    '<%= config.bin %> <%= command.id %> --percent 50',
  ]

  static args = {
    direction: Args.string({
      description: 'Scroll direction',
      options: ['up', 'down', 'left', 'right', 'top', 'bottom'],
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    to: Flags.string({
      char: 't',
      description: 'CSS selector to scroll to',
      exclusive: ['by', 'percent'],
    }),
    by: Flags.integer({
      char: 'b',
      description: 'Pixels to scroll by',
      exclusive: ['to', 'percent'],
    }),
    percent: Flags.integer({
      char: 'p',
      description: 'Percentage of page to scroll to (0-100)',
      exclusive: ['to', 'by'],
    }),
    smooth: Flags.boolean({
      description: 'Use smooth scrolling',
      default: true,
    }),
    'wait-after': Flags.integer({
      description: 'Wait time in ms after scrolling',
      default: 500,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Scroll)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.performScroll(this.page!)
  }

  private async performScroll(page: Page): Promise<void> {
    const { args, flags } = await this.parse(Scroll)
    
    const behavior = flags.smooth ? 'smooth' : 'auto'
    
    try {
      // Scroll to element
      if (flags.to) {
        await page.evaluate(({ selector, behavior }) => {
          const element = document.querySelector(selector)
          if (!element) throw new Error(`Element not found: ${selector}`)
          
          element.scrollIntoView({ behavior: behavior as ScrollBehavior, block: 'center' })
        }, { selector: flags.to, behavior })
        
        this.log(`‚úÖ Scrolled to element: ${flags.to}`)
      }
      // Scroll by pixels
      else if (flags.by) {
        const direction = args.direction || 'down'
        let x = 0, y = 0
        
        switch (direction) {
          case 'up':
            y = -flags.by
            break
          case 'down':
            y = flags.by
            break
          case 'left':
            x = -flags.by
            break
          case 'right':
            x = flags.by
            break
          default:
            y = flags.by // Default to down
        }
        
        await page.evaluate(({ x, y, behavior }) => {
          window.scrollBy({ left: x, top: y, behavior: behavior as ScrollBehavior })
        }, { x, y, behavior })
        
        this.log(`‚úÖ Scrolled ${direction} by ${flags.by}px`)
      }
      // Scroll to percentage
      else if (flags.percent !== undefined) {
        if (flags.percent < 0 || flags.percent > 100) {
          this.error('Percentage must be between 0 and 100')
        }
        
        await page.evaluate(({ percent, behavior }) => {
          const maxScroll = document.documentElement.scrollHeight - window.innerHeight
          const targetScroll = (maxScroll * percent) / 100
          
          window.scrollTo({ top: targetScroll, behavior: behavior as ScrollBehavior })
        }, { percent: flags.percent, behavior })
        
        this.log(`‚úÖ Scrolled to ${flags.percent}% of page`)
      }
      // Scroll by direction
      else if (args.direction) {
        switch (args.direction) {
          case 'top':
            await page.evaluate(({ behavior }) => {
              window.scrollTo({ top: 0, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled to top')
            break
            
          case 'bottom':
            await page.evaluate(({ behavior }) => {
              window.scrollTo({ 
                top: document.documentElement.scrollHeight, 
                behavior: behavior as ScrollBehavior 
              })
            }, { behavior })
            this.log('‚úÖ Scrolled to bottom')
            break
            
          case 'up':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ top: -window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled up')
            break
            
          case 'down':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ top: window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled down')
            break
            
          case 'left':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ left: -window.innerWidth * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled left')
            break
            
          case 'right':
            await page.evaluate(({ behavior }) => {
              window.scrollBy({ left: window.innerWidth * 0.8, behavior: behavior as ScrollBehavior })
            }, { behavior })
            this.log('‚úÖ Scrolled right')
            break
        }
      }
      // Default: scroll down one viewport
      else {
        await page.evaluate(({ behavior }) => {
          window.scrollBy({ top: window.innerHeight * 0.8, behavior: behavior as ScrollBehavior })
        }, { behavior })
        this.log('‚úÖ Scrolled down')
      }
      
      // Wait after scrolling
      if (flags['wait-after'] > 0) {
        await page.waitForTimeout(flags['wait-after'])
      }
      
      // Log current position if verbose
      if (flags.verbose) {
        const position = await page.evaluate(() => ({
          x: window.pageXOffset,
          y: window.pageYOffset,
          maxX: document.documentElement.scrollWidth - window.innerWidth,
          maxY: document.documentElement.scrollHeight - window.innerHeight,
        }))
        
        this.logVerbose('Scroll position', {
          x: `${position.x}/${position.maxX}`,
          y: `${position.y}/${position.maxY}`,
          percentX: Math.round((position.x / position.maxX) * 100) || 0,
          percentY: Math.round((position.y / position.maxY) * 100) || 0,
        })
      }
      
    } catch (error: any) {
      this.error(`Failed to scroll: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/shot.ts">
import Screenshot from './screenshot.js'

export default class Shot extends Screenshot {
  static description = 'Alias for screenshot - capture the page'

  static examples = [
    '<%= config.bin %> <%= command.id %> output.png',
    '<%= config.bin %> <%= command.id %> --selector ".main-content"',
  ]

  static args = Screenshot.args
  static flags = Screenshot.flags

  async run(): Promise<void> {
    // Simply run the parent screenshot command
    await super.run()
  }
}
</file>

<file path="src/commands/wait-for-login.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'

export default class WaitForLogin extends BaseCommand {
  static description = 'Navigate to a URL and wait for user to complete login before continuing'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://gmail.com',
    '<%= config.bin %> <%= command.id %> https://github.com --ready-selector ".Header-link--profile"',
    '<%= config.bin %> <%= command.id %> https://app.example.com --ready-selector "#dashboard" --profile work',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'ready-selector': Flags.string({
      char: 'r',
      description: 'CSS selector that indicates successful login (default: body)',
      default: 'body',
    }),
    timeout: Flags.integer({
      char: 't',
      description: 'Maximum time to wait for login in milliseconds',
      default: 300000, // 5 minutes
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to navigate to and wait for login',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(WaitForLogin)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.waitForLogin(args.url, flags['ready-selector'])
  }
}
</file>

<file path="src/types/inquirer-autocomplete-prompt.d.ts">
declare module 'inquirer-autocomplete-prompt' {
  import { Question } from 'inquirer'
  
  interface AutocompleteQuestionOptions extends Question {
    type: 'autocomplete'
    source: (answersSoFar: any, input: string) => Promise<string[]>
    pageSize?: number
    searchText?: string
    emptyText?: string
  }
  
  const AutocompletePrompt: any
  export default AutocompletePrompt
}
</file>

<file path="src/types/schema.ts">
import { Flags } from '@oclif/core'

export interface CommandSchema {
  name: string
  description: string
  flags: Record<string, any>
  args?: Record<string, any>
  examples?: string[]
}

export interface FlagSchema {
  name: string
  char?: string
  description: string
  required: boolean
  type: 'string' | 'boolean' | 'integer'
  options?: string[]
  default?: any
  multiple?: boolean
}

export interface ArgSchema {
  name: string
  description: string
  required: boolean
  options?: string[]
}

export function extractFlagSchema(flag: any): FlagSchema {
  return {
    name: flag.name,
    char: flag.char,
    description: flag.description || '',
    required: flag.required || false,
    type: flag.type || 'string',
    options: flag.options,
    default: flag.default,
    multiple: flag.multiple || false,
  }
}

export function extractCommandSchema(command: any): CommandSchema {
  const flags: Record<string, FlagSchema> = {}
  const args: Record<string, ArgSchema> = {}
  
  // Extract flags
  if (command.flags) {
    for (const [name, flag] of Object.entries(command.flags)) {
      if (name !== 'json' && flag) { // Skip oclif's built-in json flag
        flags[name] = extractFlagSchema({ name, ...flag })
      }
    }
  }
  
  // Extract args
  if (command.args) {
    for (const [name, arg] of Object.entries(command.args)) {
      if (arg) {
        args[name] = {
          name,
          description: (arg as any).description || '',
          required: (arg as any).required || false,
          options: (arg as any).options,
        }
      }
    }
  }
  
  return {
    name: command.id || command.name,
    description: command.description || '',
    flags,
    args: Object.keys(args).length > 0 ? args : undefined,
    examples: command.examples,
  }
}
</file>

<file path="src/utils/config.ts">
import * as fs from 'fs/promises'
import * as path from 'path'
import * as os from 'os'

export interface ChromancerConfig {
  chrome?: {
    port?: number
    host?: string
    defaultTimeout?: number
    launchOptions?: {
      headless?: boolean
      args?: string[]
    }
  }
  commands?: {
    screenshot?: {
      path?: string
      fullPage?: boolean
      type?: 'png' | 'jpeg' | 'webp'
    }
    pdf?: {
      path?: string
      format?: string
      landscape?: boolean
    }
    export?: {
      path?: string
      defaultFormat?: string
    }
    record?: {
      outputPath?: string
      maxDuration?: number
    }
  }
  workflows?: {
    continueOnError?: boolean
    variablePrefix?: string
    variableSuffix?: string
    defaultTimeout?: number
  }
  ui?: {
    colorOutput?: boolean
    verboseErrors?: boolean
    showTips?: boolean
    progressIndicators?: boolean
  }
  aliases?: Record<string, string>
}

class ConfigManager {
  private configPath: string
  private config?: ChromancerConfig
  
  constructor() {
    this.configPath = path.join(os.homedir(), '.chromancer.json')
  }
  
  async load(): Promise<ChromancerConfig> {
    if (this.config) {
      return this.config
    }
    
    try {
      const content = await fs.readFile(this.configPath, 'utf-8')
      this.config = JSON.parse(content)
      return this.config!
    } catch (error) {
      // Return default config if file doesn't exist
      this.config = this.getDefaultConfig()
      return this.config
    }
  }
  
  async save(config: ChromancerConfig): Promise<void> {
    this.config = config
    await fs.writeFile(
      this.configPath,
      JSON.stringify(config, null, 2)
    )
  }
  
  async get<T>(path: string, defaultValue?: T): Promise<T | undefined> {
    const config = await this.load()
    
    const keys = path.split('.')
    let value: any = config
    
    for (const key of keys) {
      if (value && typeof value === 'object' && key in value) {
        value = value[key]
      } else {
        return defaultValue
      }
    }
    
    return value as T
  }
  
  async set(path: string, value: any): Promise<void> {
    const config = await this.load()
    
    const keys = path.split('.')
    let current: any = config
    
    for (let i = 0; i < keys.length - 1; i++) {
      const key = keys[i]
      if (!current[key] || typeof current[key] !== 'object') {
        current[key] = {}
      }
      current = current[key]
    }
    
    current[keys[keys.length - 1]] = value
    await this.save(config)
  }
  
  private getDefaultConfig(): ChromancerConfig {
    return {
      chrome: {
        port: 9222,
        host: 'localhost',
        defaultTimeout: 30000,
        launchOptions: {
          headless: false,
          args: [],
        },
      },
      commands: {
        screenshot: {
          path: './screenshots',
          fullPage: true,
          type: 'png',
        },
        pdf: {
          path: './pdfs',
          format: 'A4',
          landscape: false,
        },
        export: {
          path: './exports',
          defaultFormat: 'json',
        },
        record: {
          outputPath: './recordings',
          maxDuration: 300000, // 5 minutes
        },
      },
      workflows: {
        continueOnError: false,
        variablePrefix: '${',
        variableSuffix: '}',
        defaultTimeout: 30000,
      },
      ui: {
        colorOutput: true,
        verboseErrors: true,
        showTips: true,
        progressIndicators: true,
      },
      aliases: {
        'g': 'go',
        'n': 'navigate',
        's': 'screenshot',
        'c': 'click',
        't': 'type',
        'w': 'wait',
        'e': 'evaluate',
      },
    }
  }
  
  async reset(): Promise<void> {
    this.config = this.getDefaultConfig()
    await this.save(this.config)
  }
  
  getConfigPath(): string {
    return this.configPath
  }
}

// Singleton instance
export const config = new ConfigManager()

// Helper to apply config to command flags
export async function applyConfigToFlags(command: string, flags: any): Promise<any> {
  const configData = await config.load()
  
  // Apply command-specific config
  const commandConfig = configData.commands?.[command as keyof typeof configData.commands]
  if (commandConfig) {
    Object.entries(commandConfig).forEach(([key, value]) => {
      if (!(key in flags) || flags[key] === undefined) {
        flags[key] = value
      }
    })
  }
  
  // Apply global Chrome config
  if (configData.chrome) {
    if (!flags.port && configData.chrome.port) {
      flags.port = configData.chrome.port
    }
    if (!flags.host && configData.chrome.host) {
      flags.host = configData.chrome.host
    }
  }
  
  return flags
}
</file>

<file path="src/utils/errors.ts">
export interface CommandError extends Error {
  action?: string
  selector?: string
  originalError?: Error
  isTimeout?: boolean
}

/**
 * Check if an error is a timeout error
 */
export function isTimeoutError(error: Error): boolean {
  return (
    error.name === 'TimeoutError' ||
    error.message.includes('TimeoutError') ||
    error.message.includes('timeout') ||
    error.message.includes('Timeout') ||
    error.message.includes('Waiting failed')
  )
}

/**
 * Format error message with consistent structure
 */
export function formatErrorMessage(
  action: string,
  message: string,
  selector?: string,
  error?: Error
): string {
  if (error && isTimeoutError(error) && selector) {
    return `Timeout waiting for element: ${selector}`
  }
  
  let formattedMessage = `Failed to ${action}: ${message}`
  if (selector) {
    formattedMessage += ` (${selector})`
  }
  
  return formattedMessage
}

/**
 * Create a standardized command error
 */
export function handleCommandError(
  error: Error,
  action: string,
  selector?: string
): CommandError {
  const commandError = new Error(
    formatErrorMessage(action, error.message, selector, error)
  ) as CommandError
  
  commandError.action = action
  commandError.selector = selector
  commandError.originalError = error
  commandError.isTimeout = isTimeoutError(error)
  
  // Preserve stack trace
  if (error.stack) {
    commandError.stack = error.stack
  }
  
  return commandError
}
</file>

<file path="src/utils/progress.ts">
export class ProgressIndicator {
  private spinner = ['‚†ã', '‚†ô', '‚†π', '‚†∏', '‚†º', '‚†¥', '‚†¶', '‚†ß', '‚†á', '‚†è']
  private currentIndex = 0
  private interval?: NodeJS.Timeout
  private message: string
  
  constructor(message: string) {
    this.message = message
  }
  
  start(): void {
    this.interval = setInterval(() => {
      process.stdout.write(`\r${this.spinner[this.currentIndex]} ${this.message}`)
      this.currentIndex = (this.currentIndex + 1) % this.spinner.length
    }, 80)
  }
  
  update(message: string): void {
    this.message = message
  }
  
  stop(finalMessage?: string): void {
    if (this.interval) {
      clearInterval(this.interval)
      process.stdout.write('\r' + ' '.repeat(this.message.length + 3) + '\r')
      if (finalMessage) {
        console.log(finalMessage)
      }
    }
  }
}

export class ProgressBar {
  private width: number
  private total: number
  private current = 0
  private description: string
  
  constructor(description: string, total: number, width = 30) {
    this.description = description
    this.total = total
    this.width = width
  }
  
  update(current: number): void {
    this.current = Math.min(current, this.total)
    this.render()
  }
  
  increment(): void {
    this.update(this.current + 1)
  }
  
  private render(): void {
    const percent = this.current / this.total
    const filled = Math.floor(this.width * percent)
    const empty = this.width - filled
    
    const bar = '‚ñà'.repeat(filled) + '‚ñë'.repeat(empty)
    const percentStr = `${Math.floor(percent * 100)}%`
    
    process.stdout.write(
      `\r${this.description} [${bar}] ${percentStr} (${this.current}/${this.total})`
    )
    
    if (this.current === this.total) {
      console.log() // New line when complete
    }
  }
  
  complete(message?: string): void {
    this.update(this.total)
    if (message) {
      console.log(message)
    }
  }
}
</file>

<file path="src/commands/assert.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { safeEvaluate } from '../utils/evaluation.js'
import Store from './store.js'

export default class Assert extends BaseCommand {
  static description = 'Assert conditions about page elements or JavaScript expressions'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#success-message"',
    '<%= config.bin %> <%= command.id %> --selector "h1" --contains "Welcome"',
    '<%= config.bin %> <%= command.id %> --eval "document.title" --equals "My Page"',
    '<%= config.bin %> <%= command.id %> --selector ".items" --count 5',
    '<%= config.bin %> <%= command.id %> --eval "window.location.pathname" --equals "/checkout"',
    '<%= config.bin %> <%= command.id %> --stored "originalPrice" --equals "99.99"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to assert on',
      exclusive: ['eval', 'stored'],
    }),
    eval: Flags.string({
      char: 'e',
      description: 'JavaScript expression to evaluate and assert',
      exclusive: ['selector', 'stored'],
    }),
    stored: Flags.string({
      description: 'Assert on a previously stored value',
      exclusive: ['selector', 'eval'],
    }),
    contains: Flags.string({
      description: 'Assert element text contains this value',
      exclusive: ['equals', 'matches', 'greater-than', 'less-than'],
    }),
    equals: Flags.string({
      description: 'Assert element text or evaluation result equals this value',
      exclusive: ['contains', 'matches', 'greater-than', 'less-than'],
    }),
    matches: Flags.string({
      description: 'Assert element text matches this regex pattern',
      exclusive: ['contains', 'equals', 'greater-than', 'less-than'],
    }),
    'greater-than': Flags.string({
      description: 'Assert numeric value is greater than this',
      exclusive: ['contains', 'equals', 'matches', 'less-than'],
    }),
    'less-than': Flags.string({
      description: 'Assert numeric value is less than this',
      exclusive: ['contains', 'equals', 'matches', 'greater-than'],
    }),
    count: Flags.string({
      description: 'Assert number of elements matching selector',
      dependsOn: ['selector'],
      exclusive: ['contains', 'equals', 'matches', 'visible', 'not-visible', 'value', 'greater-than', 'less-than'],
    }),
    visible: Flags.boolean({
      description: 'Assert element is visible',
      dependsOn: ['selector'],
      exclusive: ['not-visible', 'count'],
    }),
    'not-visible': Flags.boolean({
      description: 'Assert element is not visible',
      dependsOn: ['selector'],
      exclusive: ['visible', 'count'],
    }),
    value: Flags.string({
      description: 'Assert input element value',
      dependsOn: ['selector'],
      exclusive: ['contains', 'equals', 'matches', 'count'],
    }),
    message: Flags.string({
      char: 'm',
      description: 'Custom error message if assertion fails',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Assert)
    
    // For stored value assertions, we may not need Chrome connection
    if (flags.stored && !flags.eval && !flags.selector) {
      await this.assertStoredValue(flags)
      return
    }
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, flags)
  }

  private async executeCommand(page: Page, flags: any): Promise<void> {
    try {
      if (flags.selector) {
        await this.assertSelector(page, flags)
      } else if (flags.eval) {
        await this.assertEvaluation(page, flags)
      } else if (flags.stored) {
        await this.assertStoredValue(flags)
      } else {
        this.error('Either --selector, --eval, or --stored must be specified')
      }
    } catch (error: any) {
      const message = flags.message || error.message
      this.error(`‚ùå Assertion failed: ${message}`)
    }
  }

  private async assertSelector(page: Page, flags: any): Promise<void> {
    const selector = flags.selector
    
    // Check if element exists
    const count = await page.locator(selector).count()
    
    if (count === 0 && !flags['not-visible']) {
      throw new Error(`Element not found: ${selector}`)
    }
    
    // Handle count assertion
    if (flags.count !== undefined) {
      const expectedCount = parseInt(flags.count)
      if (count !== expectedCount) {
        throw new Error(`Expected ${expectedCount} elements, found ${count}`)
      }
      this.log(`‚úÖ Assertion passed: Element count equals ${expectedCount}`)
      return
    }
    
    // Handle visibility assertions
    if (flags.visible || flags['not-visible']) {
      const locator = page.locator(selector).first()
      const isVisible = count > 0 && await locator.isVisible()
      
      if (flags.visible && !isVisible) {
        throw new Error(`Element is not visible: ${selector}`)
      }
      if (flags['not-visible'] && isVisible) {
        throw new Error(`Element is visible: ${selector}`)
      }
      
      this.log(`‚úÖ Assertion passed: Element is ${flags.visible ? 'visible' : 'not visible'}`)
      return
    }
    
    // Get element content for text assertions
    const element = page.locator(selector).first()
    let content: string
    
    if (flags.value !== undefined) {
      // Get input value
      content = await element.inputValue() || ''
      
      if (content !== flags.value) {
        throw new Error(`Input value "${content}" does not equal "${flags.value}"`)
      }
      this.log(`‚úÖ Assertion passed: Input value equals "${flags.value}"`)
      return
    } else {
      // Get text content
      content = await element.textContent() || ''
      content = content.trim()
    }
    
    // Handle text assertions
    this.assertContent(content, flags, `Element text`)
  }

  private async assertEvaluation(page: Page, flags: any): Promise<void> {
    let result: any
    
    result = await safeEvaluate(page, flags.eval)
    
    // Convert result to string for comparison if needed
    const resultStr = typeof result === 'string' ? result : JSON.stringify(result)
    
    this.assertContent(resultStr, flags, `Evaluation result`, result)
  }

  private async assertStoredValue(flags: any): Promise<void> {
    const value = Store.getStoredValue(flags.stored)
    
    if (value === undefined) {
      throw new Error(`No stored value found for: ${flags.stored}`)
    }
    
    const valueStr = typeof value === 'string' ? value : JSON.stringify(value)
    
    this.assertContent(valueStr, flags, `Stored value "${flags.stored}"`, value)
  }

  private assertContent(content: string, flags: any, prefix: string, rawValue?: any): void {
    if (flags.contains) {
      if (!content.includes(flags.contains)) {
        throw new Error(`${prefix} "${content}" does not contain "${flags.contains}"`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} contains "${flags.contains}"`)
    } else if (flags.equals) {
      // For equals, also check raw value if available
      const expectedStr = flags.equals
      if (content !== expectedStr && rawValue !== flags.equals) {
        // Try numeric comparison if both can be parsed as numbers
        const numContent = parseFloat(content)
        const numExpected = parseFloat(expectedStr)
        if (isNaN(numContent) || isNaN(numExpected) || numContent !== numExpected) {
          throw new Error(`${prefix} "${content}" does not equal "${expectedStr}"`)
        }
      }
      this.log(`‚úÖ Assertion passed: ${prefix} equals "${flags.equals}"`)
    } else if (flags.matches) {
      const regex = new RegExp(flags.matches)
      if (!regex.test(content)) {
        throw new Error(`${prefix} "${content}" does not match pattern "${flags.matches}"`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} matches pattern "${flags.matches}"`)
    } else if (flags['greater-than']) {
      const numContent = parseFloat(content)
      const numThreshold = parseFloat(flags['greater-than'])
      if (isNaN(numContent) || isNaN(numThreshold)) {
        throw new Error(`Cannot compare non-numeric values: "${content}" > "${flags['greater-than']}"`)
      }
      if (numContent <= numThreshold) {
        throw new Error(`${prefix} ${numContent} is not greater than ${numThreshold}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} (${numContent}) is greater than ${numThreshold}`)
    } else if (flags['less-than']) {
      const numContent = parseFloat(content)
      const numThreshold = parseFloat(flags['less-than'])
      if (isNaN(numContent) || isNaN(numThreshold)) {
        throw new Error(`Cannot compare non-numeric values: "${content}" < "${flags['less-than']}"`)
      }
      if (numContent >= numThreshold) {
        throw new Error(`${prefix} ${numContent} is not less than ${numThreshold}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} (${numContent}) is less than ${numThreshold}`)
    } else {
      // For boolean expressions without comparison
      if (rawValue === false || rawValue === null || rawValue === undefined) {
        throw new Error(`Expression evaluated to ${rawValue}`)
      }
      this.log(`‚úÖ Assertion passed: ${prefix} exists${rawValue !== undefined ? ` (${content})` : ''}`)
    }
    
    // Log details if verbose
    if (flags.verbose) {
      this.logVerbose('Assertion details', {
        type: prefix,
        content: content,
        rawValue: rawValue,
        assertion: flags.contains ? 'contains' : 
                   flags.equals ? 'equals' : 
                   flags.matches ? 'matches' :
                   flags['greater-than'] ? 'greater-than' :
                   flags['less-than'] ? 'less-than' : 'exists'
      })
    }
  }
}
</file>

<file path="src/commands/interactive.ts">
import { Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as readline from 'readline'
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'

interface CommandHistory {
  push(cmd: string): void
  get(index: number): string | undefined
  length: number
}

export default class Interactive extends BaseCommand {
  static description = 'Start an interactive CDP session with command completion and history'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --port 9222',
    '<%= config.bin %> <%= command.id %> --launch --profile work',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
  }

  private rl?: readline.Interface
  private historyFile: string
  private commandHistory: string[] = []
  private historyIndex: number = -1
  private commands = {
    navigate: 'Navigate to a URL',
    click: 'Click on an element',
    type: 'Type text into an element',
    evaluate: 'Evaluate JavaScript in the browser',
    screenshot: 'Take a screenshot',
    select: 'Select elements on the page',
    wait: 'Wait for an element or condition',
    hover: 'Hover over an element',
    back: 'Go back in browser history',
    forward: 'Go forward in browser history',
    reload: 'Reload the current page',
    url: 'Get the current URL',
    title: 'Get the page title',
    cookies: 'List all cookies',
    viewport: 'Set or get viewport size',
    login: 'Navigate and wait for login',
    help: 'Show available commands',
    clear: 'Clear the console',
    exit: 'Exit interactive mode',
    quit: 'Exit interactive mode',
  }

  constructor(argv: string[], config: any) {
    super(argv, config)
    this.historyFile = path.join(os.homedir(), '.chromancer_history')
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Interactive)
    
    // Connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      true // Always keep open in interactive mode
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    // Load command history
    this.loadHistory()

    // Setup readline interface
    this.rl = readline.createInterface({
      input: process.stdin,
      output: process.stdout,
      prompt: 'chromancer> ',
      completer: this.completer.bind(this),
    })

    // Setup key bindings for history navigation
    this.setupKeyBindings()

    this.log('‚ú® Interactive CDP session started')
    this.log('Type "help" for available commands, "exit" to quit')
    this.log('')

    // Display prompt
    this.rl.prompt()

    // Handle line input
    this.rl.on('line', async (input: string) => {
      const trimmedInput = input.trim()
      
      if (trimmedInput) {
        // Add to history
        this.addToHistory(trimmedInput)
        
        try {
          await this.executeCommand(trimmedInput)
        } catch (error: any) {
          this.log(`‚ùå Error: ${error.message}`)
          this.logVerbose('Command execution error', error)
        }
      }
      
      this.rl?.prompt()
    })

    // Handle close
    this.rl.on('close', () => {
      this.saveHistory()
      this.log('\nüëã Goodbye!')
      process.exit(0)
    })
  }

  private setupKeyBindings(): void {
    if (!this.rl) return

    // Override keypress handling for history navigation
    process.stdin.on('keypress', (str, key) => {
      if (!key) return

      if (key.name === 'up') {
        // Navigate backward in history
        if (this.historyIndex < this.commandHistory.length - 1) {
          this.historyIndex++
          const cmd = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex]
          if (cmd && this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
            this.rl.write(cmd)
          }
        }
      } else if (key.name === 'down') {
        // Navigate forward in history
        if (this.historyIndex > 0) {
          this.historyIndex--
          const cmd = this.commandHistory[this.commandHistory.length - 1 - this.historyIndex]
          if (cmd && this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
            this.rl.write(cmd)
          }
        } else if (this.historyIndex === 0) {
          // Clear the line when reaching the end of history
          this.historyIndex = -1
          if (this.rl) {
            this.rl.write(null, { ctrl: true, name: 'u' }) // Clear current line
          }
        }
      }
    })
  }

  private completer(line: string): [string[], string] {
    const completions = Object.keys(this.commands)
    const hits = completions.filter((c) => c.startsWith(line))
    return [hits.length ? hits : completions, line]
  }

  private async executeCommand(input: string): Promise<void> {
    const parts = input.split(/\s+/)
    const command = parts[0].toLowerCase()
    const args = parts.slice(1)

    switch (command) {
      case 'help':
        this.showHelp()
        break

      case 'clear':
        console.clear()
        break

      case 'exit':
      case 'quit':
        this.rl?.close()
        break

      case 'navigate':
      case 'goto':
        if (args.length === 0) {
          this.log('Usage: navigate <url>')
          return
        }
        await this.navigate(args[0])
        break

      case 'click':
        if (args.length === 0) {
          this.log('Usage: click <selector>')
          return
        }
        await this.click(args.join(' '))
        break

      case 'type':
        if (args.length < 2) {
          this.log('Usage: type <selector> <text>')
          return
        }
        const selector = args[0]
        const text = args.slice(1).join(' ')
        await this.type(selector, text)
        break

      case 'evaluate':
      case 'eval':
        if (args.length === 0) {
          this.log('Usage: evaluate <javascript>')
          return
        }
        await this.evaluate(args.join(' '))
        break

      case 'screenshot':
        const filename = args[0] || `screenshot-${Date.now()}.png`
        await this.screenshot(filename)
        break

      case 'select':
        const selectSelector = args.join(' ') || '*'
        await this.select(selectSelector)
        break

      case 'wait':
        if (args.length === 0) {
          this.log('Usage: wait <selector>')
          return
        }
        await this.wait(args.join(' '))
        break

      case 'hover':
        if (args.length === 0) {
          this.log('Usage: hover <selector>')
          return
        }
        await this.hover(args.join(' '))
        break

      case 'back':
        await this.goBack()
        break

      case 'forward':
        await this.goForward()
        break

      case 'reload':
      case 'refresh':
        await this.reload()
        break

      case 'url':
        await this.showUrl()
        break

      case 'title':
        await this.showTitle()
        break

      case 'cookies':
        await this.showCookies()
        break

      case 'viewport':
        if (args.length >= 2) {
          const width = parseInt(args[0])
          const height = parseInt(args[1])
          await this.setViewport(width, height)
        } else {
          await this.showViewport()
        }
        break

      case 'login':
        if (args.length === 0) {
          this.log('Usage: login <url> [ready-selector]')
          return
        }
        const loginUrl = args[0]
        const readySelector = args[1]
        await this.waitForLogin(loginUrl, readySelector)
        break

      default:
        this.log(`Unknown command: ${command}`)
        this.log('Type "help" for available commands')
    }
  }

  private showHelp(): void {
    this.log('\nAvailable commands:')
    this.log('')
    
    Object.entries(this.commands).forEach(([cmd, desc]) => {
      this.log(`  ${cmd.padEnd(15)} ${desc}`)
    })
    
    this.log('')
    this.log('Examples:')
    this.log('  navigate https://example.com')
    this.log('  click button.submit')
    this.log('  type input[name="search"] hello world')
    this.log('  evaluate document.title')
    this.log('  screenshot output.png')
    this.log('  wait .loading-complete')
    this.log('  hover .dropdown-menu')
    this.log('  login https://gmail.com')
    this.log('')
  }

  private async navigate(url: string): Promise<void> {
    if (!this.page) return
    
    // Add protocol if missing
    if (!url.startsWith('http://') && !url.startsWith('https://')) {
      url = 'https://' + url
    }
    
    this.log(`üåê Navigating to ${url}...`)
    await this.page.goto(url, { waitUntil: 'load' })
    this.log(`‚úÖ Navigated to ${url}`)
  }

  private async click(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`üñ±Ô∏è  Clicking ${selector}...`)
    await this.page.click(selector)
    this.log(`‚úÖ Clicked ${selector}`)
  }

  private async type(selector: string, text: string): Promise<void> {
    if (!this.page) return
    
    this.log(`‚å®Ô∏è  Typing into ${selector}...`)
    await this.page.type(selector, text)
    this.log(`‚úÖ Typed "${text}" into ${selector}`)
  }

  private async evaluate(code: string): Promise<void> {
    if (!this.page) return
    
    try {
      const result = await this.page.evaluate(code)
      this.log('üì§ Result:', JSON.stringify(result, null, 2))
    } catch (error: any) {
      this.log('‚ùå Evaluation error:', error.message)
    }
  }

  private async screenshot(filename: string): Promise<void> {
    if (!this.page) return
    
    // Ensure filename has proper extension
    if (!filename.match(/\.(png|jpg|jpeg|webp)$/i)) {
      filename += '.png'
    }
    
    this.log(`üì∏ Taking screenshot...`)
    await this.page.screenshot({ path: filename, fullPage: true })
    this.log(`‚úÖ Screenshot saved to ${filename}`)
  }

  private async select(selector: string): Promise<void> {
    if (!this.page) return
    
    try {
      const count = await this.page.locator(selector).count()
      this.log(`üîç Found ${count} elements matching "${selector}"`)
      
      if (count > 0 && count <= 10) {
        // Show details for up to 10 elements
        for (let i = 0; i < count; i++) {
          const element = this.page.locator(selector).nth(i)
          const tagName = await element.evaluate(el => el.tagName.toLowerCase())
          const text = await element.textContent() || ''
          const className = await element.getAttribute('class') || ''
          
          this.log(`[${i}] <${tagName}${className ? ` class="${className}"` : ''}> ${text.substring(0, 50)}${text.length > 50 ? '...' : ''}`)
        }
      }
    } catch (error: any) {
      this.log('‚ùå Selection error:', error.message)
    }
  }

  private async wait(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`‚è≥ Waiting for ${selector}...`)
    await this.page.waitForSelector(selector, { state: 'visible' })
    this.log(`‚úÖ Element ${selector} is visible`)
  }

  private async hover(selector: string): Promise<void> {
    if (!this.page) return
    
    this.log(`üéØ Hovering over ${selector}...`)
    await this.page.hover(selector)
    this.log(`‚úÖ Hovered over ${selector}`)
  }

  private async goBack(): Promise<void> {
    if (!this.page) return
    
    this.log('‚¨ÖÔ∏è  Going back...')
    await this.page.goBack()
    this.log('‚úÖ Navigated back')
  }

  private async goForward(): Promise<void> {
    if (!this.page) return
    
    this.log('‚û°Ô∏è  Going forward...')
    await this.page.goForward()
    this.log('‚úÖ Navigated forward')
  }

  private async reload(): Promise<void> {
    if (!this.page) return
    
    this.log('üîÑ Reloading page...')
    await this.page.reload()
    this.log('‚úÖ Page reloaded')
  }

  private async showUrl(): Promise<void> {
    if (!this.page) return
    
    const url = this.page.url()
    this.log('üîó Current URL:', url)
  }

  private async showTitle(): Promise<void> {
    if (!this.page) return
    
    const title = await this.page.title()
    this.log('üìÑ Page title:', title)
  }

  private async showCookies(): Promise<void> {
    if (!this.page) return
    
    const cookies = await this.page.context().cookies()
    this.log(`üç™ Found ${cookies.length} cookies:`)
    
    cookies.forEach(cookie => {
      this.log(`  ${cookie.name}: ${cookie.value.substring(0, 50)}${cookie.value.length > 50 ? '...' : ''}`)
    })
  }

  private async setViewport(width: number, height: number): Promise<void> {
    if (!this.page) return
    
    await this.page.setViewportSize({ width, height })
    this.log(`‚úÖ Viewport set to ${width}x${height}`)
  }

  private async showViewport(): Promise<void> {
    if (!this.page) return
    
    const viewport = this.page.viewportSize()
    if (viewport) {
      this.log('üìê Current viewport:', `${viewport.width}x${viewport.height}`)
    } else {
      this.log('No viewport set')
    }
  }

  private loadHistory(): void {
    try {
      if (fs.existsSync(this.historyFile)) {
        const data = fs.readFileSync(this.historyFile, 'utf-8')
        this.commandHistory = data.split('\n').filter(line => line.trim())
      }
    } catch (error) {
      // Ignore history load errors
    }
  }

  private saveHistory(): void {
    try {
      const historyData = this.commandHistory.slice(-1000).join('\n') // Keep last 1000 commands
      fs.writeFileSync(this.historyFile, historyData)
    } catch (error) {
      // Ignore history save errors
    }
  }

  private addToHistory(command: string): void {
    // Don't add duplicate consecutive commands
    if (this.commandHistory.length === 0 || this.commandHistory[this.commandHistory.length - 1] !== command) {
      this.commandHistory.push(command)
    }
    this.historyIndex = -1 // Reset history navigation
  }

  async finally(): Promise<void> {
    if (this.rl) {
      this.rl.close()
    }
    this.saveHistory()
    await super.finally()
  }
}
</file>

<file path="src/commands/run.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { promises as fs } from 'fs'
import * as yaml from 'yaml'
// Create a chalk-like interface for colorization
const chalk = {
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
}
import { Page } from 'playwright'

interface WorkflowStep {
  [command: string]: any
}

interface WorkflowOptions {
  strict?: boolean
  variables?: Record<string, string>
  timeout?: number
}

export default class Run extends BaseCommand {
  private parsedFlags: any
  static description = 'Run a workflow from a YAML file or stdin'

  static examples = [
    '<%= config.bin %> <%= command.id %> workflow.yml',
    '<%= config.bin %> <%= command.id %> --file automation.yml --strict',
    'echo "navigate: https://example.com\\nwait: {selector: body}" | <%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> test.yml --var USER=john --var PASS=secret',
  ]

  static args = {
    file: Args.string({
      description: 'YAML workflow file to run',
      required: false,
    }),
  }

  static flags = {
    ...BaseCommand.baseFlags,
    strict: Flags.boolean({
      description: 'Stop on first error (default: true)',
      default: true,
    }),
    'continue-on-error': Flags.boolean({
      description: 'Continue execution even if a step fails',
      default: false,
    }),
    var: Flags.string({
      description: 'Set workflow variables (KEY=VALUE)',
      multiple: true,
    }),
    timeout: Flags.integer({
      description: 'Default timeout for commands in milliseconds',
      default: 30000,
    }),
    'dry-run': Flags.boolean({
      description: 'Parse and validate workflow without executing',
      default: false,
    }),
  }

  private variables: Record<string, string> = {}
  private stepCount = 0
  private successCount = 0
  private failureCount = 0

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Run)
    this.parsedFlags = flags
    
    // Parse variables
    if (flags.var) {
      for (const varDef of flags.var) {
        const [key, ...valueParts] = varDef.split('=')
        if (key && valueParts.length > 0) {
          this.variables[key] = valueParts.join('=')
        }
      }
    }

    // Load workflow
    let workflowContent: string
    
    if (args.file) {
      // Read from file
      workflowContent = await fs.readFile(args.file, 'utf-8')
      this.log(chalk.cyan(`üìã Loading workflow from: ${args.file}`))
    } else if (process.stdin.isTTY === false) {
      // Read from stdin
      workflowContent = await this.readStdin()
      this.log(chalk.cyan('üìã Loading workflow from stdin'))
    } else {
      this.error('No workflow file specified. Provide a file path or pipe content to stdin.')
    }

    // Parse YAML
    let workflow: WorkflowStep[]
    try {
      const parsed = yaml.parse(workflowContent)
      workflow = Array.isArray(parsed) ? parsed : [parsed]
    } catch (error: any) {
      this.error(`Failed to parse YAML: ${error.message}`)
    }

    if (flags['dry-run']) {
      this.log(chalk.yellow('üîç Dry run mode - validating workflow'))
      this.validateWorkflow(workflow)
      this.log(chalk.green('‚úÖ Workflow is valid'))
      return
    }

    // Connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    // Execute workflow
    const options: WorkflowOptions = {
      strict: flags.strict && !flags['continue-on-error'],
      variables: this.variables,
      timeout: flags.timeout,
    }

    await this.executeWorkflow(workflow, this.page!, options)

    // Show summary
    this.showSummary()
  }

  private async readStdin(): Promise<string> {
    const chunks: Buffer[] = []
    
    for await (const chunk of process.stdin) {
      chunks.push(chunk)
    }
    
    return Buffer.concat(chunks).toString('utf-8')
  }

  private validateWorkflow(workflow: WorkflowStep[]): void {
    if (!Array.isArray(workflow) || workflow.length === 0) {
      this.error('Workflow must contain at least one step')
    }

    workflow.forEach((step, index) => {
      if (typeof step !== 'object' || step === null) {
        this.error(`Step ${index + 1} must be an object`)
      }

      const commands = Object.keys(step)
      if (commands.length === 0) {
        this.error(`Step ${index + 1} must contain a command`)
      }

      if (commands.length > 1) {
        this.warn(`Step ${index + 1} contains multiple commands - only first will be executed`)
      }
    })
  }

  private async executeWorkflow(
    workflow: WorkflowStep[], 
    page: Page, 
    options: WorkflowOptions
  ): Promise<void> {
    this.log(chalk.cyan(`\nüöÄ Executing workflow with ${workflow.length} steps\n`))

    for (const [index, step] of workflow.entries()) {
      this.stepCount++
      const stepNumber = index + 1
      
      // Get command and args
      const command = Object.keys(step)[0]
      let args = step[command]
      
      // Replace variables
      args = this.replaceVariables(args, options.variables || {})
      
      this.log(chalk.blue(`[${stepNumber}/${workflow.length}] ${command}`))
      
      try {
        await this.executeStep(command, args, page, options)
        this.successCount++
        this.log(chalk.green(`    ‚úÖ Success`))
      } catch (error: any) {
        this.failureCount++
        this.log(chalk.red(`    ‚ùå Failed: ${error.message}`))
        
        if (options.strict) {
          this.error(`Workflow failed at step ${stepNumber}: ${error.message}`)
        }
      }
      
      // Add small delay between steps
      await page.waitForTimeout(100)
    }
  }

  private async executeStep(
    command: string, 
    args: any, 
    page: Page,
    options: WorkflowOptions
  ): Promise<void> {
    const timeout = options.timeout || 30000

    switch (command) {
      case 'navigate':
      case 'goto':
        const url = typeof args === 'string' ? args : args.url
        await page.goto(url, { 
          waitUntil: args.waitUntil || 'load',
          timeout 
        })
        break

      case 'click':
        const clickSelector = typeof args === 'string' ? args : args.selector
        await page.click(clickSelector, {
          button: args.button || 'left',
          clickCount: args.clickCount || 1,
          timeout,
        })
        break

      case 'type':
        const typeSelector = typeof args === 'string' 
          ? args.split(' ')[0] 
          : args.selector
        const text = typeof args === 'string' 
          ? args.split(' ').slice(1).join(' ')
          : args.text
        
        await page.type(typeSelector, text, {
          delay: args.delay || 0,
        })
        
        if (args.submit || args.enter) {
          await page.press(typeSelector, 'Enter')
        }
        break

      case 'wait':
        if (typeof args === 'string') {
          await page.waitForSelector(args, { 
            state: 'visible',
            timeout 
          })
        } else if (args.selector) {
          await page.waitForSelector(args.selector, {
            state: args.state || 'visible',
            timeout: args.timeout || timeout,
          })
        } else if (args.time || args.ms) {
          await page.waitForTimeout(args.time || args.ms)
        } else if (args.url) {
          await page.waitForURL(args.url, { timeout })
        }
        break

      case 'screenshot':
        const path = typeof args === 'string' ? args : args.path
        await page.screenshot({
          path,
          fullPage: args.fullPage !== false,
          type: args.type || 'png',
        })
        break

      case 'evaluate':
      case 'eval':
        const code = typeof args === 'string' ? args : args.code
        const result = await page.evaluate(code)
        if (this.parsedFlags.verbose) {
          this.log(chalk.gray(`    Result: ${JSON.stringify(result)}`))
        }
        break

      case 'select':
        const selectSelector = typeof args === 'string' 
          ? args.split(' ')[0]
          : args.selector
        const value = typeof args === 'string'
          ? args.split(' ').slice(1).join(' ')
          : args.value
        
        await page.selectOption(selectSelector, value)
        break

      case 'hover':
        const hoverSelector = typeof args === 'string' ? args : args.selector
        await page.hover(hoverSelector, {
          timeout,
          position: args.position,
        })
        break

      case 'scroll':
        if (typeof args === 'string') {
          await page.evaluate(`window.scrollTo(0, document.body.scrollHeight)`)
        } else if (args.to) {
          await page.evaluate(({ selector }) => {
            document.querySelector(selector)?.scrollIntoView({ behavior: 'smooth' })
          }, { selector: args.to })
        } else if (args.by) {
          await page.evaluate(({ pixels }) => {
            window.scrollBy(0, pixels)
          }, { pixels: args.by })
        }
        break

      case 'fill':
        if (typeof args === 'object' && args.form) {
          for (const [field, value] of Object.entries(args.form)) {
            await page.fill(`[name="${field}"]`, String(value))
          }
        }
        break

      case 'press':
        const key = typeof args === 'string' ? args : args.key
        await page.keyboard.press(key)
        break

      case 'reload':
      case 'refresh':
        await page.reload({ waitUntil: args.waitUntil || 'load' })
        break

      case 'back':
        await page.goBack({ waitUntil: args.waitUntil || 'load' })
        break

      case 'forward':
        await page.goForward({ waitUntil: args.waitUntil || 'load' })
        break

      default:
        throw new Error(`Unknown command: ${command}`)
    }
  }

  private replaceVariables(value: any, variables: Record<string, string>): any {
    if (typeof value === 'string') {
      // Replace ${VAR} patterns
      return value.replace(/\$\{(\w+)\}/g, (match, varName) => {
        return variables[varName] || match
      })
    } else if (Array.isArray(value)) {
      return value.map(item => this.replaceVariables(item, variables))
    } else if (typeof value === 'object' && value !== null) {
      const result: any = {}
      for (const [key, val] of Object.entries(value)) {
        result[key] = this.replaceVariables(val, variables)
      }
      return result
    }
    
    return value
  }

  private showSummary(): void {
    this.log('')
    this.log(chalk.cyan('üìä Workflow Summary:'))
    this.log(`   Total steps: ${this.stepCount}`)
    this.log(`   ${chalk.green('Successful:')} ${this.successCount}`)
    if (this.failureCount > 0) {
      this.log(`   ${chalk.red('Failed:')} ${this.failureCount}`)
    }
    
    const successRate = this.stepCount > 0 
      ? Math.round((this.successCount / this.stepCount) * 100)
      : 0
    
    if (successRate === 100) {
      this.log(chalk.green(`\n‚úÖ All steps completed successfully!`))
    } else if (successRate > 0) {
      this.log(chalk.yellow(`\n‚ö†Ô∏è  ${successRate}% success rate`))
    } else {
      this.log(chalk.red(`\n‚ùå Workflow failed`))
    }
  }
}
</file>

<file path="src/commands/stop.ts">
import { Command } from '@oclif/core'
import { SessionManager } from '../session.js'

export default class Stop extends Command {
  static description = 'Stop the active Chrome browser instance'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
  ]

  public async run(): Promise<void> {
    const session = await SessionManager.getValidSession()
    
    if (!session) {
      this.log('No active Chrome session found')
      return
    }
    
    this.log(`Stopping Chrome on port ${session.port}...`)
    
    try {
      if (process.platform === 'win32') {
        // Windows-specific process termination
        try {
          // Use taskkill command on Windows
          const { execSync } = require('child_process')
          execSync(`taskkill /F /PID ${session.pid}`, { stdio: 'ignore' })
        } catch (error) {
          // Process might already be terminated
        }
      } else {
        // Unix-like systems
        try {
          // Try to kill the process gracefully
          process.kill(session.pid, 'SIGTERM')
          
          // Give it a moment to shut down gracefully
          await new Promise(resolve => setTimeout(resolve, 1000))
          
          // Check if it's still running
          try {
            process.kill(session.pid, 0)
            // If we get here, process is still running, force kill
            process.kill(session.pid, 'SIGKILL')
          } catch {
            // Process already terminated
          }
        } catch {
          // Process might already be terminated
        }
      }
      
      // Clear the session
      SessionManager.clearSession()
      
      this.log('‚úÖ Chrome stopped successfully')
    } catch (error) {
      this.error(`Failed to stop Chrome: ${error}`)
    }
  }
}
</file>

<file path="src/commands/store.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { safeEvaluate } from '../utils/evaluation.js'

export default class Store extends BaseCommand {
  static description = 'Store values from page elements or evaluations for later use'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#price" --as "originalPrice"',
    '<%= config.bin %> <%= command.id %> --eval "document.title" --as "pageTitle"',
    '<%= config.bin %> <%= command.id %> --selector "#username" --as "username" --property "value"',
    '<%= config.bin %> <%= command.id %> --cookies --as "sessionCookies"',
    '<%= config.bin %> <%= command.id %> --list',
    '<%= config.bin %> <%= command.id %> --clear',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector of element to store value from',
      exclusive: ['eval', 'list', 'clear', 'cookies'],
    }),
    eval: Flags.string({
      char: 'e',
      description: 'JavaScript expression to evaluate and store',
      exclusive: ['selector', 'list', 'clear', 'cookies'],
    }),
    cookies: Flags.boolean({
      description: 'Store all cookies',
      exclusive: ['selector', 'eval', 'list', 'clear'],
    }),
    as: Flags.string({
      char: 'a',
      description: 'Variable name to store the value as',
      dependsOn: ['selector', 'eval', 'cookies'],
    }),
    property: Flags.string({
      char: 'p',
      description: 'Element property to store (default: textContent)',
      default: 'textContent',
      dependsOn: ['selector'],
    }),
    attribute: Flags.string({
      description: 'Element attribute to store',
      exclusive: ['property'],
      dependsOn: ['selector'],
    }),
    list: Flags.boolean({
      description: 'List all stored values',
      exclusive: ['selector', 'eval', 'clear', 'cookies'],
    }),
    clear: Flags.boolean({
      description: 'Clear all stored values',
      exclusive: ['selector', 'eval', 'list', 'cookies'],
    }),
    json: Flags.boolean({
      description: 'Output stored values as JSON',
      dependsOn: ['list'],
    }),
  }

  // Static storage that persists across command invocations
  private static storage: Record<string, any> = {}

  async run(): Promise<void> {
    const { flags } = await this.parse(Store)
    
    // Handle list and clear operations without Chrome connection
    if (flags.list) {
      this.listStoredValues(flags.json)
      return
    }
    
    if (flags.clear) {
      this.clearStoredValues()
      return
    }
    
    // For other operations, connect to Chrome
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, flags)
  }

  private async executeCommand(page: Page, flags: any): Promise<void> {
    // Ensure chromancer namespace exists in the page
    await page.evaluate(`
      if (typeof window.chromancer === 'undefined') {
        window.chromancer = { stored: {} };
      } else if (typeof window.chromancer.stored === 'undefined') {
        window.chromancer.stored = {};
      }
    `)
    
    // Inject existing stored values into the page
    for (const [key, value] of Object.entries(Store.storage)) {
      await page.evaluate(`
        window.chromancer.stored["${key}"] = ${JSON.stringify(value)};
      `)
    }
    
    let value: any
    
    if (flags.selector) {
      // Store from element
      try {
        this.log(`üîç Looking for element: ${flags.selector}`)
        const element = await waitForElement(page, flags.selector, {
          timeout: 5000,
          state: 'attached'
        })
        
        if (flags.attribute) {
          // Get attribute value
          value = await element.getAttribute(flags.attribute)
          this.logVerbose(`Getting attribute "${flags.attribute}"`)
        } else {
          // Get property value
          value = await element.evaluate((el, prop) => {
            return (el as any)[prop]
          }, flags.property)
          this.logVerbose(`Getting property "${flags.property}"`)
        }
        
      } catch (error: any) {
        if (error.name === 'TimeoutError') {
          this.error(`Element not found: ${flags.selector}`)
        }
        throw error
      }
    } else if (flags.eval) {
      // Store from evaluation
      this.log(`üîß Evaluating expression...`)
      value = await safeEvaluate(page, flags.eval)
    } else if (flags.cookies) {
      // Store cookies
      this.log(`üç™ Getting cookies...`)
      value = await page.context().cookies()
    }
    
    if (!flags.as) {
      this.error('Variable name required. Use --as flag to specify a name')
    }
    
    // Store the value
    Store.storage[flags.as] = value
    
    // Also store in the page context
    await page.evaluate(`
      window.chromancer.stored["${flags.as}"] = ${JSON.stringify(value)};
    `)
    
    this.log(`‚úÖ Stored value as "${flags.as}": ${this.formatValue(value)}`)
    
    // Log storage info if verbose
    if (flags.verbose) {
      this.logVerbose('Storage info', {
        variable: flags.as,
        type: typeof value,
        isArray: Array.isArray(value),
        totalStored: Object.keys(Store.storage).length,
      })
    }
  }
  
  private formatValue(value: any): string {
    if (typeof value === 'string') {
      return value.length > 100 ? `"${value.substring(0, 100)}..."` : `"${value}"`
    }
    if (typeof value === 'object') {
      const str = JSON.stringify(value)
      return str.length > 100 ? str.substring(0, 100) + '...' : str
    }
    return String(value)
  }
  
  private listStoredValues(json: boolean = false): void {
    if (Object.keys(Store.storage).length === 0) {
      this.log('‚ùå No values stored')
      return
    }
    
    if (json) {
      // Output as JSON for scripting
      console.log(JSON.stringify(Store.storage, null, 2))
    } else {
      this.log('üì¶ Stored values:')
      for (const [key, value] of Object.entries(Store.storage)) {
        this.log(`  ${key}: ${this.formatValue(value)}`)
      }
      this.log(`\nüìä Total: ${Object.keys(Store.storage).length} value(s)`)
    }
  }
  
  private clearStoredValues(): void {
    const count = Object.keys(Store.storage).length
    Store.storage = {}
    this.log(`‚úÖ Cleared all stored values (${count} values removed)`)
  }
  
  // Public method to access storage from other commands
  public static getStoredValue(key: string): any {
    return Store.storage[key]
  }
  
  // Public method to get all stored values
  public static getAllStoredValues(): Record<string, any> {
    return { ...Store.storage }
  }
}
</file>

<file path="src/utils/error-tips.ts">
import { CommandError } from './errors.js'

// Create a chalk-like interface for colorization
const chalk = {
  red: (s: string) => `\x1b[31m${s}\x1b[0m`,
  yellow: (s: string) => `\x1b[33m${s}\x1b[0m`,
  gray: (s: string) => `\x1b[90m${s}\x1b[0m`,
  blue: (s: string) => `\x1b[34m${s}\x1b[0m`,
  green: (s: string) => `\x1b[32m${s}\x1b[0m`,
  cyan: (s: string) => `\x1b[36m${s}\x1b[0m`,
  redBright: (s: string) => `\x1b[91m${s}\x1b[0m`,
}

export interface ErrorTip {
  message: string
  tip?: string
  example?: string
  docsLink?: string
}

/**
 * Get actionable tips for common errors
 */
export function getErrorTip(error: CommandError | Error, command?: string): ErrorTip {
  const message = error.message.toLowerCase()
  const selector = (error as CommandError).selector
  
  // Selector-related errors
  if (message.includes('element not found') || message.includes('no element matches selector')) {
    return getSelectorErrorTip(selector, message)
  }
  
  // Timeout errors
  if (message.includes('timeout') || message.includes('waiting failed')) {
    return getTimeoutErrorTip(selector, command, message)
  }
  
  // Navigation errors
  if (message.includes('navigation') || message.includes('goto')) {
    return getNavigationErrorTip(message)
  }
  
  // Click errors
  if (message.includes('click') && message.includes('intercept')) {
    return {
      message: 'Element is covered by another element',
      tip: 'The element might be hidden behind a modal, popup, or overlay',
      example: 'chromancer wait --selector ".modal" --hidden\nchromancer click "#submit"',
    }
  }
  
  // Type errors
  if (message.includes('cannot type') || message.includes('not an input')) {
    return {
      message: 'Element is not an input field',
      tip: 'Make sure you\'re targeting an <input>, <textarea>, or contenteditable element',
      example: 'chromancer type "input[name=\'email\']" "test@example.com"',
    }
  }
  
  // Frame errors
  if (message.includes('frame') || message.includes('iframe')) {
    return {
      message: 'Element might be inside an iframe',
      tip: 'Use --frame option to target elements inside iframes',
      example: 'chromancer click "#button" --frame 0',
    }
  }
  
  // Connection errors
  if (message.includes('connect') || message.includes('connection refused')) {
    return {
      message: 'Cannot connect to Chrome',
      tip: 'Make sure Chrome is running with remote debugging enabled',
      example: 'chromancer spawn --headless\n# Or manually: chrome --remote-debugging-port=9222',
    }
  }
  
  // Permission errors
  if (message.includes('permission') || message.includes('access denied')) {
    return {
      message: 'Permission denied',
      tip: 'Check file permissions or try running with appropriate privileges',
    }
  }
  
  // Default tip
  return {
    message: error.message,
    tip: 'Check the command syntax and ensure the page has loaded completely',
  }
}

function getSelectorErrorTip(selector?: string, message?: string): ErrorTip {
  if (!selector) {
    return {
      message: 'Element not found',
      tip: 'Provide a valid CSS selector',
      example: 'chromancer click ".button-class"\nchromancer click "#button-id"',
    }
  }
  
  // Check for common selector mistakes
  if (selector.includes('//')) {
    return {
      message: `XPath selectors are not supported: ${selector}`,
      tip: 'Use CSS selectors instead of XPath',
      example: 'chromancer click "button[contains(text(), \'Submit\')]"',
    }
  }
  
  if (selector.match(/^[a-zA-Z]+$/) && !['html', 'body', 'head'].includes(selector)) {
    return {
      message: `Element not found: ${selector}`,
      tip: `Did you forget to add a class (.) or ID (#) prefix?`,
      example: `chromancer click ".${selector}" # for class\nchromancer click "#${selector}" # for ID`,
    }
  }
  
  if (selector.includes(':contains')) {
    return {
      message: 'The :contains() pseudo-selector is not standard CSS',
      tip: 'Use text-based selectors or Playwright\'s text locators',
      example: 'chromancer click "button:has-text(\'Submit\')"',
    }
  }
  
  if (selector.startsWith('.') && selector.includes(' ')) {
    return {
      message: `Element not found: ${selector}`,
      tip: 'Spaces in class selectors might be an issue. Try using dots for multiple classes',
      example: `chromancer click "${selector.replace(/ /g, '.')}"`,
    }
  }
  
  return {
    message: `Element not found: ${selector}`,
    tip: 'Ensure the element exists and is not hidden. Try waiting for it first',
    example: `chromancer wait --selector "${selector}"\nchromancer click "${selector}"`,
  }
}

function getTimeoutErrorTip(selector?: string, command?: string, message?: string): ErrorTip {
  if (message?.includes('navigation')) {
    return {
      message: 'Navigation timeout',
      tip: 'The page took too long to load. Try different wait conditions',
      example: 'chromancer navigate "https://example.com" --wait-until domcontentloaded\n# Or: --wait-until networkidle',
    }
  }
  
  if (selector) {
    return {
      message: `Timeout waiting for element: ${selector}`,
      tip: 'The element didn\'t appear within the timeout period',
      example: `# Increase timeout:\nchromancer wait --selector "${selector}" --timeout 60000\n\n# Or check if element is in iframe:\nchromancer wait --selector "${selector}" --frame 0`,
    }
  }
  
  return {
    message: 'Operation timed out',
    tip: 'Try increasing the timeout or checking network conditions',
    example: 'chromancer <command> --timeout 60000',
  }
}

function getNavigationErrorTip(message: string): ErrorTip {
  if (message.includes('invalid url') || message.includes('malformed')) {
    return {
      message: 'Invalid URL',
      tip: 'Make sure the URL includes the protocol (http:// or https://)',
      example: 'chromancer navigate "https://example.com"',
    }
  }
  
  if (message.includes('net::err') || message.includes('failed to load')) {
    return {
      message: 'Failed to load page',
      tip: 'Check your internet connection and verify the URL is accessible',
      example: '# Test with a known working site:\nchromancer navigate "https://google.com"',
    }
  }
  
  return {
    message: 'Navigation failed',
    tip: 'Try using different wait conditions or check if the site requires authentication',
    example: 'chromancer navigate "https://example.com" --wait-until networkidle',
  }
}

/**
 * Format and display error with tips
 */
export function displayErrorWithTip(
  error: CommandError | Error, 
  command?: string,
  docsBaseUrl: string = 'https://chromancer.dev/docs'
): void {
  const tip = getErrorTip(error, command)
  
  // Error message
  console.error(chalk.red('‚ùå ' + tip.message))
  
  // Tip
  if (tip.tip) {
    console.error(chalk.yellow('\nüí° Tip: ' + tip.tip))
  }
  
  // Example
  if (tip.example) {
    console.error(chalk.gray('\nExample:'))
    tip.example.split('\n').forEach(line => {
      console.error(chalk.gray('   ' + line))
    })
  }
  
  // Docs link
  if (command) {
    const docsLink = `${docsBaseUrl}/${command}#errors`
    console.error(chalk.blue('\nüìö Docs: ' + docsLink))
  }
}

/**
 * Enhance error messages in BaseCommand
 */
export function enhanceError(error: Error, context?: { command?: string, selector?: string }): Error {
  const tip = getErrorTip(error, context?.command)
  
  // Create enhanced error message
  let enhancedMessage = tip.message
  if (tip.tip) {
    enhancedMessage += `\nüí° ${tip.tip}`
  }
  
  const enhancedError = new Error(enhancedMessage)
  enhancedError.stack = error.stack
  
  return enhancedError
}
</file>

<file path="src/utils/evaluation.ts">
import { Page, ElementHandle } from 'playwright'

/**
 * Safely evaluate JavaScript in the page context with error handling
 */
export async function safeEvaluate<T = any>(
  page: Page,
  pageFunction: string | Function,
  ...args: any[]
): Promise<T> {
  try {
    return await page.evaluate(pageFunction as any, ...args) as T
  } catch (error: any) {
    if (error.name === 'SyntaxError') {
      throw new Error(`Invalid JavaScript expression: ${error.message}`)
    }
    throw new Error(`Failed to evaluate: ${error.message}`)
  }
}

/**
 * Get a single property from an element
 */
export async function evaluateElementProperty(
  element: ElementHandle,
  property: string
): Promise<any> {
  return element.evaluate((el, prop) => {
    return (el as any)[prop]
  }, property)
}

/**
 * Get multiple properties from an element at once
 */
export async function evaluateElementProperties(
  element: ElementHandle,
  properties?: string[]
): Promise<Record<string, any>> {
  const defaultProperties = [
    'textContent',
    'value',
    'id',
    'className',
    'tagName',
    'href',
  ]
  
  const props = properties || defaultProperties
  
  return element.evaluate((el, propList) => {
    const result: Record<string, any> = {}
    
    for (const prop of propList) {
      result[prop] = (el as any)[prop] || null
    }
    
    return result
  }, props)
}
</file>

<file path="src/utils/selectors.ts">
import { Page, Locator, ElementHandle } from 'playwright'

export interface WaitOptions {
  timeout?: number
  state?: 'attached' | 'detached' | 'visible' | 'hidden'
}

export interface ElementInfo {
  text: string
  value: string
  tagName: string
  id: string
  className: string
  isVisible: boolean
  isDisabled: boolean
  href?: string | null
  type?: string
  placeholder?: string
  [key: string]: any
}

/**
 * Wait for an element to appear on the page
 */
export async function waitForElement(
  page: Page, 
  selector: string, 
  options: WaitOptions = {}
): Promise<ElementHandle> {
  const { timeout = 30000, state = 'attached' } = options
  
  try {
    // In Playwright, we use waitForSelector which returns ElementHandle or null
    const element = await page.waitForSelector(selector, {
      timeout,
      state,
    })
    
    if (!element) {
      throw new Error(`Element not found: ${selector}`)
    }
    
    return element
  } catch (error: any) {
    if (error.message?.includes('Timeout') || error.message?.includes('Waiting failed')) {
      throw new Error(`Element not found: ${selector}`)
    }
    throw error
  }
}

/**
 * Check if an element is visible on the page
 */
export async function isElementVisible(page: Page, selector: string): Promise<boolean> {
  try {
    const element = await page.$(selector)
    if (!element) return false
    
    return await element.isVisible()
  } catch {
    return false
  }
}

/**
 * Get comprehensive information about an element
 */
export async function getElementInfo(page: Page, selector: string): Promise<ElementInfo | null> {
  const element = await page.$(selector)
  if (!element) return null
  
  return await element.evaluate((el: HTMLElement) => {
    const style = window.getComputedStyle(el)
    const rect = el.getBoundingClientRect()
    
    const info: any = {
      text: el.textContent?.trim() || '',
      value: (el as any).value || '',
      tagName: el.tagName,
      id: el.id,
      className: el.className,
      isVisible: (
        style.display !== 'none' &&
        style.visibility !== 'hidden' &&
        style.opacity !== '0' &&
        rect.width > 0 &&
        rect.height > 0
      ),
      isDisabled: (el as any).disabled || false,
    }
    
    // Add element-specific properties
    if (el.tagName === 'A') {
      info.href = (el as HTMLAnchorElement).href
    }
    
    if (el.tagName === 'INPUT') {
      info.type = (el as HTMLInputElement).type
      info.placeholder = (el as HTMLInputElement).placeholder
    }
    
    return info
  })
}
</file>

<file path="src/session.ts">
import * as fs from 'fs'
import * as path from 'path'
import * as os from 'os'
import { ChildProcess } from 'child_process'

export interface ChromeSession {
  port: number
  pid: number
  startTime: number
  url?: string
}

export class SessionManager {
  private static sessionFile = path.join(os.tmpdir(), 'chromancer-session.json')
  private static activeProcess: ChildProcess | null = null

  static setActiveProcess(process: ChildProcess): void {
    this.activeProcess = process
  }

  static getActiveProcess(): ChildProcess | null {
    return this.activeProcess
  }

  static saveSession(session: ChromeSession): void {
    fs.writeFileSync(this.sessionFile, JSON.stringify(session, null, 2))
  }

  static loadSession(): ChromeSession | null {
    try {
      if (fs.existsSync(this.sessionFile)) {
        const data = fs.readFileSync(this.sessionFile, 'utf8')
        return JSON.parse(data)
      }
    } catch (error) {
      // Session file might be corrupted
    }
    return null
  }

  static clearSession(): void {
    try {
      if (fs.existsSync(this.sessionFile)) {
        fs.unlinkSync(this.sessionFile)
      }
    } catch (error) {
      // Ignore errors when clearing
    }
    this.activeProcess = null
  }

  static async isSessionValid(session: ChromeSession): Promise<boolean> {
    try {
      // Check if the process is still running
      if (process.platform === 'win32') {
        // On Windows, use tasklist to check if process exists
        const { execSync } = require('child_process')
        try {
          const output = execSync(`tasklist /FI "PID eq ${session.pid}"`, { encoding: 'utf8' })
          if (!output.includes(session.pid.toString())) {
            return false
          }
        } catch {
          return false
        }
      } else {
        // On Unix-like systems, use kill -0
        process.kill(session.pid, 0)
      }
      
      // Also check if Chrome is responding
      const response = await fetch(`http://localhost:${session.port}/json/version`)
      return response.ok
    } catch {
      return false
    }
  }

  static async getValidSession(): Promise<ChromeSession | null> {
    const session = this.loadSession()
    if (session && await this.isSessionValid(session)) {
      return session
    }
    this.clearSession()
    return null
  }
}
</file>

<file path="src/commands/hover.ts">
import { Args, Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Hover extends BaseCommand {
  static description = 'Hover over an element to trigger hover states and tooltips'

  static examples = [
    '<%= config.bin %> <%= command.id %> "#menu-item"',
    '<%= config.bin %> <%= command.id %> ".dropdown-toggle" --duration 2000',
    '<%= config.bin %> <%= command.id %> "button.info" --wait-for ".tooltip"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    duration: Flags.integer({
      char: 'd',
      description: 'Duration to keep hovering in milliseconds',
      default: 0,
    }),
    'wait-for': Flags.string({
      description: 'Wait for element to appear after hovering',
    }),
    position: Flags.string({
      description: 'Hover position relative to element (format: x,y)',
    }),
    force: Flags.boolean({
      description: 'Force hover even if element is obscured',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      required: true,
      description: 'CSS selector of element to hover over',
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Hover)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!, args.selector, flags)
  }

  private async executeCommand(page: Page, selector: string, flags: any): Promise<void> {
    try {
      this.logVerbose(`Looking for element: ${selector}`)
      
      // Wait for element to be present and visible
      await waitForElement(page, selector, { 
        state: 'visible',
        timeout: 30000 
      })
      
      // Build hover options
      const hoverOptions: any = {
        force: flags.force,
      }

      // Parse position if provided
      if (flags.position) {
        const [x, y] = flags.position.split(',').map((n: string) => parseInt(n.trim(), 10))
        if (!isNaN(x) && !isNaN(y)) {
          hoverOptions.position = { x, y }
          this.logVerbose('Hover position', { x, y })
        } else {
          this.warn('Invalid position format, ignoring position flag')
        }
      }

      this.log(`üéØ Hovering over element: ${selector}`)
      
      // Move mouse to element
      await page.hover(selector, hoverOptions)
      
      this.log(`‚úÖ Hovered over element: ${selector}`)
      
      // Wait for secondary element if specified
      if (flags['wait-for']) {
        this.log(`‚è≥ Waiting for: ${flags['wait-for']}`)
        try {
          await waitForElement(page, flags['wait-for'], {
            state: 'visible',
            timeout: 5000
          })
          this.log(`‚úÖ Element appeared: ${flags['wait-for']}`)
        } catch (error) {
          this.warn(`Element did not appear: ${flags['wait-for']}`)
        }
      }
      
      // If duration specified, keep hovering
      if (flags.duration > 0) {
        this.logVerbose(`Keeping hover for ${flags.duration}ms`)
        await new Promise(resolve => setTimeout(resolve, flags.duration))
      }

      // Log element info if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await page.$eval(selector, (el: Element) => {
            const rect = el.getBoundingClientRect()
            const styles = window.getComputedStyle(el)
            return {
              tagName: el.tagName.toLowerCase(),
              position: { x: rect.x, y: rect.y },
              size: { width: rect.width, height: rect.height },
              cursor: styles.cursor,
              hasTitle: !!el.getAttribute('title'),
              hasTooltip: !!el.getAttribute('data-tooltip') || !!el.getAttribute('data-bs-tooltip'),
            }
          })
          this.logVerbose('Hovered element info', elementInfo)
        } catch {
          // Element may have changed after hover
        }
      }
      
    } catch (error: any) {
      const commandError = handleCommandError(error, 'hover', selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/sessions.ts">
import { Flags } from '@oclif/core'
import { Command } from '@oclif/core'
import { execSync } from 'child_process'
import * as os from 'os'

interface ChromeInstance {
  port: number
  pid?: number
  version?: string
  tabs?: any[]
  error?: string
}

export default class Sessions extends Command {
  static description = 'List all Chrome instances with remote debugging enabled'

  static examples = [
    '<%= config.bin %> <%= command.id %>',
    '<%= config.bin %> <%= command.id %> --kill 9222',
    '<%= config.bin %> <%= command.id %> --kill-all',
  ]

  static flags = {
    kill: Flags.integer({
      description: 'Kill Chrome instance on specified port',
      required: false,
    }),
    'kill-all': Flags.boolean({
      description: 'Kill all Chrome instances with debugging enabled',
      default: false,
    }),
    verbose: Flags.boolean({
      char: 'v',
      description: 'Show detailed information about each instance',
      default: false,
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Sessions)

    // Find all Chrome instances with debugging ports
    const instances = await this.findChromeInstances()

    if (flags.verbose) {
      this.log('üîç Searching for Chrome instances...')
    }

    if (flags.kill) {
      await this.killInstance(flags.kill)
      return
    }

    if (flags['kill-all']) {
      await this.killAllInstances(instances)
      return
    }

    // Display found instances
    this.displayInstances(instances, flags.verbose)
  }

  private async findChromeInstances(): Promise<ChromeInstance[]> {
    const instances: ChromeInstance[] = []
    
    // Get all Chrome processes
    const platform = os.platform()
    let chromeProcesses: string = ''
    
    try {
      if (platform === 'darwin') {
        chromeProcesses = execSync('ps aux | grep -i "chrome.*remote-debugging-port" | grep -v grep', { encoding: 'utf8' })
      } else if (platform === 'linux') {
        chromeProcesses = execSync('ps aux | grep -i "chrom.*remote-debugging-port" | grep -v grep', { encoding: 'utf8' })
      } else if (platform === 'win32') {
        chromeProcesses = execSync('wmic process where "name like \'%chrome%\'" get processid,commandline /format:csv', { encoding: 'utf8' })
      }
    } catch (error) {
      // No Chrome processes found
      return instances
    }

    // Parse process list to find ports
    const portRegex = /--remote-debugging-port=(\d+)/
    const lines = chromeProcesses.split('\n').filter(line => line.trim())
    
    for (const line of lines) {
      const portMatch = line.match(portRegex)
      if (portMatch) {
        const port = parseInt(portMatch[1])
        const pidMatch = line.match(/^\s*\w+\s+(\d+)/)
        const pid = pidMatch ? parseInt(pidMatch[1]) : undefined
        
        // Try to connect to this port
        const instance = await this.checkChromeInstance(port, pid)
        instances.push(instance)
      }
    }

    // Also check common ports
    const commonPorts = [9222, 9223, 9224, 9225, 9226, 9227, 9228, 9229]
    for (const port of commonPorts) {
      // Skip if already found
      if (instances.find(i => i.port === port)) continue
      
      const instance = await this.checkChromeInstance(port)
      if (!instance.error) {
        instances.push(instance)
      }
    }

    // Also check saved session
    try {
      const savedSession = await fetch('http://localhost:9222/json/version')
      if (savedSession.ok) {
        const instance = await this.checkChromeInstance(9222)
        if (!instance.error && !instances.find(i => i.port === 9222)) {
          instances.push(instance)
        }
      }
    } catch (error) {
      // No saved session
    }

    return instances.filter(i => !i.error)
  }

  private async checkChromeInstance(port: number, pid?: number): Promise<ChromeInstance> {
    const instance: ChromeInstance = { port, pid }
    
    try {
      // Try to get version info
      const versionResponse = await fetch(`http://localhost:${port}/json/version`)
      
      if (versionResponse.ok) {
        const versionData = await versionResponse.json() as any
        instance.version = versionData.Browser || 'Unknown'
        
        // Get tabs/pages
        const tabsResponse = await fetch(`http://localhost:${port}/json/list`)
        if (tabsResponse.ok) {
          instance.tabs = await tabsResponse.json() as any[]
        }
      }
    } catch (error) {
      instance.error = 'Not responding'
    }
    
    return instance
  }

  private displayInstances(instances: ChromeInstance[], verbose: boolean): void {
    if (instances.length === 0) {
      this.log('‚ùå No Chrome instances with remote debugging found')
      this.log('üí° Start Chrome with: chromancer spawn')
      return
    }

    this.log(`üîç Found ${instances.length} Chrome instance(s) with remote debugging:\n`)
    
    for (const instance of instances) {
      this.log(`üìç Port: ${instance.port}`)
      if (instance.pid) {
        this.log(`   PID: ${instance.pid}`)
      }
      if (instance.version) {
        this.log(`   Version: ${instance.version}`)
      }
      if (instance.tabs) {
        this.log(`   Open tabs: ${instance.tabs.length}`)
        if (verbose) {
          for (const tab of instance.tabs) {
            this.log(`     - ${tab.title || 'Untitled'} (${tab.url})`)
          }
        }
      }
      this.log('')
    }

    this.log('üí° To connect: cdp navigate <url> --port <port>')
    this.log('üí° To kill: cdp sessions --kill <port>')
  }

  private async killInstance(port: number): Promise<void> {
    const instances = await this.findChromeInstances()
    const instance = instances.find(i => i.port === port)
    
    if (!instance) {
      this.error(`No Chrome instance found on port ${port}`)
    }

    if (instance.pid) {
      try {
        if (os.platform() === 'win32') {
          execSync(`taskkill /F /PID ${instance.pid}`)
        } else {
          execSync(`kill -9 ${instance.pid}`)
        }
        this.log(`‚úÖ Killed Chrome instance on port ${port} (PID: ${instance.pid})`)
      } catch (error) {
        this.error(`Failed to kill Chrome instance: ${error}`)
      }
    } else {
      this.error(`Could not find PID for Chrome instance on port ${port}`)
    }
  }

  private async killAllInstances(instances: ChromeInstance[]): Promise<void> {
    if (instances.length === 0) {
      this.log('‚ùå No Chrome instances to kill')
      return
    }

    let killed = 0
    for (const instance of instances) {
      if (instance.pid) {
        try {
          if (os.platform() === 'win32') {
            execSync(`taskkill /F /PID ${instance.pid}`)
          } else {
            execSync(`kill -9 ${instance.pid}`)
          }
          this.log(`‚úÖ Killed Chrome on port ${instance.port} (PID: ${instance.pid})`)
          killed++
        } catch (error) {
          this.log(`‚ùå Failed to kill Chrome on port ${instance.port}: ${error}`)
        }
      }
    }

    this.log(`\nüßπ Killed ${killed} Chrome instance(s)`)
  }
}
</file>

<file path="src/commands/wait.ts">
import { Flags } from '@oclif/core'
import { Page } from 'playwright'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError, isTimeoutError } from '../utils/errors.js'

export default class Wait extends BaseCommand {
  static description = 'Wait for elements or conditions before proceeding'

  static examples = [
    '<%= config.bin %> <%= command.id %> --selector "#dynamic-content"',
    '<%= config.bin %> <%= command.id %> --selector ".loading" --hidden',
    '<%= config.bin %> <%= command.id %> --condition "document.readyState === \'complete\'"',
    '<%= config.bin %> <%= command.id %> --page-load',
    '<%= config.bin %> <%= command.id %> --network-idle',
    '<%= config.bin %> <%= command.id %> --url "https://example.com"',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    selector: Flags.string({
      char: 's',
      description: 'CSS selector to wait for',
    }),
    condition: Flags.string({
      char: 'c',
      description: 'JavaScript condition to wait for',
    }),
    visible: Flags.boolean({
      description: 'Wait for element to be visible',
      default: false,
    }),
    hidden: Flags.boolean({
      description: 'Wait for element to be hidden',
      default: false,
    }),
    timeout: Flags.integer({
      char: 't',
      description: 'Maximum time to wait in milliseconds',
      default: 30000,
    }),
    'page-load': Flags.boolean({
      description: 'Wait for page load to complete',
      default: false,
    }),
    'network-idle': Flags.boolean({
      description: 'Wait for network to be idle',
      default: false,
    }),
    url: Flags.string({
      description: 'Wait for URL to match (supports partial match)',
    }),
    text: Flags.string({
      description: 'Wait for text to appear in the page',
    }),
  }

  async run(): Promise<void> {
    const { flags } = await this.parse(Wait)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('Failed to connect to Chrome')
    }

    await this.executeCommand(this.page!)
  }

  private async executeCommand(page: Page): Promise<void> {
    const { flags } = await this.parse(Wait)
    
    const waitPromises: Promise<any>[] = []
    const waitDescriptions: string[] = []

    // Wait for selector with visibility state
    if (flags.selector) {
      if (flags.visible) {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            state: 'visible', 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}" to be visible`)
      } else if (flags.hidden) {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            state: 'hidden', 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}" to be hidden`)
      } else {
        waitPromises.push(
          waitForElement(page, flags.selector, { 
            timeout: flags.timeout 
          })
        )
        waitDescriptions.push(`element "${flags.selector}"`)
      }
    }

    // Wait for custom condition
    if (flags.condition) {
      waitPromises.push(page.waitForFunction(flags.condition, {
        timeout: flags.timeout,
      }))
      waitDescriptions.push(`condition "${flags.condition}"`)
    }

    // Wait for page load
    if (flags['page-load']) {
      waitPromises.push(page.waitForLoadState('load', {
        timeout: flags.timeout,
      }))
      waitDescriptions.push('page load')
    }

    // Wait for network idle
    if (flags['network-idle']) {
      waitPromises.push(page.waitForLoadState('networkidle', {
        timeout: flags.timeout,
      }))
      waitDescriptions.push('network idle')
    }

    // Wait for URL
    if (flags.url) {
      waitPromises.push(page.waitForURL(flags.url, {
        timeout: flags.timeout,
      }))
      waitDescriptions.push(`URL to match "${flags.url}"`)
    }

    // Wait for text
    if (flags.text) {
      waitPromises.push(
        page.waitForFunction(
          (text) => document.body.textContent?.includes(text),
          flags.text,
          { timeout: flags.timeout }
        )
      )
      waitDescriptions.push(`text "${flags.text}" to appear`)
    }

    // If no wait conditions specified, show error
    if (waitPromises.length === 0) {
      this.error('No wait condition specified. Use --selector, --condition, --page-load, --network-idle, --url, or --text')
    }

    try {
      this.log(`‚è≥ Waiting for ${waitDescriptions.join(' and ')}...`)
      
      // Wait for all conditions
      await Promise.all(waitPromises)
      
      if (waitDescriptions.length === 1) {
        if (flags.selector && flags.visible) {
          this.log(`‚úÖ Element is visible: ${flags.selector}`)
        } else if (flags.selector && flags.hidden) {
          this.log(`‚úÖ Element is hidden: ${flags.selector}`)
        } else if (flags.selector) {
          this.log(`‚úÖ Element found: ${flags.selector}`)
        } else if (flags.condition) {
          this.log(`‚úÖ Condition met: ${flags.condition}`)
        } else if (flags['page-load']) {
          this.log('‚úÖ Page loaded')
        } else if (flags['network-idle']) {
          this.log('‚úÖ Network idle')
        } else if (flags.url) {
          this.log(`‚úÖ URL matched: ${page.url()}`)
        } else if (flags.text) {
          this.log(`‚úÖ Text found: "${flags.text}"`)
        }
      } else {
        this.log(`‚úÖ All conditions met`)
      }

      // Log additional info if verbose
      if (flags.verbose) {
        this.logVerbose('Wait completed', {
          conditions: waitDescriptions,
          currentUrl: page.url(),
          title: await page.title(),
        })
      }
    } catch (error: any) {
      if (isTimeoutError(error)) {
        this.error(`Timeout waiting for ${waitDescriptions.join(' and ')} (${flags.timeout}ms)`)
      }
      const commandError = handleCommandError(error, 'wait')
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/evaluate.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { safeEvaluate } from '../utils/evaluation.js'

export default class Evaluate extends BaseCommand {
  static description = 'Execute JavaScript in the page context'

  static examples = [
    '<%= config.bin %> <%= command.id %> "document.title"',
    '<%= config.bin %> <%= command.id %> "document.querySelectorAll(\'a\').length" --return-result',
    '<%= config.bin %> <%= command.id %> "localStorage.getItem(\'token\')" --json',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'return-result': Flags.boolean({
      description: 'Print the result of the evaluation',
      default: true,
    }),
    json: Flags.boolean({
      description: 'Output result as raw JSON',
      default: false,
    }),
    selector: Flags.string({
      description: 'Evaluate within the context of a specific element',
    }),
  }

  static args = {
    script: Args.string({
      description: 'JavaScript code to execute',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Evaluate)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      this.log(`üîß Evaluating JavaScript...`)
      this.logVerbose('Script to evaluate', { script: args.script })

      let result: any

      if (flags.selector) {
        // Evaluate within element context
        this.log(`üìç Using element context: ${flags.selector}`)
        const element = await this.page!.$(flags.selector)
        if (!element) {
          this.error(`Element not found: ${flags.selector}`)
        }
        
        result = await element!.evaluate((el, script) => {
          // Create a function that has 'el' in scope
          const fn = new Function('el', `return ${script}`)
          return fn(el)
        }, args.script)
      } else {
        // Evaluate in page context
        result = await safeEvaluate(this.page!, args.script)
      }
      
      if (flags['return-result']) {
        if (flags.json) {
          // Raw JSON output for scripting
          console.log(JSON.stringify(result))
        } else {
          // Pretty formatted output
          this.log('üì§ Result:')
          if (result === undefined) {
            this.log('undefined')
          } else if (result === null) {
            this.log('null')
          } else if (typeof result === 'object') {
            this.log(JSON.stringify(result, null, 2))
          } else {
            this.log(String(result))
          }
        }

        // Log type information if verbose
        if (flags.verbose && !flags.json) {
          this.logVerbose('Result type', {
            type: typeof result,
            isArray: Array.isArray(result),
            constructor: result?.constructor?.name,
          })
        }
      } else {
        this.log('‚úÖ JavaScript executed successfully')
      }

      // Log performance metrics if verbose
      if (flags.verbose) {
        const metrics = await this.page!.evaluate(() => {
          if (typeof performance !== 'undefined' && (performance as any).memory) {
            return {
              usedJSHeapSize: Math.round((performance as any).memory.usedJSHeapSize / 1024 / 1024) + 'MB',
              totalJSHeapSize: Math.round((performance as any).memory.totalJSHeapSize / 1024 / 1024) + 'MB',
            }
          }
          return null
        })
        if (metrics) {
          this.logVerbose('Memory usage', metrics)
        }
      }
    } catch (error: any) {
      if (error.name === 'SyntaxError' || error.message.includes('SyntaxError')) {
        this.error(`JavaScript syntax error: ${error.message}`)
      }
      this.error(`Failed to evaluate JavaScript: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/navigate.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'

export default class Navigate extends BaseCommand {
  static description = 'Navigate to a URL in Chrome'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> https://example.com --wait-until networkidle',
    '<%= config.bin %> <%= command.id %> https://example.com --profile personal',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'wait-until': Flags.string({
      description: 'When to consider navigation succeeded',
      options: ['load', 'domcontentloaded', 'networkidle', 'commit'],
      default: 'load',
    }),
    timeout: Flags.integer({
      description: 'Maximum navigation time in milliseconds',
      default: 30000,
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to navigate to',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Navigate)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    // Set up verbose logging event listeners
    if (flags.verbose) {
      this.setupVerbosePageListeners()
    }

    try {
      this.log(`üåê Navigating to ${args.url}...`)
      this.logVerbose('Navigation options', {
        url: args.url,
        waitUntil: flags['wait-until'],
        timeout: flags.timeout,
      })

      const startTime = Date.now()
      const response = await this.page!.goto(args.url, {
        waitUntil: flags['wait-until'] as any,
        timeout: flags.timeout,
      })

      const loadTime = Date.now() - startTime
      
      if (response) {
        const status = response.status()
        this.log(`‚úÖ Navigated to ${args.url} (${status} - ${loadTime}ms)`)
        
        if (flags.verbose) {
          const metrics = await this.page!.evaluate(() => {
            const timing = performance.timing
            return {
              domContentLoaded: timing.domContentLoadedEventEnd - timing.domContentLoadedEventStart,
              loadComplete: timing.loadEventEnd - timing.loadEventStart,
              domInteractive: timing.domInteractive - timing.navigationStart,
              responseEnd: timing.responseEnd - timing.requestStart,
            }
          })
          
          this.logVerbose('Performance metrics', metrics)
        }
      } else {
        this.log(`‚úÖ Navigated to ${args.url} (${loadTime}ms)`)
      }

      // Get final page info
      const title = await this.page!.title()
      const finalUrl = this.page!.url()
      
      if (title) {
        this.log(`üìÑ Page title: "${title}"`)
      }
      
      if (finalUrl !== args.url) {
        this.log(`üîÄ Final URL: ${finalUrl}`)
      }
    } catch (error: any) {
      if (error.name === 'TimeoutError') {
        this.error(`Navigation timeout: Failed to navigate to ${args.url} within ${flags.timeout}ms`)
      }
      this.error(`Navigation failed: ${error.message}`)
    }
  }

  private setupVerbosePageListeners(): void {
    if (!this.page) return

    // Request logging
    this.page.on('request', request => {
      this.logVerbose(`üì§ Request: ${request.method()} ${request.url()}`)
    })

    // Response logging
    this.page.on('response', response => {
      this.logVerbose(`üì• Response: ${response.status()} ${response.url()}`)
    })

    // Console logging
    this.page.on('console', msg => {
      this.logVerbose(`üñ•Ô∏è  Console [${msg.type()}]: ${msg.text()}`)
    })

    // Page errors
    this.page.on('pageerror', error => {
      this.logVerbose(`‚ùå Page error: ${error.message}`)
    })

    // Frame navigation
    this.page.on('framenavigated', frame => {
      if (frame === this.page!.mainFrame()) {
        this.logVerbose(`üîÑ Main frame navigated to: ${frame.url()}`)
      }
    })

    // Downloads
    this.page.on('download', download => {
      this.logVerbose(`‚¨áÔ∏è  Download started: ${download.suggestedFilename()}`)
    })
  }
}
</file>

<file path="src/commands/screenshot.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as fs from 'fs/promises'
import * as path from 'path'

export default class Screenshot extends BaseCommand {
  static description = 'Take a screenshot of the current page'

  static examples = [
    '<%= config.bin %> <%= command.id %> screenshot.png',
    '<%= config.bin %> <%= command.id %> fullpage.png --full-page',
    '<%= config.bin %> <%= command.id %> element.png --selector ".main-content"',
    '<%= config.bin %> <%= command.id %> mobile.png --viewport 375x667',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'full-page': Flags.boolean({
      description: 'Capture full scrollable page',
      default: false,
    }),
    format: Flags.string({
      description: 'Screenshot format',
      options: ['png', 'jpeg', 'webp'],
      default: 'png',
    }),
    quality: Flags.integer({
      description: 'Quality (0-100) for JPEG/WebP format',
      default: 80,
    }),
    selector: Flags.string({
      description: 'CSS selector of element to screenshot',
    }),
    'omit-background': Flags.boolean({
      description: 'Make background transparent (PNG only)',
      default: false,
    }),
    viewport: Flags.string({
      description: 'Set viewport size before screenshot (format: widthxheight)',
    }),
    scale: Flags.string({
      description: 'Device scale factor',
      options: ['css', 'device'],
      default: 'device',
    }),
  }

  static args = {
    filename: Args.string({
      description: 'Output filename',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Screenshot)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      // Set viewport if specified
      if (flags.viewport) {
        const [width, height] = flags.viewport.split('x').map(n => parseInt(n, 10))
        if (!isNaN(width) && !isNaN(height)) {
          this.log(`üìê Setting viewport to ${width}x${height}`)
          await this.page!.setViewportSize({ width, height })
        } else {
          this.warn('Invalid viewport format, ignoring viewport flag')
        }
      }

      this.log(`üì∏ Taking screenshot...`)

      // Ensure directory exists
      const dir = path.dirname(args.filename)
      if (dir && dir !== '.') {
        await fs.mkdir(dir, { recursive: true })
      }

      const screenshotOptions: any = {
        path: args.filename,
        fullPage: flags['full-page'],
        type: flags.format as 'png' | 'jpeg' | 'webp',
        scale: flags.scale as 'css' | 'device',
      }

      // Add quality for JPEG/WebP
      if (flags.format === 'jpeg' || flags.format === 'webp') {
        screenshotOptions.quality = flags.quality
      }

      // Add transparent background option for PNG
      if (flags.format === 'png' && flags['omit-background']) {
        screenshotOptions.omitBackground = true
      }

      // Take screenshot of specific element or full page
      if (flags.selector) {
        this.log(`üéØ Capturing element: ${flags.selector}`)
        const element = await this.page!.$(flags.selector)
        if (!element) {
          this.error(`Element not found: ${flags.selector}`)
        }
        await element!.screenshot(screenshotOptions)
      } else {
        await this.page!.screenshot(screenshotOptions)
      }

      const absolutePath = path.resolve(args.filename)
      const stats = await fs.stat(args.filename)
      const sizeMB = (stats.size / 1024 / 1024).toFixed(2)
      
      this.log(`‚úÖ Screenshot saved to: ${absolutePath}`)
      this.log(`üìä File size: ${sizeMB} MB`)

      // Log screenshot details if verbose
      if (flags.verbose) {
        const pageInfo = await this.page!.evaluate(() => ({
          title: document.title,
          url: window.location.href,
          viewport: {
            width: window.innerWidth,
            height: window.innerHeight,
          },
          documentSize: {
            width: document.documentElement.scrollWidth,
            height: document.documentElement.scrollHeight,
          },
        }))
        
        this.logVerbose('Screenshot details', {
          format: flags.format,
          fullPage: flags['full-page'],
          selector: flags.selector || 'page',
          ...pageInfo,
        })
      }
    } catch (error: any) {
      this.error(`Failed to take screenshot: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/select.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import * as inquirer from 'inquirer'
import * as clipboardy from 'clipboardy'

export default class Select extends BaseCommand {
  static description = 'Find and inspect elements by CSS selector'

  static examples = [
    '<%= config.bin %> <%= command.id %> button',
    '<%= config.bin %> <%= command.id %> "a[href]"',
    '<%= config.bin %> <%= command.id %> ".my-class" --attributes',
    '<%= config.bin %> <%= command.id %> button --interactive',
    '<%= config.bin %> <%= command.id %> "input[type=text]" --limit 10',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    attributes: Flags.boolean({
      char: 'a',
      description: 'Include element attributes in output',
      default: false,
    }),
    limit: Flags.integer({
      char: 'l',
      description: 'Limit number of results',
      default: 50,
    }),
    interactive: Flags.boolean({
      char: 'i',
      description: 'Interactively select an element and copy its selector to clipboard',
      default: false,
    }),
    visible: Flags.boolean({
      description: 'Only show visible elements',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector to find elements',
      required: true,
    }),
  }

  public async run(): Promise<void> {
    const { args, flags } = await this.parse(Select)

    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )

    if (!this.page) {
      this.error('No page available')
    }

    try {
      // First check if any elements exist
      const count = await this.page!.locator(args.selector).count()
      
      if (count === 0) {
        this.log(`‚ùå No elements found matching "${args.selector}"`)
        return
      }

      this.log(`üîç Found ${count} element(s) matching "${args.selector}"`)
      
      const limit = Math.min(count, flags.limit)
      if (count > flags.limit) {
        this.log(`üìä Showing first ${flags.limit} results (use --limit to change)`)
      }

      // Collect element information
      const elements = []
      for (let i = 0; i < limit; i++) {
        const locator = this.page!.locator(args.selector).nth(i)
        
        // Check visibility if flag is set
        if (flags.visible) {
          const isVisible = await locator.isVisible()
          if (!isVisible) continue
        }

        const elementInfo = await locator.evaluate((el, index) => {
          const rect = el.getBoundingClientRect()
          
          // Generate best selector for element
          function getBestSelector(element: Element): string {
            // Priority 1: ID
            if (element.id) {
              return '#' + element.id
            }
            
            // Priority 2: Unique class combination
            if (element.className) {
              const classes = element.className.split(' ').filter(c => c.trim())
              const validClasses = classes.filter(c => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c))
              
              if (validClasses.length > 0) {
                const firstClassSelector = '.' + validClasses[0]
                if (document.querySelectorAll(firstClassSelector).length === 1) {
                  return firstClassSelector
                }
                
                for (let i = 2; i <= Math.min(validClasses.length, 3); i++) {
                  const classSelector = '.' + validClasses.slice(0, i).join('.')
                  try {
                    if (document.querySelectorAll(classSelector).length === 1) {
                      return classSelector
                    }
                  } catch (e) {
                    // Invalid selector, skip
                  }
                }
              }
            }
            
            // Priority 3: Unique attribute
            const uniqueAttrs = ['name', 'type', 'placeholder', 'aria-label', 'data-testid']
            for (const attr of uniqueAttrs) {
              if (element.hasAttribute(attr)) {
                const value = element.getAttribute(attr)
                const selector = element.tagName.toLowerCase() + '[' + attr + '="' + value + '"]'
                if (document.querySelectorAll(selector).length === 1) {
                  return selector
                }
              }
            }
            
            // Priority 4: nth-of-type with parent context
            const parent = element.parentElement
            const siblings = parent ? Array.from(parent.children).filter(child => 
              child.tagName === element.tagName
            ) : []
            const indexInType = siblings.indexOf(element) + 1
            
            if (parent && parent.id) {
              return '#' + parent.id + ' > ' + element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
            }
            
            if (parent && parent.className) {
              const parentClasses = parent.className.split(' ').filter(c => c.trim())
              const validParentClasses = parentClasses.filter(c => /^[a-zA-Z_-][a-zA-Z0-9_-]*$/.test(c))
              if (validParentClasses.length > 0) {
                return '.' + validParentClasses[0] + ' > ' + element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
              }
            }
            
            // Fallback: tag with index
            return element.tagName.toLowerCase() + ':nth-of-type(' + indexInType + ')'
          }
          
          const info: any = {
            index: index,
            tagName: el.tagName.toLowerCase(),
            selector: getBestSelector(el),
            textContent: el.textContent?.trim().substring(0, 100) || '',
            visible: rect.width > 0 && rect.height > 0 && rect.top >= 0 && rect.left >= 0,
            position: {
              top: Math.round(rect.top),
              left: Math.round(rect.left),
              width: Math.round(rect.width),
              height: Math.round(rect.height),
            },
          }
          
          if (el.id) {
            info.id = el.id
          }
          
          if (el.className) {
            info.classes = el.className.split(' ').filter((c: string) => c.trim())
          }
          
          // Get attributes if requested
          const attrs: Record<string, string> = {}
          for (let i = 0; i < el.attributes.length; i++) {
            const attr = el.attributes[i]
            attrs[attr.name] = attr.value
          }
          info.attributes = attrs
          
          return info
        }, i)
        
        elements.push(elementInfo)
      }

      if (flags.interactive && elements.length > 0) {
        // Interactive mode - show selection menu
        const choices = elements.map((el: any) => {
          const visibilityIcon = el.visible ? '‚úì' : '‚úó'
          const text = el.textContent ? ` - "${el.textContent.substring(0, 50)}${el.textContent.length > 50 ? '...' : ''}"` : ''
          return {
            name: `[${el.index}] <${el.tagName}> ${visibilityIcon} ${el.selector}${text}`,
            value: el.selector,
            short: el.selector,
          }
        })
        
        const { selectedSelector } = await inquirer.prompt([
          {
            type: 'list',
            name: 'selectedSelector',
            message: 'Select an element to copy its selector:',
            choices,
            pageSize: 15,
          },
        ])
        
        try {
          await clipboardy.write(selectedSelector)
          this.log(`\n‚úÖ Copied selector to clipboard: ${selectedSelector}`)
        } catch (error) {
          this.log(`\n‚ùå Failed to copy to clipboard: ${selectedSelector}`)
          this.log('  You can manually copy the selector above')
        }
      } else {
        // Regular output mode
        this.log('---')
        
        for (const el of elements) {
          this.log(`[${el.index}] <${el.tagName}> ${el.visible ? '‚úì visible' : '‚úó hidden'}`)
          this.log(`  Selector: ${el.selector}`)
          
          if (el.id) {
            this.log(`  ID: ${el.id}`)
          }
          
          if (el.classes && el.classes.length > 0) {
            this.log(`  Classes: ${el.classes.join(', ')}`)
          }
          
          if (el.textContent) {
            this.log(`  Text: "${el.textContent}"`)
          }
          
          this.log(`  Position: ${el.position.left}x${el.position.top} (${el.position.width}x${el.position.height})`)
          
          if (flags.attributes && el.attributes && Object.keys(el.attributes).length > 0) {
            this.log('  Attributes:')
            for (const [key, value] of Object.entries(el.attributes)) {
              if (key !== 'id' && key !== 'class') {
                this.log(`    ${key}: "${value}"`)
              }
            }
          }
          
          this.log('')
        }
      }

      // Log summary if verbose
      if (flags.verbose) {
        const visibleCount = elements.filter((el: any) => el.visible).length
        this.logVerbose('Element summary', {
          total: count,
          shown: elements.length,
          visible: visibleCount,
          hidden: elements.length - visibleCount,
        })
      }
    } catch (error: any) {
      this.error(`Failed to select elements: ${error.message}`)
    }
  }
}
</file>

<file path="src/commands/type.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Type extends BaseCommand {
  static description = 'Type text into an element'

  static examples = [
    '<%= config.bin %> <%= command.id %> "input[name=email]" "user@example.com"',
    '<%= config.bin %> <%= command.id %> "#search-box" "search query" --clear-first',
    '<%= config.bin %> <%= command.id %> "textarea" "multi\\nline\\ntext" --press-enter',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'clear-first': Flags.boolean({
      description: 'Clear existing text before typing',
      default: false,
    }),
    delay: Flags.integer({
      description: 'Delay between key presses in milliseconds',
      default: 0,
    }),
    'wait-for-selector': Flags.boolean({
      description: 'Wait for selector to be available before typing',
      default: true,
    }),
    timeout: Flags.integer({
      description: 'Maximum time to wait for selector in milliseconds',
      default: 30000,
    }),
    'press-enter': Flags.boolean({
      description: 'Press Enter key after typing',
      default: false,
    }),
    'press-tab': Flags.boolean({
      description: 'Press Tab key after typing',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector of element to type into',
      required: true,
    }),
    text: Args.string({
      description: 'Text to type (use \\n for newlines)',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Type)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      if (flags['wait-for-selector']) {
        this.log(`‚è≥ Waiting for selector: ${args.selector}`)
        await waitForElement(this.page!, args.selector, { 
          timeout: flags.timeout,
          state: 'visible' 
        })
      }

      // Focus the element first
      await this.page!.focus(args.selector)

      if (flags['clear-first']) {
        this.log(`üßπ Clearing existing text in: ${args.selector}`)
        // Playwright's fill method clears by default, but for type we need to manually clear
        await this.page!.click(args.selector, { clickCount: 3 })
        await this.page!.keyboard.press('Delete')
      }

      // Process text to handle escape sequences
      const processedText = args.text.replace(/\\n/g, '\n').replace(/\\t/g, '\t')

      this.log(`‚å®Ô∏è  Typing into: ${args.selector}`)
      this.logVerbose('Type options', {
        text: processedText,
        delay: flags.delay,
        clearFirst: flags['clear-first'],
      })

      // Use type method for more natural typing with delay
      await this.page!.type(args.selector, processedText, {
        delay: flags.delay,
      })

      // Press additional keys if requested
      if (flags['press-enter']) {
        this.log('‚èé Pressing Enter')
        await this.page!.keyboard.press('Enter')
      }

      if (flags['press-tab']) {
        this.log('‚á• Pressing Tab')
        await this.page!.keyboard.press('Tab')
      }

      this.log(`‚úÖ Successfully typed text into: ${args.selector}`)

      // Log element value if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await this.page!.$eval(args.selector, (el: Element) => {
            const input = el as HTMLInputElement | HTMLTextAreaElement
            return {
              tagName: el.tagName.toLowerCase(),
              type: (el as HTMLInputElement).type || null,
              value: input.value || null,
              textContent: el.textContent?.trim().substring(0, 50),
            }
          })
          this.logVerbose('Element state after typing', elementInfo)
        } catch {
          // Element may not support value property
        }
      }
    } catch (error: any) {
      const commandError = handleCommandError(error, 'type', args.selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/click.ts">
import { Args, Flags } from '@oclif/core'
import { BaseCommand } from '../base.js'
import { waitForElement } from '../utils/selectors.js'
import { handleCommandError } from '../utils/errors.js'

export default class Click extends BaseCommand {
  static description = 'Click an element by CSS selector'

  static examples = [
    '<%= config.bin %> <%= command.id %> "button.submit"',
    '<%= config.bin %> <%= command.id %> "#login-button" --wait-for-selector',
    '<%= config.bin %> <%= command.id %> "a.link" --right-click',
  ]

  static flags = {
    ...BaseCommand.baseFlags,
    'wait-for-selector': Flags.boolean({
      description: 'Wait for selector to be available before clicking',
      default: true,
    }),
    timeout: Flags.integer({
      description: 'Maximum time to wait for selector in milliseconds',
      default: 30000,
    }),
    'click-count': Flags.integer({
      description: 'Number of clicks',
      default: 1,
    }),
    button: Flags.string({
      description: 'Mouse button to use',
      options: ['left', 'right', 'middle'],
      default: 'left',
    }),
    'right-click': Flags.boolean({
      description: 'Perform a right-click instead of left-click',
      default: false,
    }),
    position: Flags.string({
      description: 'Click position relative to element (format: x,y)',
    }),
    modifiers: Flags.string({
      description: 'Modifier keys to press during click (comma-separated: Alt,Control,Meta,Shift)',
    }),
    force: Flags.boolean({
      description: 'Force click even if element is obscured',
      default: false,
    }),
  }

  static args = {
    selector: Args.string({
      description: 'CSS selector of element to click',
      required: true,
    }),
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Click)
    
    await this.connectToChrome(
      flags.port,
      flags.host,
      flags.launch,
      flags.profile,
      flags.headless,
      flags.verbose,
      flags.keepOpen
    )
    
    if (!this.page) {
      this.error('No page available')
    }

    try {
      if (flags['wait-for-selector']) {
        this.log(`‚è≥ Waiting for selector: ${args.selector}`)
        await waitForElement(this.page!, args.selector, { timeout: flags.timeout })
      }

      // Parse click options
      const clickOptions: any = {
        clickCount: flags['click-count'],
        button: flags['right-click'] ? 'right' : flags.button as 'left' | 'right' | 'middle',
        force: flags.force,
      }

      // Parse position if provided
      if (flags.position) {
        const [x, y] = flags.position.split(',').map(n => parseInt(n.trim(), 10))
        if (!isNaN(x) && !isNaN(y)) {
          clickOptions.position = { x, y }
          this.logVerbose('Click position', { x, y })
        } else {
          this.warn('Invalid position format, ignoring position flag')
        }
      }

      // Parse modifiers if provided
      if (flags.modifiers) {
        clickOptions.modifiers = flags.modifiers
          .split(',')
          .map(m => m.trim())
          .filter(m => ['Alt', 'Control', 'Meta', 'Shift'].includes(m))
        if (clickOptions.modifiers.length > 0) {
          this.logVerbose('Click modifiers', clickOptions.modifiers)
        }
      }

      this.log(`üñ±Ô∏è  Clicking on: ${args.selector}`)
      this.logVerbose('Click options', clickOptions)

      await this.page!.click(args.selector, clickOptions)
      
      this.log(`‚úÖ Successfully clicked on: ${args.selector}`)

      // Log element info if verbose
      if (flags.verbose) {
        try {
          const elementInfo = await this.page!.$eval(args.selector, (el: Element) => {
            const rect = el.getBoundingClientRect()
            return {
              tagName: el.tagName.toLowerCase(),
              text: el.textContent?.trim().substring(0, 50),
              classList: Array.from(el.classList),
              position: { x: rect.x, y: rect.y },
              size: { width: rect.width, height: rect.height },
            }
          })
          this.logVerbose('Clicked element info', elementInfo)
        } catch {
          // Element may have been removed after click
        }
      }
    } catch (error: any) {
      const commandError = handleCommandError(error, 'click', args.selector)
      this.error(commandError.message)
    }
  }
}
</file>

<file path="src/commands/spawn.ts">
import { Args, Command, Flags } from '@oclif/core'
import { chromium } from 'playwright'
import * as net from 'net'
import * as path from 'path'
import * as os from 'os'
import { SessionManager } from '../session.js'

export default class Spawn extends Command {
  static description = 'Spawn a Chrome browser instance with remote debugging'

  static examples = [
    '<%= config.bin %> <%= command.id %> https://example.com',
    '<%= config.bin %> <%= command.id %> https://example.com --port 9223',
    '<%= config.bin %> <%= command.id %> https://example.com --headless',
    '<%= config.bin %> <%= command.id %> --profile work  # Opens with work profile',
    '<%= config.bin %> <%= command.id %> --headless  # Opens about:blank in headless mode',
  ]

  static flags = {
    port: Flags.integer({
      char: 'p',
      description: 'Remote debugging port',
      default: 9222,
    }),
    headless: Flags.boolean({
      description: 'Run Chrome in headless mode',
      default: false,
    }),
    profile: Flags.string({
      description: 'Chrome profile name or path to use',
    }),
  }

  static args = {
    url: Args.string({
      description: 'URL to open in Chrome',
      required: false,
      default: 'about:blank',
    }),
  }

  private getProfilePath(profileName: string): string {
    // If it's already an absolute path, use it
    if (path.isAbsolute(profileName)) {
      return profileName
    }

    // Otherwise, create profile in user's home directory
    const platform = process.platform
    let profileBase: string

    if (platform === 'win32') {
      profileBase = path.join(os.homedir(), 'AppData', 'Local', 'chromancer', 'profiles')
    } else if (platform === 'darwin') {
      profileBase = path.join(os.homedir(), 'Library', 'Application Support', 'chromancer', 'profiles')
    } else {
      profileBase = path.join(os.homedir(), '.config', 'chromancer', 'profiles')
    }

    return path.join(profileBase, profileName)
  }

  async run(): Promise<void> {
    const { args, flags } = await this.parse(Spawn)
    
    try {
      this.log(`üöÄ Launching Chrome with remote debugging on port ${flags.port}...`)
      
      const launchOptions: any = {
        headless: flags.headless,
        args: [
          `--remote-debugging-port=${flags.port}`,
          '--no-first-run',
          '--no-default-browser-check',
        ],
        channel: 'chrome',
        // Keep browser running after script ends
        handleSIGINT: false,
        handleSIGTERM: false,
        handleSIGHUP: false,
      }
      
      // Add profile support
      if (flags.profile) {
        const profilePath = this.getProfilePath(flags.profile)
        this.log(`üìÅ Using Chrome profile: ${profilePath}`)
        launchOptions.args.push(`--user-data-dir=${profilePath}`)
      }
      
      const browser = await chromium.launch(launchOptions)
      const context = browser.contexts()[0] || await browser.newContext()
      const page = context.pages()[0] || await context.newPage()
      
      // Navigate to the specified URL
      if (args.url && args.url !== 'about:blank') {
        await page.goto(args.url)
      }
      
      // Playwright doesn't expose wsEndpoint directly, but we can use the port
      const wsEndpoint = `ws://localhost:${flags.port}`
      
      this.log(`‚úÖ Chrome launched successfully!`)
      this.log(`üîó Remote debugging URL: http://localhost:${flags.port}`)
      this.log(`üîå WebSocket endpoint: ${wsEndpoint}`)
      
      if (flags.profile) {
        this.log(`üìÅ Profile: ${flags.profile}`)
      }
      
      this.log(`\nüí° To connect from another terminal:`)
      this.log(`   chromancer navigate https://example.com --port ${flags.port}`)
      this.log(`   chromancer click "#button" --port ${flags.port}`)
      
      this.log(`\n‚åõ Chrome will stay open. Press Ctrl+C to close.`)
      
      // Keep the process alive
      process.on('SIGINT', async () => {
        this.log('\nüîí Closing Chrome...')
        await browser.close()
        process.exit(0)
      })
      
      // Prevent the process from exiting
      await new Promise(() => {})
    } catch (error: any) {
      this.error(`Failed to spawn Chrome: ${error.message}`)
    }
  }
}
</file>

<file path="src/base.ts">
import { Command, Flags } from '@oclif/core'
import { chromium, Browser, Page, BrowserContext } from 'playwright'
import { SessionManager } from './session.js'
import * as path from 'path'
import * as os from 'os'
import { displayErrorWithTip, enhanceError } from './utils/error-tips.js'

export abstract class BaseCommand extends Command {
  static baseFlags = {
    port: Flags.integer({
      char: 'p',
      description: 'Chrome debugging port',
      default: 9222,
    }),
    host: Flags.string({
      char: 'h',
      description: 'Chrome debugging host',
      default: 'localhost',
    }),
    launch: Flags.boolean({
      char: 'l',
      description: 'Launch Chrome automatically',
      default: false,
    }),
    profile: Flags.string({
      description: 'Chrome profile name or path to use',
    }),
    headless: Flags.boolean({
      description: 'Run Chrome in headless mode',
      default: false,
    }),
    verbose: Flags.boolean({
      char: 'v',
      description: 'Enable verbose logging for debugging',
      default: false,
    }),
    keepOpen: Flags.boolean({
      char: 'k',
      description: 'Keep Chrome open after command completes',
      default: true,
      allowNo: true,
    }),
  }

  protected browser?: Browser
  protected context?: BrowserContext
  protected page?: Page
  private isLaunched = false
  protected verbose = false
  private keepOpen = false

  protected logVerbose(message: string, data?: any): void {
    if (this.verbose) {
      const timestamp = new Date().toISOString()
      const prefix = `[${timestamp}] [VERBOSE]`
      if (data) {
        this.log(`${prefix} ${message}`, JSON.stringify(data, null, 2))
      } else {
        this.log(`${prefix} ${message}`)
      }
    }
  }

  private getProfilePath(profileName: string): string {
    // If it's already an absolute path, use it
    if (path.isAbsolute(profileName)) {
      return profileName
    }

    // Otherwise, create profile in user's home directory
    const platform = process.platform
    let profileBase: string

    if (platform === 'win32') {
      profileBase = path.join(os.homedir(), 'AppData', 'Local', 'chromancer', 'profiles')
    } else if (platform === 'darwin') {
      profileBase = path.join(os.homedir(), 'Library', 'Application Support', 'chromancer', 'profiles')
    } else {
      profileBase = path.join(os.homedir(), '.config', 'chromancer', 'profiles')
    }

    return path.join(profileBase, profileName)
  }

  async connectToChrome(
    port: number = 9222,
    host: string = 'localhost',
    launch: boolean = false,
    profile?: string,
    headless: boolean = false,
    verbose: boolean = false,
    keepOpen: boolean = true
  ): Promise<void> {
    this.verbose = verbose
    this.keepOpen = keepOpen
    const startTime = Date.now()
    
    this.logVerbose('Starting Chrome connection process', { port, host, launch, profile, headless })
    
    const browserURL = `http://${host}:${port}`
    
    try {
      // First try to connect to existing Chrome instance
      this.log(`üîç Attempting to connect to Chrome at ${browserURL}...`)
      
      this.browser = await chromium.connectOverCDP(browserURL)
      this.context = this.browser.contexts()[0]
      
      this.log('‚úÖ Connected to existing Chrome instance')
      this.logVerbose(`Connection successful in ${Date.now() - startTime}ms`)
    } catch (connectError: any) {
      this.log(`‚ùå No existing Chrome instance found at ${browserURL}`)
      this.logVerbose('Connection failed', { error: connectError.message })
      
      if (launch) {
        try {
          this.log('üöÄ Launching new Chrome instance...')
          
          const launchOptions: any = {
            headless,
            args: [
              `--remote-debugging-port=${port}`,
              '--no-first-run',
              '--no-default-browser-check',
            ],
            channel: 'chrome',
          }
          
          // Add profile support
          if (profile) {
            const profilePath = this.getProfilePath(profile)
            this.log(`üìÅ Using Chrome profile: ${profilePath}`)
            launchOptions.args.push(`--user-data-dir=${profilePath}`)
          }
          
          this.browser = await chromium.launch(launchOptions)
          this.context = await this.browser.newContext()
          this.isLaunched = true
          
          this.log(`‚úÖ Chrome launched successfully${profile ? ` with profile "${profile}"` : ''}`)
          this.logVerbose(`Chrome launched in ${Date.now() - startTime}ms`)
        } catch (launchError: any) {
          this.error(`Failed to launch Chrome: ${launchError.message}`)
        }
      } else {
        this.error(`Failed to connect to Chrome at ${host}:${port}. 

Possible solutions:
1. Use --launch flag to start a new Chrome instance
2. Use 'chromancer spawn' to start a persistent Chrome instance
3. Start Chrome manually with: chrome --remote-debugging-port=${port}`)
      }
    }

    if (this.browser && this.context) {
      // Get or create a page
      const pages = this.context.pages()
      this.page = pages[0] || await this.context.newPage()
      
      this.logVerbose('Page setup complete', { 
        totalPages: pages.length,
        newPageCreated: pages.length === 0
      })
      
      const totalTime = Date.now() - startTime
      this.logVerbose(`Total connection time: ${totalTime}ms`)
    }
  }

  async waitForLogin(url: string, readySelector?: string): Promise<void> {
    if (!this.page) {
      this.error('No page available')
    }

    this.log(`üîê Navigating to ${url}...`)
    await this.page!.goto(url, { waitUntil: 'domcontentloaded' })
    
    const checkSelector = readySelector || 'body'
    
    this.log(`‚è≥ Waiting for you to log in...`)
    this.log(`   (Looking for element: ${checkSelector})`)
    this.log(`   Press Ctrl+C to cancel`)
    
    // Check if already logged in
    try {
      await this.page!.waitForSelector(checkSelector, { timeout: 1000 })
      this.log('‚úÖ Already logged in!')
      return
    } catch {
      // Not logged in yet, continue waiting
    }
    
    // Wait for login with visual feedback
    let dots = 0
    const loadingInterval = setInterval(() => {
      process.stdout.write(`\r‚è≥ Waiting for login${'.'.repeat(dots % 4)}    `)
      dots++
    }, 500)
    
    try {
      // Wait for either the ready selector or a common logged-in indicator
      await this.page!.waitForSelector(checkSelector, { timeout: 300000 }) // 5 minute timeout
      
      clearInterval(loadingInterval)
      process.stdout.write('\r')
      this.log('‚úÖ Login detected! Continuing...')
      
      // Give the page a moment to fully load after login
      await this.page!.waitForLoadState('networkidle')
    } catch (error: any) {
      clearInterval(loadingInterval)
      process.stdout.write('\r')
      if (error.name === 'TimeoutError') {
        this.error('Timeout waiting for login (5 minutes)')
      }
      throw error
    }
  }

  /**
   * Enhanced error handler
   */
  protected handleError(error: Error | string): never {
    const err = typeof error === 'string' ? new Error(error) : error
    
    // Display error with tips if not in JSON mode
    if (!this.jsonEnabled()) {
      displayErrorWithTip(err, this.constructor.name.toLowerCase())
    }
    
    // Call parent error method
    this.exit(1)
  }

  /**
   * Log error with tips but don't exit
   */
  protected logError(error: Error, command?: string): void {
    if (!this.jsonEnabled()) {
      displayErrorWithTip(error, command || this.constructor.name.toLowerCase())
    } else {
      this.logToStderr(error.message)
    }
  }

  async finally(): Promise<void> {
    if (this.browser) {
      if (this.isLaunched) {
        if (this.keepOpen) {
          this.log('üîì Keeping Chrome open (use --no-keepOpen to close automatically)')
          // Just disconnect, don't close the browser
          // Just disconnect by not closing the browser
          // Browser remains open
        } else {
          this.log('üîí Closing Chrome...')
          await this.browser.close()
        }
      } else {
        // Was connected to existing instance, just disconnect
        // Browser remains open
      }
    }
  }
}
</file>

</files>
